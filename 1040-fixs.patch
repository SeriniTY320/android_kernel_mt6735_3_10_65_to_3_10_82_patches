From 173f1199e301b4dced11fd38028e8a1871e7891d Mon Sep 17 00:00:00 2001
From: Jan Engelmohr <jan.engelmohr@mailbox.tu-dresden.de>
Date: Sat, 9 Apr 2016 14:10:44 +0200
Subject: [PATCH 1040/1168] fixs

Former-commit-id: ca8d0a92729f33a2f06aba1c7f92e0663b18a95f
---
 arch/arm/vfp/Makefile                              |   2 +-
 arch/arm64/configs/benefit_m7_defconfig            |   1 +
 block/Kconfig.iosched                              |   7 -
 block/Makefile                                     |   3 -
 drivers/misc/mediatek/Makefile                     |   3 -
 .../mach/mt6735/benefit_m7/core/logger_custom.h    |   8 +-
 .../mach/mt6735/k05ts_a/power/cust_battery_meter.h | 128 ++++++++++
 drivers/mmc/core/mmc.c                             |   9 +
 drivers/staging/android/logger.h                   |  16 +-
 fs/Kconfig                                         |   4 +
 fs/namespace.c                                     |   7 +
 fs/pipe.c                                          |   2 +-
 fs/sync.c                                          | 263 +++++++++++++++------
 include/linux/cpufreq.h                            |   4 -
 include/linux/fs.h                                 |   5 +
 kernel/power/Kconfig                               |  11 +-
 kernel/power/suspend.c                             |  13 -
 17 files changed, 368 insertions(+), 118 deletions(-)
 create mode 100644 drivers/misc/mediatek/mach/mt6735/k05ts_a/power/cust_battery_meter.h

diff --git a/arch/arm/vfp/Makefile b/arch/arm/vfp/Makefile
index a81404c..4345ce0 100644
--- a/arch/arm/vfp/Makefile
+++ b/arch/arm/vfp/Makefile
@@ -7,7 +7,7 @@
 # ccflags-y := -DDEBUG
 # asflags-y := -DDEBUG
 
-KBUILD_AFLAGS	:=$(KBUILD_AFLAGS:-msoft-float=-Wa,-mfpu=softvfp+vfp -mfloat-abi=soft)
+KBUILD_AFLAGS	:=$(KBUILD_AFLAGS:-mhard-float=-Wa,-mfpu=neon)
 LDFLAGS		+=--no-warn-mismatch
 
 obj-y			+= vfp.o
diff --git a/arch/arm64/configs/benefit_m7_defconfig b/arch/arm64/configs/benefit_m7_defconfig
index 25d896b..bac0cfb 100644
--- a/arch/arm64/configs/benefit_m7_defconfig
+++ b/arch/arm64/configs/benefit_m7_defconfig
@@ -1033,6 +1033,7 @@ CONFIG_MTK_AUTO_DETECT_ACCELEROMETER=y
 CONFIG_CUSTOM_KERNEL_ACCELEROMETER=y
 CONFIG_CUSTOM_KERNEL_GYROSCOPE=y
 CONFIG_CUSTOM_KERNEL_ALSPS=y
+CONFIG_ASYNC_FSYNC=y
 # CONFIG_CUSTOM_SEC_AUTH_SUPPORT is not set
 CONFIG_CUSTOM_KERNEL_MAGNETOMETER=y
 # CONFIG_CUSTOM_KERNEL_BAROMETER is not set
diff --git a/block/Kconfig.iosched b/block/Kconfig.iosched
index cea16f9..f89955d 100644
--- a/block/Kconfig.iosched
+++ b/block/Kconfig.iosched
@@ -21,9 +21,6 @@ config IOSCHED_DEADLINE
 	  a new point in the service tree and doing a batch of IO from there
 	  in case of expiry.
 
-<<<<<<< HEAD
- config IOSCHED_SIO
-=======
 config IOSCHED_ROW
 	tristate "ROW I/O scheduler"
 	default y
@@ -36,7 +33,6 @@ config IOSCHED_ROW
 	  Most suitable for mobile devices.
 
 config IOSCHED_SIO
->>>>>>> 0f3243c... Add ROW IO scheduler.
 	tristate "Simple I/O scheduler"
 	default y
 	---help---
@@ -98,11 +94,8 @@ endchoice
 config DEFAULT_IOSCHED
 	string
 	default "deadline" if DEFAULT_DEADLINE
-<<<<<<< HEAD
-=======
 	default "row" if DEFAULT_ROW
 	default "sio" if DEFAULT_SIO
->>>>>>> 0f3243c... Add ROW IO scheduler.
 	default "cfq" if DEFAULT_CFQ
 	default "noop" if DEFAULT_NOOP
 	default "sioplus" if DEFAULT_SIOPLUS
diff --git a/block/Makefile b/block/Makefile
index 9d78f71..3f1adcb 100644
--- a/block/Makefile
+++ b/block/Makefile
@@ -14,11 +14,8 @@ obj-$(CONFIG_BLK_CGROUP)	+= blk-cgroup.o
 obj-$(CONFIG_BLK_DEV_THROTTLING)	+= blk-throttle.o
 obj-$(CONFIG_IOSCHED_NOOP)	+= noop-iosched.o
 obj-$(CONFIG_IOSCHED_DEADLINE)	+= deadline-iosched.o
-<<<<<<< HEAD
-=======
 obj-$(CONFIG_IOSCHED_ROW)	+= row-iosched.o
 obj-$(CONFIG_IOSCHED_SIO)       += sio-iosched.o
->>>>>>> 0f3243c... Add ROW IO scheduler.
 obj-$(CONFIG_IOSCHED_CFQ)	+= cfq-iosched.o
 obj-$(CONFIG_IOSCHED_SIOPLUS)   += sioplus-iosched.o
 obj-$(CONFIG_IOSCHED_SIO)       += sio-iosched.o
diff --git a/drivers/misc/mediatek/Makefile b/drivers/misc/mediatek/Makefile
index b50b92d..9b99a0f 100755
--- a/drivers/misc/mediatek/Makefile
+++ b/drivers/misc/mediatek/Makefile
@@ -258,10 +258,7 @@ obj-y	+= selinux_warning/
 # MTK PASR SW flow
 obj-$(CONFIG_MTKPASR)	+= mtkpasr/
 
-<<<<<<< HEAD
 
-=======
->>>>>>> ad43ce2... make it possible to mrproper
 obj-$(CONFIG_MTK_SWITCH_TX_POWER) += sw_tx_power/
 
 #charge pump
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/core/logger_custom.h b/drivers/misc/mediatek/mach/mt6735/benefit_m7/core/logger_custom.h
index 7ffb8df..062f44a 100755
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/core/logger_custom.h
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/core/logger_custom.h
@@ -3,10 +3,10 @@
 
 #include <generated/autoconf.h>
 
-#define __MAIN_BUF_SIZE 64*1024 
-#define __EVENTS_BUF_SIZE 256*1024 
-#define __RADIO_BUF_SIZE 64*1024 
-#define __SYSTEM_BUF_SIZE 64*1024
+#define __MAIN_BUF_SIZE 32*1024 
+#define __EVENTS_BUF_SIZE 64*1024 
+#define __RADIO_BUF_SIZE 32*1024 
+#define __SYSTEM_BUF_SIZE 32*1024
 
 #endif /* __LOGGER_CUSTOM_H */
 
diff --git a/drivers/misc/mediatek/mach/mt6735/k05ts_a/power/cust_battery_meter.h b/drivers/misc/mediatek/mach/mt6735/k05ts_a/power/cust_battery_meter.h
new file mode 100644
index 0000000..59e14b2
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/k05ts_a/power/cust_battery_meter.h
@@ -0,0 +1,128 @@
+#ifndef _CUST_BATTERY_METER_H
+#define _CUST_BATTERY_METER_H
+
+#include <mach/mt_typedefs.h>
+
+// ============================================================
+// define
+// ============================================================
+//#define SOC_BY_AUXADC
+#define SOC_BY_HW_FG
+//#define HW_FG_FORCE_USE_SW_OCV
+//#define SOC_BY_SW_FG
+
+//#define CONFIG_DIS_CHECK_BATTERY
+//#define FIXED_TBAT_25
+
+/* ADC resistor  */
+#define R_BAT_SENSE 4					
+#define R_I_SENSE 4						
+#define R_CHARGER_1 330
+#define R_CHARGER_2 39
+
+#define TEMPERATURE_T0             110
+#define TEMPERATURE_T1             0
+#define TEMPERATURE_T2             25
+#define TEMPERATURE_T3             50
+#define TEMPERATURE_T              255 // This should be fixed, never change the value
+
+#define FG_METER_RESISTANCE 	0
+
+/* Qmax for battery  */
+#define Q_MAX_POS_50	4341
+#define Q_MAX_POS_25	4330
+#define Q_MAX_POS_0		4279
+#define Q_MAX_NEG_10	3921
+
+#define Q_MAX_POS_50_H_CURRENT	4284
+#define Q_MAX_POS_25_H_CURRENT	4264
+#define Q_MAX_POS_0_H_CURRENT	  3366
+#define Q_MAX_NEG_10_H_CURRENT	1741
+
+
+/* Discharge Percentage */
+#define OAM_D5		 1		//  1 : D5,   0: D2
+
+
+/* battery meter parameter */
+#define CHANGE_TRACKING_POINT
+#ifdef CONFIG_MTK_HAFG_20
+#define CUST_TRACKING_POINT  0
+#else
+#define CUST_TRACKING_POINT  1
+#endif
+#define CUST_R_SENSE         10//10mO for k05ts_a so we have faster charging
+#define CUST_HW_CC 		    0
+#define AGING_TUNING_VALUE   103
+#define CUST_R_FG_OFFSET    0
+
+#define OCV_BOARD_COMPESATE	0 //mV 
+#define R_FG_BOARD_BASE		1000
+#define R_FG_BOARD_SLOPE	1000 //slope
+#define CAR_TUNE_VALUE		86 //1.00
+
+
+/* HW Fuel gague  */
+#define CURRENT_DETECT_R_FG	10  //1mA
+#define MinErrorOffset       1000
+#define FG_VBAT_AVERAGE_SIZE 18
+#define R_FG_VALUE 			10 // mOhm, base is 20
+
+/* fg 2.0 */
+#define DIFFERENCE_HWOCV_RTC		30
+#define DIFFERENCE_HWOCV_SWOCV		10
+#define DIFFERENCE_SWOCV_RTC		10
+#define MAX_SWOCV			3
+
+#define DIFFERENCE_VOLTAGE_UPDATE	20
+#define AGING1_LOAD_SOC			70
+#define AGING1_UPDATE_SOC		30
+#define BATTERYPSEUDO100		95
+#define BATTERYPSEUDO1			4
+
+#define Q_MAX_BY_SYS			//8. Qmax varient by system drop voltage.
+#define SHUTDOWN_GAUGE0
+#define SHUTDOWN_GAUGE1_XMINS
+#define SHUTDOWN_GAUGE1_MINS		60
+
+#define SHUTDOWN_SYSTEM_VOLTAGE		3400
+#define CHARGE_TRACKING_TIME		60
+#define DISCHARGE_TRACKING_TIME		10
+
+#define RECHARGE_TOLERANCE		10
+/* SW Fuel Gauge */
+#define MAX_HWOCV			5
+#define MAX_VBAT			90
+#define DIFFERENCE_HWOCV_VBAT		30
+
+/* fg 1.0 */
+#define CUST_POWERON_DELTA_CAPACITY_TOLRANCE	30
+#define CUST_POWERON_LOW_CAPACITY_TOLRANCE		5
+#define CUST_POWERON_MAX_VBAT_TOLRANCE			90
+#define CUST_POWERON_DELTA_VBAT_TOLRANCE		30
+#define CUST_POWERON_DELTA_HW_SW_OCV_CAPACITY_TOLRANCE	10
+
+
+/* Disable Battery check for HQA */
+#ifdef CONFIG_MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION
+#define FIXED_TBAT_25
+#endif
+
+/* Dynamic change wake up period of battery thread when suspend*/
+#define VBAT_NORMAL_WAKEUP		3600		//3.6V
+#define VBAT_LOW_POWER_WAKEUP		3500		//3.5v
+#define NORMAL_WAKEUP_PERIOD		5400 		//90 * 60 = 90 min
+#define LOW_POWER_WAKEUP_PERIOD		300		//5 * 60 = 5 min
+#define CLOSE_POWEROFF_WAKEUP_PERIOD	30	//30 s
+
+#define INIT_SOC_BY_SW_SOC
+//#define SYNC_UI_SOC_IMM			//3. UI SOC sync to FG SOC immediately
+#define MTK_ENABLE_AGING_ALGORITHM	//6. Q_MAX aging algorithm
+#define MD_SLEEP_CURRENT_CHECK	//5. Gauge Adjust by OCV 9. MD sleep current check
+//#define Q_MAX_BY_CURRENT		//7. Qmax varient by current loading.
+
+#define FG_BAT_INT
+#define IS_BATTERY_REMOVE_BY_PMIC
+
+
+#endif	//#ifndef _CUST_BATTERY_METER_H
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 93a3b8f..1f72d8c 100755
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -56,6 +56,15 @@ static const unsigned int tacc_mant[] = {
 		__res & __mask;						\
 	})
 
+#ifdef CONFIG_ASYNC_FSYNC
+ static unsigned int perf_degr;
+ int emmc_perf_degr(void)
+ {
+  return perf_degr;
+ }
+ #endif
+ 
+
 /*
  * Given the decoded CSD structure, decode the raw CID to our CID structure.
  */
diff --git a/drivers/staging/android/logger.h b/drivers/staging/android/logger.h
index 49ce615..ecceb5c 100755
--- a/drivers/staging/android/logger.h
+++ b/drivers/staging/android/logger.h
@@ -78,35 +78,35 @@ struct logger_entry {
 #ifdef CONFIG_SMP
 /* mingjian, 20101208: define buffer size based on different products {*/
 #ifndef __MAIN_BUF_SIZE
-#define __MAIN_BUF_SIZE 256*1024
+#define __MAIN_BUF_SIZE 32*1024
 #endif
 
 #ifndef __EVENTS_BUF_SIZE
-#define __EVENTS_BUF_SIZE 256*1024
+#define __EVENTS_BUF_SIZE 32*1024
 #endif
 
 #ifndef __RADIO_BUF_SIZE
-#define __RADIO_BUF_SIZE 256*1024
+#define __RADIO_BUF_SIZE 32*1024
 #endif
 
 #ifndef __SYSTEM_BUF_SIZE
-#define __SYSTEM_BUF_SIZE 256*1024
+#define __SYSTEM_BUF_SIZE 32*1024
 #endif
 #else
 #ifndef __MAIN_BUF_SIZE
-#define __MAIN_BUF_SIZE 256*1024
+#define __MAIN_BUF_SIZE 32*1024
 #endif
 
 #ifndef __EVENTS_BUF_SIZE
-#define __EVENTS_BUF_SIZE 256*1024 
+#define __EVENTS_BUF_SIZE 32*1024 
 #endif
 
 #ifndef __RADIO_BUF_SIZE
-#define __RADIO_BUF_SIZE 64*1024
+#define __RADIO_BUF_SIZE 32*1024
 #endif
 
 #ifndef __SYSTEM_BUF_SIZE
-#define __SYSTEM_BUF_SIZE 64*1024
+#define __SYSTEM_BUF_SIZE 32*1024
 #endif
 #endif
 
diff --git a/fs/Kconfig b/fs/Kconfig
index fa8badd..a58ff1f 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -269,6 +269,10 @@ source "fs/nls/Kconfig"
 source "fs/dlm/Kconfig"
 source "fs/rawfs/Kconfig"
 
+ config ASYNC_FSYNC
+	bool "asynchronous fsync"
+	default y
+
 config DYNAMIC_FSYNC
 	bool "dynamic file sync control"
 	default n
diff --git a/fs/namespace.c b/fs/namespace.c
index 4235a44..e366809 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -2213,6 +2213,13 @@ static int do_new_mount(struct path *path, const char *fstype, int flags,
 	err = do_add_mount(real_mount(mnt), path, mnt_flags);
 	if (err)
 		mntput(mnt);
+ 	#ifdef CONFIG_ASYNC_FSYNC
+		if (!err && ((!strcmp(type, "ext4") &&
+		!strcmp(path->dentry->d_name.name, "data")) ||
+		(!strcmp(type, "fuse") &&
+		!strcmp(path->dentry->d_name.name, "emulated"))))
+		mnt->mnt_sb->fsync_flags |= FLAG_ASYNC_FSYNC;
+	#endif
 	return err;
 }
 
diff --git a/fs/pipe.c b/fs/pipe.c
index 3e7ab27..3678b9b 100644
--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -118,7 +118,7 @@ void pipe_wait(struct pipe_inode_info *pipe)
 
 static int
 pipe_iov_copy_from_user(void *addr, int *offset, struct iovec *iov,
-			size_t *remaining, int atomic)
+size_t *remaining, int atomic)
 {
 	unsigned long copy;
 
diff --git a/fs/sync.c b/fs/sync.c
index 5e98720..f1f880c 100644
--- a/fs/sync.c
+++ b/fs/sync.c
@@ -16,6 +16,9 @@
 #include <linux/quotaops.h>
 #include <linux/backing-dev.h>
 #include "internal.h"
+#ifdef CONFIG_ASYNC_FSYNC
+#include <linux/statfs.h>
+#endif
 
 #ifdef CONFIG_DYNAMIC_FSYNC
 extern bool early_suspend_active;
@@ -25,6 +28,15 @@ extern bool dyn_fsync_active;
 #define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \
 			SYNC_FILE_RANGE_WAIT_AFTER)
 
+#ifdef CONFIG_ASYNC_FSYNC
+#define FLAG_ASYNC_FSYNC        0x1
+static struct workqueue_struct *fsync_workqueue = NULL;
+struct fsync_work {
+	struct work_struct work;
+	char pathname[256];
+};
+#endif
+
 /*
  * Do the filesystem syncing work. For simple filesystems
  * writeback_inodes_sb(sb) just dirties buffers with inodes so we have to
@@ -34,6 +46,13 @@ extern bool dyn_fsync_active;
  */
 static int __sync_filesystem(struct super_block *sb, int wait)
 {
+	/*
+	 * This should be safe, as we require bdi backing to actually
+	 * write out data in the first place
+	 */
+	if (sb->s_bdi == &noop_backing_dev_info)
+		return 0;
+
 	if (wait)
 		sync_inodes_sb(sb);
 	else
@@ -72,78 +91,100 @@ int sync_filesystem(struct super_block *sb)
 }
 EXPORT_SYMBOL_GPL(sync_filesystem);
 
-static void sync_inodes_one_sb(struct super_block *sb, void *arg)
+static void sync_one_sb(struct super_block *sb, void *arg)
 {
 	if (!(sb->s_flags & MS_RDONLY))
-		sync_inodes_sb(sb);
-}
-
-static void sync_fs_one_sb(struct super_block *sb, void *arg)
-{
-	if (!(sb->s_flags & MS_RDONLY) && sb->s_op->sync_fs)
-		sb->s_op->sync_fs(sb, *(int *)arg);
+		__sync_filesystem(sb, *(int *)arg);
 }
 
-static void fdatawrite_one_bdev(struct block_device *bdev, void *arg)
+/*
+ * Sync all the data for all the filesystems (called by sys_sync() and
+ * emergency sync)
+ */
+void sync_filesystems(int wait)
 {
-	filemap_fdatawrite(bdev->bd_inode->i_mapping);
+	iterate_supers(sync_one_sb, &wait);
 }
 
-static void fdatawait_one_bdev(struct block_device *bdev, void *arg)
+/*
+ * sync everything.  Start out by waking pdflush, because that writes back
+ * all queues in parallel.
+ */
+static void do_sync(void)
 {
-	filemap_fdatawait(bdev->bd_inode->i_mapping);
+	wakeup_flusher_threads(0, WB_REASON_SYNC);
+	sync_filesystems(0);
+	sync_filesystems(1);
+	if (unlikely(laptop_mode))
+	laptop_sync_completion();
+	return;
 }
 
-#ifndef CONFIG_DYNAMIC_FSYNC
-static
-#endif
-void sync_filesystems(int wait)
-{
-	iterate_supers(sync_fs_one_sb, &wait);
-}
-#ifdef CONFIG_DYNAMIC_FSYNC
-EXPORT_SYMBOL_GPL(sync_filesystems);
-#endif
+static DEFINE_MUTEX(sync_mutex);	/* One do_sync() at a time. */
+static unsigned long sync_seq;		/* Many sync()s from one do_sync(). */
+					/*  Overflow harmless, extra wait. */
 
 /*
- * Sync everything. We start by waking flusher threads so that most of
- * writeback runs on all devices in parallel. Then we sync all inodes reliably
- * which effectively also waits for all flusher threads to finish doing
- * writeback. At this point all data is on disk so metadata should be stable
- * and we tell filesystems to sync their metadata via ->sync_fs() calls.
- * Finally, we writeout all block devices because some filesystems (e.g. ext2)
- * just write metadata (such as inodes or bitmaps) to block device page cache
- * and do not sync it on their own in ->sync_fs().
+ * Only allow one task to do sync() at a time, and further allow
+ * concurrent sync() calls to be satisfied by a single do_sync()
+ * invocation.
  */
 SYSCALL_DEFINE0(sync)
 {
-	int nowait = 0, wait = 1;
+	unsigned long snap;
+	unsigned long snap_done;
 
-	wakeup_flusher_threads(0, WB_REASON_SYNC);
-	iterate_supers(sync_inodes_one_sb, NULL);
-	iterate_supers(sync_fs_one_sb, &nowait);
-	iterate_supers(sync_fs_one_sb, &wait);
-	iterate_bdevs(fdatawrite_one_bdev, NULL);
-	iterate_bdevs(fdatawait_one_bdev, NULL);
-	if (unlikely(laptop_mode))
-		laptop_sync_completion();
+
+	snap = ACCESS_ONCE(sync_seq);
+	smp_mb();  /* Prevent above from bleeding into critical section. */
+	mutex_lock(&sync_mutex);
+	snap_done = sync_seq;
+
+
+	/*
+	 * If the value in snap is odd, we need to wait for the current
+	 * do_sync() to complete, then wait for the next one, in other
+	 * words, we need the value of snap_done to be three larger than
+	 * the value of snap.  On the other hand, if the value in snap is
+	 * even, we only have to wait for the next request to complete,
+	 * in other words, we need the value of snap_done to be only two
+	 * greater than the value of snap.  The "(snap + 3) & 0x1" computes
+	 * this for us (thank you, Linus!).
+	 */
+	if (ULONG_CMP_GE(snap_done, (snap + 3) & ~0x1)) {
+		/*
+		 * A full do_sync() executed between our two fetches from
+		 * sync_seq, so our work is done!
+		 */
+		smp_mb(); /* Order test with caller's subsequent code. */
+		mutex_unlock(&sync_mutex);
+		return 0;
+	}
+
+	/* Record the start of do_sync(). */
+	ACCESS_ONCE(sync_seq)++;
+	WARN_ON_ONCE((sync_seq & 0x1) != 1);
+	smp_mb(); /* Keep prior increment out of do_sync(). */
+
+	do_sync();
+
+	/* Record the end of do_sync(). */
+	smp_mb(); /* Keep subsequent increment out of do_sync(). */
+	ACCESS_ONCE(sync_seq)++;
+	WARN_ON_ONCE((sync_seq & 0x1) != 0);
+	mutex_unlock(&sync_mutex);
 	return 0;
 }
 
 static void do_sync_work(struct work_struct *work)
 {
-	int nowait = 0;
 
 	/*
 	 * Sync twice to reduce the possibility we skipped some inodes / pages
 	 * because they were temporarily locked
 	 */
-	iterate_supers(sync_inodes_one_sb, &nowait);
-	iterate_supers(sync_fs_one_sb, &nowait);
-	iterate_bdevs(fdatawrite_one_bdev, NULL);
-	iterate_supers(sync_inodes_one_sb, &nowait);
-	iterate_supers(sync_fs_one_sb, &nowait);
-	iterate_bdevs(fdatawrite_one_bdev, NULL);
+	sync_filesystems(0);
+	sync_filesystems(0);
 	printk("Emergency Sync complete\n");
 	kfree(work);
 }
@@ -193,9 +234,18 @@ SYSCALL_DEFINE1(syncfs, int, fd)
  */
 int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)
 {
+
+	#ifdef CONFIG_DYNAMIC_FSYNC
+	if (likely(dyn_fsync_active && !early_suspend_active))
+		return 0;
+	else {
+#endif
 	if (!file->f_op || !file->f_op->fsync)
 		return -EINVAL;
 	return file->f_op->fsync(file, start, end, datasync);
+#ifdef CONFIG_DYNAMIC_FSYNC
+	}
+#endif
 }
 EXPORT_SYMBOL(vfs_fsync_range);
 
@@ -209,47 +259,129 @@ EXPORT_SYMBOL(vfs_fsync_range);
  */
 int vfs_fsync(struct file *file, int datasync)
 {
-#ifdef CONFIG_DYNAMIC_FSYNC
-	if (likely(dyn_fsync_active && !early_suspend_active))
-		return 0;
-	else {
-#endif
 	return vfs_fsync_range(file, 0, LLONG_MAX, datasync);
-#ifdef CONFIG_DYNAMIC_FSYNC
-	}
-#endif	
 }
 EXPORT_SYMBOL(vfs_fsync);
 
+#ifdef CONFIG_ASYNC_FSYNC
+extern int emmc_perf_degr(void);
+#define LOW_STORAGE_THRESHOLD   786432
+int async_fsync(struct file *file, int fd)
+{
+	struct inode *inode = file->f_mapping->host;
+	struct super_block *sb = inode->i_sb;
+	struct kstatfs st;
+
+	if ((sb->fsync_flags & FLAG_ASYNC_FSYNC) == 0)
+		return 0;
+
+	if (!emmc_perf_degr())
+		return 0;
+
+	if (fd_statfs(fd, &st))
+		return 0;
+
+	if (st.f_bfree > LOW_STORAGE_THRESHOLD)
+		return 0;
+
+	return 1;
+}
+
+static int do_async_fsync(char *pathname)
+{
+	struct file *file;
+	int ret;
+	file = filp_open(pathname, O_RDWR, 0);
+	if (IS_ERR(file)) {
+		pr_debug("%s: can't open %s\n", __func__, pathname);
+		return -EBADF;
+	}
+	ret = vfs_fsync(file, 0);
+
+	filp_close(file, NULL);
+	return ret;
+}
+
+static void do_afsync_work(struct work_struct *work)
+{
+	struct fsync_work *fwork =
+		container_of(work, struct fsync_work, work);
+	int ret = -EBADF;
+
+	pr_debug("afsync: %s\n", fwork->pathname);
+	ret = do_async_fsync(fwork->pathname);
+	if (ret != 0 && ret != -EBADF)
+		pr_info("afsync return %d\n", ret);
+	else
+		pr_debug("afsync: %s done\n", fwork->pathname);
+	kfree(fwork);
+}
+#endif
+
 static int do_fsync(unsigned int fd, int datasync)
 {
 	struct fd f = fdget(fd);
 	int ret = -EBADF;
+#ifdef CONFIG_ASYNC_FSYNC
+	struct fsync_work *fwork;
+#endif
 
 	if (f.file) {
+		ktime_t fsync_t, fsync_diff;
+		char pathname[256], *path;
+		path = d_path(&(f.file->f_path), pathname, sizeof(pathname));
+		if (IS_ERR(path))
+			path = "(unknown)";
+#ifdef CONFIG_ASYNC_FSYNC
+		else if (async_fsync(f.file, fd)) {
+			if (!fsync_workqueue)
+				fsync_workqueue =
+					create_singlethread_workqueue("fsync");
+			if (!fsync_workqueue)
+				goto no_async;
+
+			if (IS_ERR(path))
+				goto no_async;
+
+			fwork = kmalloc(sizeof(*fwork), GFP_KERNEL);
+			if (fwork) {
+				strncpy(fwork->pathname, path,
+					sizeof(fwork->pathname) - 1);
+				INIT_WORK(&fwork->work, do_afsync_work);
+				queue_work(fsync_workqueue, &fwork->work);
+				fput(f.file);
+				return 0;
+			}
+		}
+no_async:
+#endif
+		fsync_t = ktime_get();
 		ret = vfs_fsync(f.file, datasync);
 		fdput(f);
+		fsync_diff = ktime_sub(ktime_get(), fsync_t);
+		if (ktime_to_ms(fsync_diff) >= 5000) {
+                        pr_info("VFS: %s pid:%d(%s)(parent:%d/%s)\
+				takes %lld ms to fsync %s.\n", __func__,
+				current->pid, current->comm,
+				current->parent->pid, current->parent->comm,
+				ktime_to_ms(fsync_diff), path);
+		}
 	}
 	return ret;
 }
 
 SYSCALL_DEFINE1(fsync, unsigned int, fd)
 {
-#ifdef CONFIG_DYNAMIC_FSYNC
+	#ifdef CONFIG_DYNAMIC_FSYNC
 	if (likely(dyn_fsync_active && !early_suspend_active))
 		return 0;
 	else
-#endif
+	#endif
 	return do_fsync(fd, 0);
 }
 
 SYSCALL_DEFINE1(fdatasync, unsigned int, fd)
 {
-#if 0
-	if (likely(dyn_fsync_active && !early_suspend_active))
-		return 0;
-	else
-#endif
 	return do_fsync(fd, 1);
 }
 
@@ -321,11 +453,10 @@ SYSCALL_DEFINE4(sync_file_range, int, fd, loff_t, offset, loff_t, nbytes,
 				unsigned int, flags)
 {
 #ifdef CONFIG_DYNAMIC_FSYNC
-if (likely(dyn_fsync_active && !early_suspend_active))
-return 0;
-else {
+	if (likely(dyn_fsync_active && !early_suspend_active))
+		return 0;
+	else {
 #endif
-
 	int ret;
 	struct fd f;
 	struct address_space *mapping;
@@ -406,7 +537,7 @@ out:
 	return ret;
 #ifdef CONFIG_DYNAMIC_FSYNC
 	}
-#endif	
+#endif
 }
 
 /* It would be nice if people remember that not all the world's an i386
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 889c130..e1dc034 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -399,14 +399,10 @@ extern struct cpufreq_governor cpufreq_gov_conservative;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_conservative)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTMAX)
 extern struct cpufreq_governor cpufreq_gov_smartmax;
-<<<<<<< HEAD
-#define CPUFREQ_DEFAULT_GOVERNOR (&cpufreq_gov_smartmax)
-=======
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_smartmax)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_WHEATLEY)
 extern struct cpufreq_governor cpufreq_gov_wheatley;
 #define CPUFREQ_DEFAULT_GOVERNOR (&cpufreq_gov_wheatley)
->>>>>>> b85d253... smartmax governor changes
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_HOTPLUG)
 extern struct cpufreq_governor cpufreq_gov_hotplug;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_hotplug)
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 056af1d..cfb2cc5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1312,6 +1312,10 @@ struct super_block {
 
 	/* Being remounted read-only */
 	int s_readonly_remount;
+#ifdef CONFIG_ASYNC_FSYNC
+	 #define FLAG_ASYNC_FSYNC 0x1
+	 unsigned int fsync_flags;
+	#endif
 };
 
 /* superblock cache pruning functions */
@@ -2080,6 +2084,7 @@ static inline void iterate_bdevs(void (*f)(struct block_device *, void *), void
 extern int sync_filesystem(struct super_block *);
 extern const struct file_operations def_blk_fops;
 extern const struct file_operations def_chr_fops;
+extern void sync_filesystems(int wait);
 extern const struct file_operations bad_sock_fops;
 #ifdef CONFIG_BLOCK
 extern int ioctl_by_bdev(struct block_device *, unsigned, unsigned long);
diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig
index 37f9f32..06f9b6a 100644
--- a/kernel/power/Kconfig
+++ b/kernel/power/Kconfig
@@ -625,15 +625,10 @@ config SUSPEND_TIME
 	  keeps statistics on the time spent in suspend in
 	  /sys/kernel/debug/suspend_time
 
-<<<<<<< HEAD
-<<<<<<< HEAD
- config PM_SYNC_BEFORE_SUSPEND
-=======
-config PM_SYNC_BEFORE_SUSPEND
->>>>>>> 7e69c4e... power: make sync on suspend optional
-=======
+
+
+
 config PM_SYNC_BEFORE_SUSPEND
->>>>>>> 7e69c4e... power: make sync on suspend optional
 	bool "Sync file systems before suspend"
 	depends on PM
 	default y
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index e94c9b1..5ce9df9 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -400,13 +400,7 @@ int enter_state(suspend_state_t state)
 
 	if (state == PM_SUSPEND_FREEZE)
 		freeze_begin();
-<<<<<<< HEAD
-=======
 
-<<<<<<< HEAD
->>>>>>> 7e69c4e... power: make sync on suspend optional
-=======
->>>>>>> 7e69c4e... power: make sync on suspend optional
 #ifdef CONFIG_PM_SYNC_BEFORE_SUSPEND
 	printk(KERN_INFO "PM: Syncing filesystems ... ");
 #if MTK_SOLUTION
@@ -420,13 +414,6 @@ int enter_state(suspend_state_t state)
 #endif
 	printk("done.\n");
 #endif
-<<<<<<< HEAD
-<<<<<<< HEAD
-=======
-=======
->>>>>>> 7e69c4e... power: make sync on suspend optional
-
->>>>>>> 7e69c4e... power: make sync on suspend optional
 	pr_debug("PM: Preparing system for %s sleep\n", pm_states[state].label);
 	error = suspend_prepare(state);
 	if (error)
-- 
2.7.4

