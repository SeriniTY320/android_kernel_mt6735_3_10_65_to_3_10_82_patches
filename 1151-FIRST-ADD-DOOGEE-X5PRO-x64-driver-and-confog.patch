From 3841b6c24f49dd9c5db5eb0218daab1d2643a338 Mon Sep 17 00:00:00 2001
From: SnowCatPDA <snowcat@vpro.ru>
Date: Tue, 24 May 2016 14:25:49 +0500
Subject: [PATCH 1151/1168] FIRST ADD DOOGEE X5PRO x64 driver and confog

---
 arch/arm64/configs/X5PRO_6735m_defconfig           | 3106 ++++++++++++++++++++
 .../mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c    |    2 +-
 .../lcm/hct_hx8394f_dsi_vdo_hd_cmi/Makefile        |   11 +
 .../hct_hx8394f_dsi_vdo_hd_cmi.c                   |  576 ++++
 .../lcm/hct_ili9881_dsi_vdo_hd_cpt/Makefile        |   10 +
 .../hct_ili9881_dsi_vdo_hd_cpt.c                   |  689 +++++
 .../lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile       |    9 +
 .../lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile~      |   13 +
 .../hct_otm1282a_dsi_vdo_hd_auo.c                  |  541 ++++
 .../hct_otm1282a_dsi_vdo_hd_auo.c~                 |  902 ++++++
 .../lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile        |   11 +
 .../lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile~       |   15 +
 .../hct_rm68200_dsi_vdo_hd_cpt.c                   |  752 +++++
 .../hct_rm68200_dsi_vdo_hd_cpt.c~                  | 1055 +++++++
 drivers/misc/mediatek/lcm/mt65xx_lcm_list.c        |   20 +
 .../misc/mediatek/mach/mt6735/X5PRO_6735m/Makefile |   67 +
 .../mach/mt6735/X5PRO_6735m/accdet/Makefile        |    3 +
 .../mach/mt6735/X5PRO_6735m/accdet/accdet_custom.c |   28 +
 .../mach/mt6735/X5PRO_6735m/accdet/accdet_custom.h |   14 +
 .../mt6735/X5PRO_6735m/accdet/accdet_custom_def.h  |   28 +
 .../accelerometer/KXTJ2_1009-new/Makefile          |    4 +
 .../accelerometer/KXTJ2_1009-new/Makefile~         |    4 +
 .../KXTJ2_1009-new/kxtj2_1009_cust_acc.c           |   52 +
 .../mach/mt6735/X5PRO_6735m/alsps/epl2182/Makefile |    4 +
 .../mt6735/X5PRO_6735m/alsps/epl2182/cust_alsps.c  |   72 +
 .../mach/mt6735/X5PRO_6735m/camera/camera/Makefile |    6 +
 .../mt6735/X5PRO_6735m/camera/camera/dummyds.c     |    0
 .../X5PRO_6735m/camera/camera/kd_camera_hw.c       | 1676 +++++++++++
 .../X5PRO_6735m/camera/camera/kd_camera_hw.c~      | 1089 +++++++
 .../X5PRO_6735m/camera/camera/kd_camera_hw.h       |   51 +
 .../mediatek/mach/mt6735/X5PRO_6735m/codegen.dws   |  Bin 0 -> 29749 bytes
 .../mediatek/mach/mt6735/X5PRO_6735m/core/Makefile |    3 +
 .../mach/mt6735/X5PRO_6735m/core/board-custom.h    |  121 +
 .../mediatek/mach/mt6735/X5PRO_6735m/core/board.c  | 1217 ++++++++
 .../mach/mt6735/X5PRO_6735m/core/logger_custom.h   |   13 +
 .../mach/mt6735/X5PRO_6735m/dct/dct/Makefile       |    5 +
 .../mach/mt6735/X5PRO_6735m/dct/dct/codegen.dws    |  Bin 0 -> 29635 bytes
 .../mach/mt6735/X5PRO_6735m/dct/dct/cust_eint.dtsi |   68 +
 .../mach/mt6735/X5PRO_6735m/dct/dct/cust_i2c.dtsi  |   82 +
 .../mach/mt6735/X5PRO_6735m/dct/dct/pmic_drv.c     |   22 +
 .../X5PRO_6735m/gyroscope/ITG1010-new/Makefile     |    4 +
 .../X5PRO_6735m/gyroscope/ITG1010-new/cust_gyro.c  |   19 +
 .../mach/mt6735/X5PRO_6735m/keypad/Makefile        |    4 +
 .../mach/mt6735/X5PRO_6735m/keypad/mtk_kpd.h       |   81 +
 .../mach/mt6735/X5PRO_6735m/keypad/mtk_kpd_bkl.c   |   52 +
 .../mediatek/mach/mt6735/X5PRO_6735m/leds/Makefile |   21 +
 .../mach/mt6735/X5PRO_6735m/leds/mt65xx/Makefile   |    2 +
 .../mt6735/X5PRO_6735m/leds/mt65xx/cust_leds.c     |  120 +
 .../mt6735/X5PRO_6735m/leds/mt65xx/cust_leds.h     |   20 +
 .../mt6735/X5PRO_6735m/leds/mt65xx/cust_leds_def.h |   53 +
 .../X5PRO_6735m/magnetometer/akm09911-new/Makefile |    4 +
 .../magnetometer/akm09911-new/cust_mag.c           |   17 +
 .../X5PRO_6735m/magnetometer/mmc3416x/Makefile     |    4 +
 .../X5PRO_6735m/magnetometer/mmc3416x/cust_mag.c   |   17 +
 .../mt6735/X5PRO_6735m/power/cust_battery_meter.h  |  127 +
 .../X5PRO_6735m/power/cust_battery_meter_table.h   | 1108 +++++++
 .../mach/mt6735/X5PRO_6735m/power/cust_charging.h  |  113 +
 .../mach/mt6735/X5PRO_6735m/power/cust_pe.h        |   21 +
 .../mach/mt6735/X5PRO_6735m/power/cust_pmic.h      |   92 +
 .../mediatek/mach/mt6735/X5PRO_6735m/rtc/rtc-mt.h  |   47 +
 .../mach/mt6735/X5PRO_6735m/sound/Makefile         |    5 +
 .../X5PRO_6735m/sound/inc/external_codec_driver.h  |  104 +
 .../X5PRO_6735m/sound/inc/yusu_android_speaker.h   |  146 +
 .../X5PRO_6735m/sound/yusu_android_speaker.c       |  272 ++
 .../mach/mt6735/X5PRO_6735m/vibrator/Makefile      |    3 +
 .../mt6735/X5PRO_6735m/vibrator/cust_vibrator.c    |   18 +
 .../mt6735/X5PRO_6735m/vibrator/cust_vibrator.h    |   24 +
 tools/dct/DCT.log                                  |    8 -
 68 files changed, 14838 insertions(+), 9 deletions(-)
 create mode 100644 arch/arm64/configs/X5PRO_6735m_defconfig
 create mode 100755 drivers/misc/mediatek/lcm/hct_hx8394f_dsi_vdo_hd_cmi/Makefile
 create mode 100755 drivers/misc/mediatek/lcm/hct_hx8394f_dsi_vdo_hd_cmi/hct_hx8394f_dsi_vdo_hd_cmi.c
 create mode 100755 drivers/misc/mediatek/lcm/hct_ili9881_dsi_vdo_hd_cpt/Makefile
 create mode 100755 drivers/misc/mediatek/lcm/hct_ili9881_dsi_vdo_hd_cpt/hct_ili9881_dsi_vdo_hd_cpt.c
 create mode 100644 drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile
 create mode 100644 drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile~
 create mode 100644 drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c
 create mode 100644 drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c~
 create mode 100644 drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile
 create mode 100644 drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile~
 create mode 100644 drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c
 create mode 100644 drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c~
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom.c
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom_def.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile~
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/kxtj2_1009_cust_acc.c
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/alsps/epl2182/Makefile
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/alsps/epl2182/cust_alsps.c
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/dummyds.c
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.c
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.c~
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/codegen.dws
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/board-custom.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/board.c
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/logger_custom.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/codegen.dws
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/cust_eint.dtsi
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/cust_i2c.dtsi
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/pmic_drv.c
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/gyroscope/ITG1010-new/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/gyroscope/ITG1010-new/cust_gyro.c
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/mtk_kpd.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/mtk_kpd_bkl.c
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/Makefile
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds.c
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds.h
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds_def.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/akm09911-new/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/akm09911-new/cust_mag.c
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/mmc3416x/Makefile
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/mmc3416x/cust_mag.c
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_battery_meter.h
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_battery_meter_table.h
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_charging.h
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_pe.h
 create mode 100644 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_pmic.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/rtc/rtc-mt.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/inc/external_codec_driver.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/inc/yusu_android_speaker.h
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/yusu_android_speaker.c
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/Makefile
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/cust_vibrator.c
 create mode 100755 drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/cust_vibrator.h
 delete mode 100644 tools/dct/DCT.log

diff --git a/arch/arm64/configs/X5PRO_6735m_defconfig b/arch/arm64/configs/X5PRO_6735m_defconfig
new file mode 100644
index 0000000..0ae109d
--- /dev/null
+++ b/arch/arm64/configs/X5PRO_6735m_defconfig
@@ -0,0 +1,3106 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm64 3.10.101 Kernel Configuration
+#
+CONFIG_ARM64=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_64BIT=y
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_MMU=y
+CONFIG_NO_IOPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_ARM_ERRATA_824069 is not set
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="aarch64-linux-android-"
+CONFIG_LOCALVERSION="-oleg.svs-Benefit-M7-v0.7-B"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_FHANDLE is not set
+CONFIG_AUDIT=y
+CONFIG_AUDIT_WATCH=n
+CONFIG_AUDIT_TREE=n
+CONFIG_AUDITSYSCALL=n
+# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_DEBUG=n
+CONFIG_SPARSE_IRQ=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_FANOUT=32
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_RCU_NOCB_CPU is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_MEMCG is not set
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_UIDGID_CONVERTED=y
+# CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HOTPLUG=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_64BIT_ALIGNED_ACCESS=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_IOSCHED_SIO=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_SIO=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="sio"
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Platform selection
+#
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_MT6735 is not set
+CONFIG_ARCH_MT6735M=y
+# CONFIG_ARCH_MT6753 is not set
+# CONFIG_ARCH_MT6752 is not set
+# CONFIG_ARCH_MT8163 is not set
+# CONFIG_ARCH_MT6795 is not set
+
+#
+# MTK Board Support Package
+#
+CONFIG_MTK_EVB_BOARD=y
+# CONFIG_MTK_FPGA is not set
+CONFIG_MTK_PSCI=y
+CONFIG_MAX_DRAM_SIZE_SUPPORT=0x10000000
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+
+#
+# Kernel Features
+#
+# CONFIG_ARM64_64K_PAGES is not set
+CONFIG_SMP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+# CONFIG_SCHED_MC is not set
+# CONFIG_SCHED_SMT is not set
+# CONFIG_DISABLE_CPU_SCHED_DOMAIN_BALANCE is not set
+# CONFIG_HEVTASK_INTERFACE is not set
+# CONFIG_ARCH_SCALE_INVARIANT_CPU_CAPACITY is not set
+CONFIG_NR_CPUS=8
+CONFIG_SWP_EMULATE=y
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+CONFIG_ARCH_HAS_HOLES_MEMORYMODEL=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARMV7_COMPAT=y
+CONFIG_ARMV7_COMPAT_CPUINFO=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_PM_SYNC_BEFORE_SUSPEND=n
+CONFIG_KSM=y
+CONFIG_UKSM=y
+# CONFIG_KSM_LEGACY is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_SECCOMP=y
+CONFIG_SECCOMP_FILTER=y
+
+#
+# Boot options
+#
+CONFIG_CMDLINE="console=tty0 console=ttyMT3,921600n1 root=/dev/ram vmalloc=496M slub_max_order=0 slub_debug=O "
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE=y
+CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE_NAMES="benefit_m7"
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVEPLUS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTMAX is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_WHEATLEY=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTELLIACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_BALANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_HOTPLUG is not set
+# CONFIG_CPU_FREQ_GOV_BALANCE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_INTERACTIVEPLUS is not set
+# CONFIG_CPU_FREQ_GOV_SMARTMAX is not set
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_GOV_HOTPLUG is not set
+CONFIG_CPU_FREQ_GOV_WHEATLEY=y
+CONFIG_CPU_FREQ_GOV_INTELLIACTIVE=y
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_EXYNOS4210_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS4X12_CPUFREQ is not set
+# CONFIG_ARM_EXYNOS5250_CPUFREQ is not set
+# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+CONFIG_COMPAT=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_HAS_SBSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_TOI_CORE=y
+
+#
+# Image Storage (you need at least one allocator)
+#
+# CONFIG_TOI_FILE is not set
+CONFIG_TOI_SWAP=y
+
+#
+# General Options
+#
+CONFIG_TOI_CRYPTO=y
+CONFIG_TOI_DEFAULT_IMAGE_SIZE_LIMIT=-2
+# CONFIG_TOI_KEEP_IMAGE is not set
+CONFIG_TOI_REPLACE_SWSUSP=y
+# CONFIG_TOI_IGNORE_LATE_INITCALL is not set
+CONFIG_TOI_DEFAULT_WAIT=2
+CONFIG_TOI_DEFAULT_EXTRA_PAGES_ALLOWANCE=2000
+# CONFIG_TOI_CHECKSUM is not set
+CONFIG_TOI=y
+CONFIG_TOI_ZRAM_SUPPORT=y
+CONFIG_TOI_FIXUP=y
+CONFIG_TOI_ENHANCE=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+CONFIG_PM_WAKELOCKS_LIMIT=0
+CONFIG_PM_WAKELOCKS_GC=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_CLK=y
+CONFIG_SUSPEND_TIME=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM64_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_NET=y
+CONFIG_COMPAT_NETLINK_MESSAGES=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_ALGO=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+CONFIG_XFRM_MIGRATE=y
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_ROUTE_CLASSID=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=y
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_ARPD=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_IPVTI is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=y
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+# CONFIG_IPV6_GRE is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+# CONFIG_IPV6_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_MTK_DHCPV6C_WIFI=y
+# CONFIG_NETLABEL is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+# CONFIG_NF_CONNTRACK_SECMARK is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+CONFIG_NF_CT_PROTO_GRE=y
+# CONFIG_NF_CT_PROTO_SCTP is not set
+CONFIG_NF_CT_PROTO_UDPLITE=y
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+CONFIG_NF_CONNTRACK_FTP=y
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+# CONFIG_NF_CONNTRACK_SANE is not set
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE_CT is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+# CONFIG_NF_NAT_AMANDA is not set
+CONFIG_NF_NAT_FTP=y
+# CONFIG_NF_NAT_IRC is not set
+CONFIG_NF_NAT_SIP=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_HL=y
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=y
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+# CONFIG_NETFILTER_XT_TARGET_LOG is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NETMAP=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+CONFIG_NETFILTER_XT_TARGET_REDIRECT=y
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+# CONFIG_NETFILTER_XT_TARGET_SECMARK is not set
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNTRACK is not set
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=y
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+CONFIG_NETFILTER_XT_MATCH_REALM=y
+CONFIG_NETFILTER_XT_MATCH_RECENT=y
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_REJECT_SKERR is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT_IPV4=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PPTP=y
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+# CONFIG_IP_NF_SECURITY is not set
+CONFIG_IP_NF_ARPTABLES=y
+# CONFIG_IP_NF_ARPFILTER is not set
+# CONFIG_IP_NF_ARP_MANGLE is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+CONFIG_IP6_NF_MATCH_FRAG=y
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+CONFIG_IP6_NF_MATCH_IPV6HEADER=y
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+CONFIG_IP6_NF_TARGET_HL=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP6_NF_SECURITY is not set
+# CONFIG_NF_NAT_IPV6 is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+# CONFIG_BRIDGE_VLAN_FILTERING is not set
+CONFIG_HAVE_NET_DSA=y
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+CONFIG_NET_SCH_INGRESS=y
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+CONFIG_NET_CLS_FW=y
+CONFIG_NET_CLS_U32=y
+CONFIG_CLS_U32_PERF=y
+CONFIG_CLS_U32_MARK=y
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+CONFIG_NET_CLS_FLOW=y
+# CONFIG_NET_CLS_CGROUP is not set
+# CONFIG_NET_EMATCH is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+# CONFIG_NET_ACT_GACT is not set
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_NET_ACT_IPT=y
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+CONFIG_NET_CLS_IND=y
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_NET_DROP_MONITOR=y
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_DEVELOPER_WARNINGS=y
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+# CONFIG_CFG80211_DEFAULT_PS is not set
+# CONFIG_CFG80211_DEBUGFS is not set
+CONFIG_CFG80211_INTERNAL_REGDB=y
+CONFIG_CFG80211_WEXT=y
+# CONFIG_LIB80211 is not set
+CONFIG_CFG80211_ALLOW_RECONNECT=y
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_MTK_NET_LOGGING is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_HAVE_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_DMA_SHARED_BUFFER=y
+
+#
+# Bus devices
+#
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Device Tree and Open Firmware support
+#
+# CONFIG_PROC_DEVICETREE is not set
+# CONFIG_OF_SELFTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_DEVICE=y
+CONFIG_OF_I2C=y
+CONFIG_OF_NET=y
+CONFIG_OF_MTD=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_ANDROID_PMEM is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+CONFIG_THUNDERQUAKE_ENGINE_GPL=y
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+# pocket mode (avoid dt2w to be active while proximity sensor is triggered)
+CONFIG_POCKETMOD=n
+CONFIG_DYNAMIC_FSYNC=y
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_MEDIATEK_SOLUTION=y
+CONFIG_MTK_PLATFORM="mt6735"
+CONFIG_ARCH_MTK_PROJECT="X5PRO_6735m"
+# CONFIG_MTK_INTERNAL is not set
+CONFIG_MTK_CIRQ=y
+CONFIG_MTK_SYS_CIRQ=y
+CONFIG_MTK_SYSTRACKER=y
+# CONFIG_MTK_L2C_SHARE is not set
+CONFIG_HAVE_AEE_FEATURE=y
+CONFIG_HAVE_XLOG_FEATURE=y
+# CONFIG_FPGA_EARLY_PORTING is not set
+CONFIG_MTK_EMMC_SUPPORT=y
+CONFIG_MTK_NEW_COMBO_EMMC_SUPPORT=y
+CONFIG_MTK_GPT_SCHEME_SUPPORT=y
+CONFIG_MTK_SHARED_SDCARD=y
+CONFIG_MTK_MULTI_STORAGE_SUPPORT=y
+# CONFIG_MTK_MULTI_PARTITION_MOUNT_ONLY_SUPPORT is not set
+CONFIG_MTK_SECURITY_SW_SUPPORT=y
+# CONFIG_HAVE_MTK_IN_HOUSE_TEE_SUPPORT is not set
+# CONFIG_HAVE_TRUSTONIC_TEE_SUPPORT is not set
+# CONFIG_MTK_THERMAL_STATUS_COLLECTION is not set
+# CONFIG_MD32_SUPPORT is not set
+# CONFIG_MTK_MEMCFG is not set
+# CONFIG_MTK_DT_SUPPORT is not set
+# CONFIG_MTK_SMARTBOOK_SUPPORT is not set
+CONFIG_MTK_SENSOR_SUPPORT=y
+CONFIG_MTK_AUTO_DETECT_ACCELEROMETER=y
+# CONFIG_MTK_AUTO_DETECT_MAGNETOMETER is not set
+#CONFIG_MTK_AUTO_DETECT_ALSPS=y
+CONFIG_CUSTOM_KERNEL_ACCELEROMETER=y
+#CONFIG_CUSTOM_KERNEL_GYROSCOPE=y
+CONFIG_CUSTOM_KERNEL_ALSPS=y
+CONFIG_ASYNC_FSYNC=y
+# CONFIG_CUSTOM_SEC_AUTH_SUPPORT is not set
+#CONFIG_CUSTOM_KERNEL_MAGNETOMETER=y
+# CONFIG_CUSTOM_KERNEL_BAROMETER is not set
+# CONFIG_MTK_SENSOR_HUB_SUPPORT is not set
+CONFIG_CUSTOM_KERNEL_SENSORHUB=""
+CONFIG_CUSTOM_KERNEL_STEP_COUNTER=""
+CONFIG_CUSTOM_KERNEL_SIGNIFICANT_MOTION_SENSOR=""
+CONFIG_CUSTOM_KERNEL_ACTIVITY_SENSOR=""
+CONFIG_CUSTOM_KERNEL_PICK_UP_SENSOR=""
+CONFIG_CUSTOM_KERNEL_SHAKE_SENSOR=""
+CONFIG_CUSTOM_KERNEL_FACE_DOWN_SENSOR=""
+CONFIG_CUSTOM_KERNEL_IN_POCKET_SENSOR=""
+CONFIG_CUSTOM_KERNEL_PEDOMETER=""
+CONFIG_CUSTOM_KERNEL_HEART_RATE_SENSOR=""
+CONFIG_CUSTOM_KERNEL_TILT_DETECTOR_SENSOR=""
+CONFIG_CUSTOM_KERNEL_WAKE_GESTURE_SENSOR=""
+CONFIG_CUSTOM_KERNEL_GLANCE_GESTURE_SENSOR=""
+CONFIG_CUSTOM_KERNEL_IMGSENSOR="gc2355_mipi_raw s5k5e2ya_mipi_raw"
+CONFIG_CUSTOM_KERNEL_CAM_CAL_DRV="imx219_eeprom"
+CONFIG_CUSTOM_KERNEL_LCM="hct_otm1282a_dsi_vdo_hd_auo hct_rm68200_dsi_vdo_hd_cpt hct_ili9881_dsi_vdo_hd_cpt"
+CONFIG_CUSTOM_KERNEL_FLASHLIGHT="constant_flashlight"
+CONFIG_CUSTOM_KERNEL_EXTMD=""
+CONFIG_CUSTOM_KERNEL_SSW="ssw_single_v2"
+# CONFIG_MTK_FORCE_CLUSTER1 is not set
+# CONFIG_MTK_MMPROFILE_SUPPORT is not set
+CONFIG_MTK_HIBERNATION=y
+# CONFIG_CUSTOM_KERNEL_CHARGEPUMP is not set
+# CONFIG_MTK_TC1_FEATURE is not set
+# CONFIG_MTK_TC7_FEATURE is not set
+# CONFIG_MTK_TC1_FM_AT_SUSPEND is not set
+
+#
+# Kernel Configurations
+#
+
+#
+# Tracer Related
+#
+# CONFIG_MTK_SCHED_TRACERS is not set
+# CONFIG_MTK_KERNEL_MARKER is not set
+# CONFIG_MT65XX_TRACER is not set
+
+#
+# MET
+#
+CONFIG_MTK_MET=y
+CONFIG_MTK_MET_PLF=y
+
+#
+# MTPROF tools
+#
+CONFIG_MTK_MUTATION=y
+CONFIG_MTPROF_CPUTIME=y
+# CONFIG_MTPROF_IRQ_DURATION is not set
+CONFIG_MTK_AEE_FEATURE=y
+CONFIG_MTK_AEE_AED=y
+CONFIG_MTK_AEE_IPANIC=y
+# CONFIG_MTK_AEE_POWERKEY_HANG_DETECT is not set
+# CONFIG_MTK_AEE_MRDUMP is not set
+# CONFIG_ANDROID_VMEM is not set
+# CONFIG_CPUTIME_SUPPORT is not set
+# CONFIG_CPUTIME_STATS is not set
+CONFIG_MTK_RAM_CONSOLE=y
+# CONFIG_MTK_RAM_CONSOLE_USING_SRAM is not set
+CONFIG_MTK_RAM_CONSOLE_USING_DRAM=y
+CONFIG_MTK_RAM_CONSOLE_SIZE=0x3000
+CONFIG_MTK_RAM_CONSOLE_ADDR=0xF912D000
+CONFIG_MTK_RAM_CONSOLE_DRAM_SIZE=0x10000
+CONFIG_MTK_RAM_CONSOLE_DRAM_ADDR=0x43F00000
+# CONFIG_PREEMPT_MONITOR is not set
+# CONFIG_ISR_MONITOR is not set
+# CONFIG_MT_SCHED_MONITOR is not set
+# CONFIG_MT_CHRDEV_REG is not set
+# CONFIG_MT_LOCK_DEBUG is not set
+CONFIG_PRINTK_PROCESS_INFO=y
+CONFIG_MT_PRINTK_UART_CONSOLE=n
+# CONFIG_MT_ENG_BUILD is not set
+CONFIG_RAMDISK_OFFSET=0xF00000
+# CONFIG_EARLY_LINUX_PORTING is not set
+# CONFIG_MTK_MCI is not set
+# CONFIG_MTK_ETM is not set
+
+#
+# MT load balance and schedule enhancement
+#
+CONFIG_MT_SCHED=y
+CONFIG_MT_LOAD_BALANCE_ENHANCEMENT=y
+# CONFIG_MT_LOAD_BALANCE_PROFILER is not set
+CONFIG_MTK_COMPAT=y
+CONFIG_MT_SCHED_INTEROP=y
+CONFIG_MTK_SCHED_RQAVG_US=y
+CONFIG_MTK_SCHED_RQAVG_KS=y
+# CONFIG_MT_PRIO_TRACER is not set
+# CONFIG_MT_SCHED_TRACE is not set
+# CONFIG_MT_DEBUG_PREEMPT is not set
+
+#
+# MTK Cluster MultiProcessor Scheduler
+#
+CONFIG_MTK_CPU_TOPOLOGY=y
+# CONFIG_MTK_WQ_DEBUG is not set
+CONFIG_MTK_STORAGE_PID_LOGGER=y
+
+#
+# MTK Large Memory mode support
+#
+# CONFIG_MTK_LM_MODE is not set
+# CONFIG_MTK_TABLET_HARDWARE is not set
+CONFIG_GATOR_DRIVER=y
+# CONFIG_MTK_IPV6_TETHER_NDP_MODE is not set
+# CONFIG_MTK_EMMC_SUPPORT_OTP is not set
+CONFIG_MTK_TETHERINGIPV6_SUPPORT=y
+CONFIG_MTK_LEGACY=y
+
+#
+# Drivers Configurations
+#
+# CONFIG_MTK_LDVT is not set
+CONFIG_MTK_ACCDET=y
+CONFIG_ACCDET_EINT=y
+# CONFIG_MTK_IRTX_SUPPORT is not set
+CONFIG_MTK_CCCI_DEVICES=y
+# CONFIG_MTK_CCCI_DRIVER is not set
+# CONFIG_MTK_CCCI_EXT is not set
+CONFIG_MTK_ECCCI_DRIVER=y
+CONFIG_MTK_ECCCI_CLDMA=y
+# CONFIG_MTK_ECCCI_CCIF is not set
+# CONFIG_MTK_ECCCI_UT is not set
+# CONFIG_MTK_MD_LOW_BAT_SUPPORT is not set
+CONFIG_MTK_NET_CCMNI=y
+CONFIG_MTK_ENABLE_MD1=y
+CONFIG_MTK_MD1_SUPPORT=6
+CONFIG_MD1_SIZE=0x5000000
+CONFIG_MD1_SMEM_SIZE=0x200000
+# CONFIG_MTK_ENABLE_MD2 is not set
+CONFIG_MTK_MD_SBP_CUSTOM_VALUE=""
+CONFIG_MTK_MD2_SBP_CUSTOM_VALUE=""
+CONFIG_MTK_UMTS_TDD128_MODE=y
+# CONFIG_MTK_EMCI_DEVICES is not set
+CONFIG_MTK_EXTERNAL_MODEM_SLOT=""
+# CONFIG_MTK_SWITCH_TX_POWER is not set
+CONFIG_MTK_CONN_LTE_IDC_SUPPORT=y
+CONFIG_MTK_FB=y
+CONFIG_MTK_FB_SUPPORT_ASSERTION_LAYER=y
+CONFIG_MTK_DITHERING_SUPPORT=y
+CONFIG_MTK_LCM_PHYSICAL_ROTATION="0"
+CONFIG_LCM_HEIGHT="1280"
+CONFIG_LCM_WIDTH="720"
+CONFIG_CUSTOM_LCM_X="0"
+CONFIG_CUSTOM_LCM_Y="0"
+# CONFIG_MTK_OVERLAY_ENGINE_SUPPORT is not set
+# CONFIG_MTK_TVOUT_SUPPORT is not set
+# CONFIG_MIXMODE_FOR_INCELL is not set
+# CONFIG_LCM_SEND_CMD_IN_VIDEO is not set
+CONFIG_GPS=y
+CONFIG_MTK_GPS=y
+# CONFIG_MTK_NFC is not set
+# CONFIG_NFC_MT6605 is not set
+# CONFIG_NFC_MSR3110 is not set
+CONFIG_MTK_BTIF=y
+CONFIG_MTK_COMBO=y
+# CONFIG_MTK_COMBO_CHIP_MT6620 is not set
+# CONFIG_MTK_COMBO_CHIP_MT6628 is not set
+# CONFIG_MTK_COMBO_CHIP_MT6630 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_6572 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_6582 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_8127 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_6752 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_6592 is not set
+# CONFIG_MTK_COMBO_CHIP_CONSYS_8163 is not set
+CONFIG_MTK_COMBO_CHIP_CONSYS_6735=y
+# CONFIG_MTK_COMBO_CHIP_CONSYS_6580 is not set
+CONFIG_MTK_COMBO_CHIP="CONSYS_6735"
+CONFIG_MTK_WAPI_SUPPORT=y
+CONFIG_MTK_PASSPOINT_R1_SUPPORT=y
+# CONFIG_MTK_PASSPOINT_R2_SUPPORT is not set
+CONFIG_MTK_WIFI_MCC_SUPPORT=y
+CONFIG_MTK_COMBO_PLAT_PATH=""
+# CONFIG_MTK_COMBO_COMM is not set
+CONFIG_MTK_COMBO_BT=y
+# CONFIG_MTK_COMBO_ANT is not set
+CONFIG_MTK_COMBO_GPS=y
+CONFIG_MTK_GPS_SUPPORT=y
+CONFIG_MTK_COMBO_WIFI=y
+CONFIG_MTK_BT_SUPPORT=y
+# CONFIG_MTK_WFD_SUPPORT is not set
+CONFIG_MTK_FM=y
+CONFIG_MTK_FM_SUPPORT=y
+CONFIG_MTK_FM_CHIP="MT6625_FM"
+# CONFIG_MTK_FM_50KHZ_SUPPORT is not set
+# CONFIG_MTK_MERGE_INTERFACE_SUPPORT is not set
+# CONFIG_SDIOAUTOK_SUPPORT is not set
+# CONFIG_MTK_MT6306_SUPPORT is not set
+# CONFIG_MTK_IDLE_TIME_FIX is not set
+CONFIG_MTK_G2D=y
+CONFIG_MTK_MPEG4_DEC_DRIVER=y
+CONFIG_MTK_MPEG4_ENC_DRIVER=y
+CONFIG_MTK_H264_DEC_DRIVER=y
+CONFIG_MTK_MFLEXVIDEO_DRIVER=y
+CONFIG_MTK_VIDEOCODEC_DRIVER=y
+# CONFIG_MTK_MJC_DRIVER is not set
+CONFIG_MTK_I2C=y
+CONFIG_MTK_SPI=y
+# CONFIG_MTK_CMMB is not set
+CONFIG_MTK_JPEG=y
+CONFIG_MTK_KEYPAD=y
+# CONFIG_KEYBOARD_HID is not set
+CONFIG_MTK_LEDS=y
+CONFIG_MTK_MMC=y
+# CONFIG_MTK_SDIOAUTOK_SUPPORT is not set
+
+#
+# MediaTek OFN / Jogball Related Drivers
+#
+# CONFIG_MOUSE_PANASONIC_EVQWJN is not set
+# CONFIG_MOUSE_AVAGOTECH_A320 is not set
+CONFIG_MTK_SMART_BATTERY=y
+CONFIG_MTK_PMIC=y
+CONFIG_MTK_PMIC_WRAP=y
+# CONFIG_MTK_PMIC_MT6397 is not set
+# CONFIG_POWER_EXT is not set
+# CONFIG_MTK_POWER_EXT_DETECT is not set
+# CONFIG_MTK_PUMP_EXPRESS_SUPPORT is not set
+# CONFIG_MTK_PUMP_EXPRESS_PLUS_SUPPORT is not set
+# CONFIG_MTK_VOW_SUPPORT is not set
+# CONFIG_MTK_EXTERNAL_LDO is not set
+# CONFIG_X2_BQ27531_SUPPORT is not set
+# CONFIG_MTK_BQ24250_SUPPORT is not set
+# CONFIG_MTK_BQ24261_SUPPORT is not set
+# CONFIG_MTK_BQ24196_SUPPORT is not set
+# CONFIG_MTK_FAN5405_SUPPORT is not set
+# CONFIG_MTK_FAN5402_SUPPORT is not set
+# CONFIG_MTK_BQ24158_SUPPORT is not set
+# CONFIG_MTK_BQ24296_SUPPORT is not set
+# CONFIG_MTK_BQ27541_SUPPORT is not set
+# CONFIG_MTK_NCP1851_SUPPORT is not set
+# CONFIG_MTK_NCP1854_SUPPORT is not set
+# CONFIG_MTK_RT9536_SUPPORT is not set
+# CONFIG_MTK_MAX8971_SUPPORT is not set
+# CONFIG_MTK_DUAL_INPUT_CHARGER_SUPPORT is not set
+# CONFIG_MTK_WIRELESS_CHARGER_SUPPORT is not set
+# CONFIG_MTK_JEITA_STANDARD_SUPPORT is not set
+CONFIG_MTK_RTC=y
+CONFIG_MTK_SERIAL=y
+CONFIG_MTK_SERIAL_CONSOLE=y
+# CONFIG_MTK_SERIAL_MODEM_TEST is not set
+# CONFIG_MTK_UART_USB_SWITCH is not set
+CONFIG_MTK_SIM2=y
+# CONFIG_MTK_SOUND is not set
+# CONFIG_MTK_AUDIO_EXTCODEC_SUPPORT is not set
+# CONFIG_MTK_CM36283 is not set
+# CONFIG_MTK_GP2AP002S00F is not set
+# CONFIG_MTK_APM_16D is not set
+# CONFIG_MTK_EPL2182 is not set //fc
+CONFIG_MTK_EPL2182_NEW=y
+#CONFIG_MTK_STK3X1X_NEW=n
+#CONFIG_MTK_STK3X1X_DRIVER=n
+# CONFIG_MTK_CM36652_NEW is not set
+# CONFIG_MTK_APDS9930 is not set
+# CONFIG_MTK_CM3232_NEW is not set
+# CONFIG_MTK_APDS9930_NEW is not set
+# CONFIG_MTK_KXTJ2_1009 is not set
+# CONFIG_MTK_KXTIK1004 is not set
+# CONFIG_MTK_K2DH is not set
+# CONFIG_MTK_BMA222E is not set
+# CONFIG_MTK_BMA222E_NEW is not set
+# CONFIG_MTK_MC3410_NEW is not set
+# CONFIG_MTK_KXTJ2_1009_AUTO is not set
+# CONFIG_MTK_MC3XXX is not set
+# CONFIG_MTK_MPU6050G_NEW is not set
+# CONFIG_MTK_BMA250 is not set
+# CONFIG_MTK_MPU6515A is not set
+# CONFIG_MTK_MPU60X0 is not set
+CONFIG_MTK_KXTJ2_1009_NEW=y
+#CONFIG_MTK_MC3XXX_AUTO=y
+# CONFIG_MTK_BMA250E is not set
+# CONFIG_MTK_MPU3050C is not set
+# CONFIG_MTK_MPU3000 is not set
+# CONFIG_MTK_MPU3000_NEW is not set
+# CONFIG_MTK_MPU6050GY_NEW is not set
+# CONFIG_MTK_ITG1010_NEW is not set
+# CONFIG_MTK_MPU6515G is not set
+# CONFIG_MTK_MPU3050C_NEW is not set
+# CONFIG_MTK_MPU6050C is not set
+# CONFIG_MTK_AKM8963 is not set
+# CONFIG_MTK_AKM8963_NEW is not set
+# CONFIG_MTK_AKM09911 is not set
+# CONFIG_MTK_AKM09911_NEW is not set
+# CONFIG_MTK_HSCDTD006 is not set
+# CONFIG_MTK_BMM050 is not set
+# CONFIG_MTK_BMM050_NEW is not set
+#CONFIG_MTK_MMC3416X=y
+# CONFIG_MTK_BMA050 is not set
+# CONFIG_MTK_BMA050_NEW is not set
+# CONFIG_MTK_BMA255_SDO0 is not set
+# CONFIG_MTK_BMA255_SDO1 is not set
+# CONFIG_MTK_S2200 is not set
+# CONFIG_MTK_YAS532 is not set
+# CONFIG_MTK_YAS532_NEW is not set
+# CONFIG_MTK_BMP180_NEW is not set
+CONFIG_MTK_TOUCHPANEL=y
+# CONFIG_MTK_S7020 is not set
+CONFIG_MTK_USB_GADGET=y
+# CONFIG_USB_MU3D_PIO_ONLY is not set
+# CONFIG_USB_MU3D_DRV is not set
+# CONFIG_USB_MU3D_DVT is not set
+# CONFIG_MU3_PHY is not set
+# CONFIG_MTK_XHCI is not set
+# CONFIG_MTK_OTG_PMIC_BOOST_5V is not set
+# CONFIG_MTK_OTG_OC_DETECTOR is not set
+# CONFIG_MTK_TEST_XHCI is not set
+# CONFIG_USBIF_COMPLIANCE is not set
+# CONFIG_MTK_S3320 is not set
+# CONFIG_MTK_S3320_47 is not set
+# CONFIG_MTK_S3320_50 is not set
+# CONFIG_LEDS_LM3632 is not set
+# CONFIG_LEDS_LM3639 is not set
+# CONFIG_LEDS_RT8542 is not set
+CONFIG_MTK_VIBRATOR=y
+CONFIG_MTK_WD_KICKER=y
+# CONFIG_MT592X_SDIO_CLNT is not set
+CONFIG_USB_MTK_ACM_TEMP=y
+CONFIG_USB_MTK_HDRC=y
+CONFIG_USB_MTK_HDRC_GADGET=y
+# CONFIG_USB_MTK_OTG is not set
+# CONFIG_USB_MTK_DUALMODE is not set
+CONFIG_USB_MTK_DEBUG_FS=y
+CONFIG_USB_MTK_DEBUG=y
+# CONFIG_USB_MTK_HDRC_HCD is not set
+# CONFIG_MTK_USB_UNIQUE_SERIAL is not set
+# CONFIG_MTK_USBFSH is not set
+# CONFIG_MUSBFSH_PIO_ONLY is not set
+# CONFIG_MTK_MUSB_QMU_SUPPORT is not set
+CONFIG_AMPC_CDEV_NUM=151
+CONFIG_ION_MTK=y
+CONFIG_ION_MTK_FB_HEAP_SUPPORT=y
+CONFIG_MMPROFILE=y
+# CONFIG_MTK_STAGING is not set
+# CONFIG_PWR_LOSS_MTK_TEST is not set
+CONFIG_MTK_EMMC_CACHE=y
+CONFIG_MTK_GPU_SUPPORT=y
+# CONFIG_MTK_ICUSB_SUPPORT is not set
+# CONFIG_MTK_DT_USB_SUPPORT is not set
+# CONFIG_MTK_SWCHR_SUPPORT is not set
+# CONFIG_MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION is not set
+CONFIG_MTK_KERNEL_POWER_OFF_CHARGING=y
+# CONFIG_MTK_BQ24160_SUPPORT is not set
+# CONFIG_MTK_MT8193_SUPPORT is not set
+# CONFIG_MTK_HDMI_SUPPORT is not set
+# CONFIG_MTK_MT8193_HDCP_SUPPORT is not set
+CONFIG_CUSTOM_KERNEL_HDMI=""
+# CONFIG_SINGLE_PANEL_OUTPUT is not set
+CONFIG_MTK_THERMAL_PA_VIA_ATCMD=y
+CONFIG_MTK_SIM1_SOCKET_TYPE="1"
+CONFIG_MTK_SIM2_SOCKET_TYPE="1"
+CONFIG_MTK_SEC_MODEM_NVRAM_ANTI_CLONE=y
+# CONFIG_MTK_MT6333_SUPPORT is not set
+# CONFIG_MTK_CTP_RESET_CONFIG is not set
+CONFIG_MTK_BICR_SUPPORT=y
+# CONFIG_MTK_VIDEO_HEVC_SUPPORT is not set
+# CONFIG_MTK_AAL_SUPPORT is not set
+# CONFIG_MTK_MULTIBRIDGE_SUPPORT is not set
+# CONFIG_NAND_OTP_SUPPORT is not set
+# CONFIG_MTK_OD_SUPPORT is not set
+# CONFIG_MTK_LENS_DUMMYLENS_SUPPORT is not set
+# CONFIG_MTK_LENS_AD5820AF_SUPPORT is not set
+# CONFIG_MTK_LENS_AD5823_SUPPORT is not set
+# CONFIG_MTK_LENS_AD5823AF_SUPPORT is not set
+# CONFIG_MTK_LENS_AK7345AF_SUPPORT is not set
+# CONFIG_MTK_LENS_BU6424AF_SUPPORT is not set
+# CONFIG_MTK_LENS_BU6429AF_SUPPORT is not set
+# CONFIG_MTK_LENS_BU64745GWZAF_SUPPORT is not set
+# CONFIG_MTK_LENS_DW9718AF_SUPPORT is not set
+#CONFIG_MTK_LENS_DW9714AF_SUPPORT=y
+# CONFIG_MTK_LENS_DW9714A_SUPPORT is not set
+# CONFIG_MTK_LENS_DW9814AF_SUPPORT is not set
+# CONFIG_MTK_LENS_LC898122AF_SUPPORT is not set
+# CONFIG_MTK_LENS_LC898212AF_SUPPORT is not set
+CONFIG_MTK_LENS_FM50AF_SUPPORT=y
+# CONFIG_MTK_LENS_MT9P017AF_SUPPORT is not set
+# CONFIG_MTK_LENS_OV8825AF_SUPPORT is not set
+# CONFIG_MTK_LENS_SENSORDRIVE_SUPPORT is not set
+# CONFIG_MTK_LENS_GAF001AF_SUPPORT is not set
+# CONFIG_MTK_LENS_GAF002AF_SUPPORT is not set
+# CONFIG_MTK_LENS_GAF008AF_SUPPORT is not set
+# CONFIG_MTK_EXTMEM is not set
+# CONFIG_MTK_INHOUSE_GPU is not set
+# CONFIG_SW_SYNC64 is not set
+CONFIG_MTK_CPU_STRESS=y
+CONFIG_MTK_LASTPC=y
+CONFIG_MTK_FMRADIO=y
+CONFIG_MTK_HWMON=y
+CONFIG_MTK_CMDQ=y
+CONFIG_MTK_VIDEOX=y
+CONFIG_MTK_MT_LOGGER=y
+CONFIG_MTK_CONN_MD=y
+CONFIG_MTK_LENS=y
+# CONFIG_MTK_IMGSENSOR is not set
+# CONFIG_MTK_CAM_CAL is not set
+# CONFIG_MTK_FLASHLIGHT is not set
+# CONFIG_MTK_DUM_CHAR is not set
+CONFIG_MTK_SYSENV=y
+CONFIG_MTK_SMI=y
+CONFIG_MTK_BTCVSD=y
+# CONFIG_MTK_SOUND_DRV is not set
+CONFIG_MTK_POWER_GS=y
+# CONFIG_MTK_VIDEO is not set
+# CONFIG_MTK_MRDUMP is not set
+# CONFIG_MTK_WMT_CCCI is not set
+CONFIG_MTK_VCOREFS=y
+CONFIG_MTK_EMI_MPU=y
+CONFIG_MTK_EMI_BWL=y
+# CONFIG_MTK_DBG_DUMP is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=y
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+CONFIG_SCSI_SCAN_ASYNC=y
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM_BUILTIN=y
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_CACHE is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+CONFIG_DM_UEVENT=y
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_MII is not set
+CONFIG_IFB=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+# CONFIG_ETHERNET is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_WIFI_CONTROL_FUNC is not set
+# CONFIG_ATH_CARDS is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_WL_TI is not set
+# CONFIG_MWIFIEX is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+# CONFIG_INPUT_KEYCOMBO is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_MTK=y
+# CONFIG_TOUCHSCREEN_MTK_GT9XX is not set
+# CONFIG_TOUCHSCREEN_MTK_FHD is not set
+# CONFIG_TOUCHSCREEN_MTK_HD is not set
+# CONFIG_TOUCHSCREEN_MTK_GT9XX_AIO is not set
+# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_SCP is not set
+# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT is not set
+# CONFIG_TOUCHSCREEN_MTK_GT1151 is not set
+# CONFIG_TOUCHSCREEN_GT1151 is not set
+CONFIG_MTK_GT915_HD=y
+# doubletap 2 wake!
+CONFIG_TOUCHSCREEN_SWEEP2WAKE=y
+CONFIG_TOUCHSCREEN_DOUBLETAP2WAKE=y
+CONFIG_TOUCHSCREEN_PREVENT_SLEEP=y
+CONFIG_TOUCHSCREEN_MTK_FT6206_X2605=y
+
+# CONFIG_MTK_GT915_QHD is not set
+# CONFIG_MTK_FOCALTECH_QHD is not set
+# CONFIG_MTK_FT6X06_QHD is not set
+# CONFIG_TOUCHSCREEN_MTK_GT910 is not set
+# CONFIG_TOUCHSCREEN_MTK_MAX1187X is not set
+# CONFIG_TOUCHSCREEN_MTK_GT9XX_HOTKNOT_FPGA is not set
+# CONFIG_TOUCHSCREEN_MTK_GT9XXTB_HOTKNOT is not set
+# CONFIG_TOUCHSCREEN_MTK_GT818B_FPGA is not set
+# CONFIG_TOUCHSCREEN_S7020 is not set
+# CONFIG_TOUCHSCREEN_MTK_GT9XX_2 is not set
+# CONFIG_MTK_GT9XX is not set
+# CONFIG_GT9XX_2 is not set
+# CONFIG_MTK_GT911 is not set
+# CONFIG_MTK_MMS244 is not set
+# CONFIG_GT9XX_HOTKNOT_FLASHLESS is not set
+# CONFIG_MTK_FT5406 is not set
+# CONFIG_MTK_FT5406_82 is not set
+# CONFIG_MTK_FT5206 is not set
+# CONFIG_MTK_FT5X0X is not set
+# CONFIG_MTK_MMS134 is not set
+# CONFIG_MTK_MMS128 is not set
+# CONFIG_MTK_MIT200 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_MTK_FTS2A052 is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_S3528 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYCHORD is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# Qualcomm MSM SSBI bus support
+#
+# CONFIG_SSBI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_TS5500 is not set
+# CONFIG_GPIO_GRGPIO is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+
+#
+# USB GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_DEFAULT_GOV_BACKWARD_COMPATIBLE=y
+# CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+CONFIG_BACKWARD_COMPATIBLE=y
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_GOV_STEP_WISE is not set
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_CPU_THERMAL is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_ADF is not set
+
+#
+# Console display driver support
+#
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_FB_SSD1307 is not set
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_SEQ_DUMMY=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_HRTIMER=y
+CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=n
+CONFIG_SND_VERBOSE_PRINTK=n
+CONFIG_SND_DEBUG=n
+CONFIG_SND_DEBUG_VERBOSE=n
+CONFIG_SND_PCM_XRUN_DEBUG=n
+CONFIG_SND_RAWMIDI_SEQ=y
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=y
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+# CONFIG_MT_SND_SOC_V1 is not set
+# CONFIG_MT_SND_SOC_V2 is not set
+CONFIG_MT_SND_SOC_V3=y
+# CONFIG_MT_SND_SOC_6580 is not set
+# CONFIG_MT_SND_SOC_8163 is not set
+# CONFIG_MTK_SPEAKER is not set
+# CONFIG_MTK_NXP_TFA9890 is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_SOUND_PRIME=y
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=y
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+CONFIG_HID_GYRATION=y
+# CONFIG_HID_ICADE is not set
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PS3REMOTE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+CONFIG_HID_SAMSUNG=y
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+# CONFIG_HID_TIVO is not set
+CONFIG_HID_TOPSEED=y
+# CONFIG_HID_THINGM is not set
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_CHIPIDEA is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+CONFIG_USB_TRANCEVIBRATOR=y
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+CONFIG_USB_PHY=y
+# CONFIG_USB_OTG_WAKELOCK is not set
+CONFIG_NOP_USB_XCEIV=y
+# CONFIG_OMAP_CONTROL_USB is not set
+# CONFIG_OMAP_USB3 is not set
+# CONFIG_SAMSUNG_USBPHY is not set
+# CONFIG_SAMSUNG_USB2PHY is not set
+# CONFIG_SAMSUNG_USB3PHY is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_RCAR_PHY is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=y
+CONFIG_USB_F_ACM=y
+CONFIG_USB_U_SERIAL=y
+CONFIG_USB_F_SERIAL=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_G_ANDROID=y
+# CONFIG_USB_ANDROID_RNDIS_DWORD_ALIGNED is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+# CONFIG_MMC_CLKGATE is not set
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_FFU is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_BLINKM is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+CONFIG_SWITCH=y
+# CONFIG_SWITCH_GPIO is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+# CONFIG_RTC_SYSTOHC is not set
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_USBIP_CORE is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8712U is not set
+# CONFIG_RTS5139 is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_LINE6_USB is not set
+CONFIG_ZSMALLOC=y
+CONFIG_ZRAM=y
+CONFIG_ZRAM_DEBUG=n
+# CONFIG_ZSM is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ASHMEM=y
+CONFIG_ANDROID_LOGGER=y
+CONFIG_ANDROID_TIMED_OUTPUT=y
+# CONFIG_ANDROID_TIMED_GPIO is not set
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER_AUTODETECT_OOM_ADJ_VALUES=y
+CONFIG_ANDROID_INTF_ALARM_DEV=y
+CONFIG_SYNC=y
+CONFIG_SW_SYNC=y
+CONFIG_SW_SYNC_USER=y
+# CONFIG_MTK_GMO_RAM_OPTIMIZE is not set
+CONFIG_ION=y
+# CONFIG_ION_TEST is not set
+# CONFIG_FIQ_DEBUGGER is not set
+# CONFIG_FIQ_WATCHDOG is not set
+# CONFIG_USB_WPAN_HCD is not set
+# CONFIG_WIMAX_GDM72XX is not set
+# CONFIG_CSR_WIFI is not set
+# CONFIG_CED1401 is not set
+# CONFIG_DGRP is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_COMMON_CLK_DEBUG is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_ARM_ARCH_TIMER=y
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_OF_IOMMU=y
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_MTK_GIC=y
+CONFIG_MTK_EIC=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+
+#
+# Android
+#
+CONFIG_ANDROID_BINDER_IPC=y
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_EXT4_DEBUG=n
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+CONFIG_NLS_CODEPAGE_950=y
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+# CONFIG_RAWFS_FS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1400
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=n
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=n
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_PANIC_ON_OOPS_VALUE=1
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=n
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=n
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_HAVE_DEBUG_BUGVERBOSE=n
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=n
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU_DELAY is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+CONFIG_FAULT_INJECTION=y
+# CONFIG_FAILSLAB is not set
+# CONFIG_FAIL_PAGE_ALLOC is not set
+# CONFIG_FAIL_MAKE_REQUEST is not set
+# CONFIG_FAIL_IO_TIMEOUT is not set
+# CONFIG_FAIL_MMC_REQUEST is not set
+# CONFIG_FAULT_INJECTION_DEBUG_FS is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+CONFIG_ENABLE_DEFAULT_TRACERS=y
+# CONFIG_FTRACE_SYSCALLS is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_PROBE_EVENTS is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+CONFIG_DYNAMIC_DEBUG=n
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_PID_IN_CONTEXTIDR is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+CONFIG_LSM_MMAP_MIN_ADDR=32768
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
+# CONFIG_SECURITY_SELINUX_DISABLE is not set
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_IMA is not set
+CONFIG_DEFAULT_SECURITY_SELINUX=y
+# CONFIG_DEFAULT_SECURITY_DAC is not set
+CONFIG_DEFAULT_SECURITY="selinux"
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_CRYPTD=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_ABLK_HELPER=y
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_ARM32_CE is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_LZ4K is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_ARM64_CRYPTO=y
+# CONFIG_CRYPTO_SHA1_ARM64_CE is not set
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+# CONFIG_CRYPTO_GHASH_ARM64_CE is not set
+CONFIG_CRYPTO_AES_ARM64_CE=y
+# CONFIG_CRYPTO_AES_ARM64_CE_CCM is not set
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+# CONFIG_CRYPTO_AES_ARM64_NEON_BLK is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+# CONFIG_LZ4K is not set
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
diff --git a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c
index 8530335..2bc8bd7 100755
--- a/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c
+++ b/drivers/misc/mediatek/imgsensor/src/mt6735m/gc2355_mipi_raw/gc2355mipi_Sensor.c
@@ -26,7 +26,7 @@
 #include <linux/uaccess.h>
 #include <linux/fs.h>
 #include <asm/atomic.h>
-#include <asm/system.h>
+//#include <asm/system.h>
 #include <linux/xlog.h>
 
 #include "kd_camera_hw.h"
diff --git a/drivers/misc/mediatek/lcm/hct_hx8394f_dsi_vdo_hd_cmi/Makefile b/drivers/misc/mediatek/lcm/hct_hx8394f_dsi_vdo_hd_cmi/Makefile
new file mode 100755
index 0000000..a5bb9b3
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_hx8394f_dsi_vdo_hd_cmi/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for misc devices that really don't fit anywhere else.
+#
+
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y += hct_hx8394f_dsi_vdo_hd_cmi.o
+
+
+
+
diff --git a/drivers/misc/mediatek/lcm/hct_hx8394f_dsi_vdo_hd_cmi/hct_hx8394f_dsi_vdo_hd_cmi.c b/drivers/misc/mediatek/lcm/hct_hx8394f_dsi_vdo_hd_cmi/hct_hx8394f_dsi_vdo_hd_cmi.c
new file mode 100755
index 0000000..fa911f6
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_hx8394f_dsi_vdo_hd_cmi/hct_hx8394f_dsi_vdo_hd_cmi.c
@@ -0,0 +1,576 @@
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+
+#include "lcm_drv.h"
+
+#if defined(BUILD_LK)
+#else
+
+#include <linux/proc_fs.h>   //proc file use 
+#endif
+
+
+// ---------------------------------------------------------------------------
+//  Local Constants
+// ---------------------------------------------------------------------------
+
+#define FRAME_WIDTH  										(720)
+#define FRAME_HEIGHT 										(1280)
+
+#define LCM_ID                      								(0x94)
+
+#define REGFLAG_DELAY             								(0XFE)
+#define REGFLAG_END_OF_TABLE      								(0x100)	// END OF REGISTERS MARKER
+
+#ifndef TRUE
+    #define TRUE 1
+#endif
+
+#ifndef FALSE
+    #define FALSE 0
+#endif
+
+// ---------------------------------------------------------------------------
+//  Local Variables
+// ---------------------------------------------------------------------------
+
+static LCM_UTIL_FUNCS lcm_util = {0};
+
+#define SET_RESET_PIN(v)    									(lcm_util.set_reset_pin((v)))
+
+#define UDELAY(n) 										(lcm_util.udelay(n))
+#define MDELAY(n) 										(lcm_util.mdelay(n))
+
+static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
+
+// ---------------------------------------------------------------------------
+//  Local Functions
+// ---------------------------------------------------------------------------
+#define dsi_set_cmdq_V3(para_tbl,size,force_update)        lcm_util.dsi_set_cmdq_V3(para_tbl,size,force_update)
+#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)	lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
+#define dsi_set_cmdq(pdata, queue_size, force_update)		lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
+#define wrtie_cmd(cmd)										lcm_util.dsi_write_cmd(cmd)
+#define write_regs(addr, pdata, byte_nums)					lcm_util.dsi_write_regs(addr, pdata, byte_nums)
+#define read_reg(cmd)											lcm_util.dsi_dcs_read_lcm_reg(cmd)
+#define read_reg_v2(cmd, buffer, buffer_size)				lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)
+
+ struct LCM_setting_table {
+    unsigned cmd;
+    unsigned char count;
+    unsigned char para_list[64];
+};
+
+static struct LCM_setting_table lcm_initialization_setting[] = {
+// Set EXTC
+{0xB9, 3, {0xFF,0x83,0x94}},
+
+// Set MIPI
+{0xBA, 6, {0x63,0x03,0x68,0x6B,0xB2,0xC0}},
+
+// Set Power
+{0xB1, 10, {0x50,0x12,0x72,0x09,0x33,0x54,0x71,0x31,0x70,0x2F}},
+
+// Set Display
+{0xB2, 6, {0x00,0x80,0x64,0x0E,0x0D,0x2F}},
+
+// Set CYC
+{0xB4, 21, {0x64,0x65,0x64,0x65,0x64,0x65,0x01,0x01,0x7E,0x75,
+0x00,0x3F,0x64,0x65,0x64,0x65,0x64,0x65,0x01,0x01,
+0x7E}},
+
+// Set VCOM
+{0xB6, 2, {0x75,0x75}},
+
+// Set D3
+{0xD3, 33, {0x00,0x00,0x07,0x07,0x40,0x07,0x10,0x00,0x08,0x10,
+0x08,0x00,0x08,0x54,0x15,0x0E,0x05,0x0E,0x02,0x15,
+0x06,0x05,0x06,0x47,0x44,0x0A,0x0A,0x4B,0x10,0x07,
+0x07,0x0E,0x40}},
+
+// Set GIP
+{0xD5, 44, {0x1A,0x1A,0x1B,0x1B,0x00,0x01,0x02,0x03,0x04,0x05,
+0x06,0x07,0x08,0x09,0x0A,0x0B,0x24,0x25,0x18,0x18,
+0x26,0x27,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x20,0x21,
+0x18,0x18,0x18,0x18}},
+
+// Set D6
+{0xD6, 44, {0x1A,0x1A,0x1B,0x1B,0x0B,0x0A,0x09,0x08,0x07,0x06,
+0x05,0x04,0x03,0x02,0x01,0x00,0x21,0x20,0x18,0x18,
+0x27,0x26,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
+0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x25,0x24,
+0x18,0x18,0x18,0x18}},
+
+// Set Gamma
+{0xE0, 58, {0x00,0x0C,0x19,0x20,0x23,0x26,0x29,0x28,0x51,0x61,
+0x70,0x6F,0x76,0x86,0x89,0x8D,0x99,0x9A,0x95,0xA1,
+0xB0,0x57,0x55,0x58,0x5C,0x5E,0x64,0x6B,0x7F,0x00,
+0x0C,0x18,0x20,0x23,0x26,0x29,0x28,0x51,0x61,0x70,
+0x6F,0x76,0x86,0x89,0x8D,0x99,0x9A,0x95,0xA1,0xB0,
+0x57,0x55,0x58,0x5C,0x5E,0x64,0x6B,0x7F}},
+
+// Set C0
+{0xC0, 2, {0x1F,0x73}},
+
+// Set Panel
+{0xCC, 1, {0x0B}},
+
+// Set D4 enhance
+{0xD4, 1, {0x02}},
+
+// Sleep Out
+{0x11,  0,  {0x00}},
+{REGFLAG_DELAY, 120, {0}},
+
+// Set Power Option   HX5186 Mode
+{0xBF, 7, {0x40,0x81,0x50,0x02,0x1A,0xFC,0x02}},
+
+// Display ON
+{0x29,  0,  {0x00}},
+{REGFLAG_DELAY, 20, {0}},
+};
+
+
+
+static struct LCM_setting_table lcm_sleep_out_setting[] = {
+    // Sleep Out
+	{0x11, 1, {0x00}},
+	{REGFLAG_DELAY, 150, {}},
+	// Display ON
+	//{0x2C, 1, {0x00}},
+	//{0x13, 1, {0x00}},
+	{0x29, 1, {0x00}},
+	{REGFLAG_DELAY, 200, {}},
+	{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+
+static struct LCM_setting_table lcm_deep_sleep_mode_in_setting[] = {
+	// Display off sequence
+	{0x28, 1, {0x00}},
+    {REGFLAG_DELAY, 150, {}},
+
+	// Sleep Mode On
+	{0x10, 1, {0x00}},
+	{REGFLAG_DELAY, 150, {}},
+
+	{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+static struct LCM_setting_table lcm_compare_id_setting[] = {
+	// Display off sequence
+	{0xf0, 5, {0x55, 0xaa, 0x52, 0x08, 0x01}},
+	{REGFLAG_DELAY, 10, {}},
+	{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+static struct LCM_setting_table lcm_backlight_level_setting[] = {
+	{0x51, 1, {0xFF}},
+	{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+
+static void push_table(struct LCM_setting_table *table, unsigned int count, unsigned char force_update)
+{
+	unsigned int i;
+
+    for(i = 0; i < count; i++) {
+		
+        unsigned cmd;
+        cmd = table[i].cmd;
+		
+        switch (cmd) {
+			
+            case REGFLAG_DELAY :
+                MDELAY(table[i].count);
+                break;
+				
+            case REGFLAG_END_OF_TABLE :
+                break;
+				
+            default:
+				dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update);
+       	}
+    }
+	
+}
+
+
+// ---------------------------------------------------------------------------
+//  LCM Driver Implementations
+// ---------------------------------------------------------------------------
+
+static void lcm_set_util_funcs(const LCM_UTIL_FUNCS *util)
+{
+    memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
+}
+
+static void lcm_get_params(LCM_PARAMS *params)
+{
+	memset(params, 0, sizeof(LCM_PARAMS));
+	params->type   = LCM_TYPE_DSI;
+	params->width  = FRAME_WIDTH;
+	params->height = FRAME_HEIGHT;
+
+	// enable tearing-free
+	params->dbi.te_mode 			= LCM_DBI_TE_MODE_DISABLED;
+	params->dbi.te_edge_polarity		= LCM_POLARITY_RISING;
+
+	params->dsi.mode   = SYNC_PULSE_VDO_MODE;	//SYNC_PULSE_VDO_MODE;
+
+	// DSI
+	/* Command mode setting */
+	params->dsi.LANE_NUM			= LCM_FOUR_LANE;
+	//The following defined the fomat for data coming from LCD engine. 
+	params->dsi.data_format.color_order 	= LCM_COLOR_ORDER_RGB;
+	params->dsi.data_format.trans_seq   	= LCM_DSI_TRANS_SEQ_MSB_FIRST; 
+	params->dsi.data_format.padding     	= LCM_DSI_PADDING_ON_LSB;
+	params->dsi.data_format.format      	= LCM_DSI_FORMAT_RGB888;
+	// Highly depends on LCD driver capability.
+	// Not support in MT6573
+	params->dsi.packet_size=256;
+	// Video mode setting		
+	params->dsi.intermediat_buffer_num 	= 2;
+	params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
+        params->dsi.word_count=720 * 3;
+	params->dsi.vertical_sync_active				= 4;//5
+	params->dsi.vertical_backporch					= 12;
+	params->dsi.vertical_frontporch					= 15;
+	params->dsi.vertical_active_line				= FRAME_HEIGHT; 
+	params->dsi.horizontal_sync_active				= 40;
+	params->dsi.horizontal_backporch				= 40;//66
+	params->dsi.horizontal_frontporch				= 40;//70
+	//params->dsi.horizontal_blanking_pixel		       		= 60;
+	params->dsi.horizontal_active_pixel		       		= FRAME_WIDTH;
+	// Bit rate calculation
+
+	params->dsi.PLL_CLOCK=205;//227;//254;//254//247  240
+}
+
+static void lcm_init_resgister(void)
+{
+     unsigned int data_array[16];
+  
+    data_array[0] = 0x00043902;
+    data_array[1] = 0x9483ffb9;
+    dsi_set_cmdq(data_array, 2, 1);
+    MDELAY(5);
+    data_array[0] = 0x00073902;
+    data_array[1] = 0x680363ba;
+    data_array[2] = 0x00c0b26b;
+    dsi_set_cmdq(data_array, 3, 1);
+    MDELAY(5);
+    data_array[0] = 0x000B3902;
+    data_array[1] = 0x721250b1;
+    data_array[2] = 0x71543309;
+    data_array[3] = 0x002f7031;
+    dsi_set_cmdq(data_array, 4, 1);
+    MDELAY(5);
+    data_array[0] = 0x00073902;
+    data_array[1] = 0x648000b2;
+    data_array[2] = 0x002F0D0E;
+    dsi_set_cmdq(data_array, 3, 1);
+    MDELAY(5);
+    data_array[0] = 0x00163902;
+    data_array[1] = 0x646564b4;
+    data_array[2] = 0x01656465;
+    data_array[3] = 0x00757E01;
+    data_array[4] = 0x6465643F;
+       data_array[5] = 0x01656465;
+           data_array[6] = 0x00007E01;
+    dsi_set_cmdq(data_array, 7, 1);
+    MDELAY(5);
+   
+        data_array[0] = 0x00033902;
+    data_array[1] = 0x007575b6;
+    dsi_set_cmdq(data_array, 2, 1);
+    MDELAY(5);
+    
+    data_array[0] = 0x00223902;
+    data_array[1] = 0x070000d3;
+    data_array[2] = 0x10074007;
+    data_array[3] = 0x08100800;
+    data_array[4] = 0x15540800;
+    data_array[5] = 0x020E050E;
+    data_array[6] = 0x06050615;
+    data_array[7] = 0x0A0A4447;
+    data_array[8] = 0x0707104B;
+    data_array[9] = 0x0000400E;
+    dsi_set_cmdq(data_array, 10, 1);
+    MDELAY(5);
+   
+    data_array[0] = 0x002d3902;
+    data_array[1] = 0x1B1A1Ad5;
+    data_array[2] = 0x0201001B;
+    data_array[3] = 0x06050403;
+    data_array[4] = 0x0A090807;
+    data_array[5] = 0x1825240B;
+    data_array[6] = 0x18272618;
+    data_array[7] = 0x18181818;
+    data_array[8] = 0x18181818;
+    data_array[9] = 0x18181818;
+    data_array[10] = 0x20181818;
+    data_array[11] = 0x18181821;
+    data_array[12] = 0x00000018;
+    dsi_set_cmdq(data_array, 13, 1);
+    MDELAY(5);
+   data_array[0] = 0x002d3902;
+    data_array[1] = 0x1B1A1Ad6;
+    data_array[2] = 0x090A0B1B;
+    data_array[3] = 0x05060708;
+    data_array[4] = 0x01020304;
+    data_array[5] = 0x18202100;
+    data_array[6] = 0x18262718;
+    data_array[7] = 0x18181818;
+    data_array[8] = 0x18181818;
+    data_array[9] = 0x18181818;
+    data_array[10] = 0x25181818;
+    data_array[11] = 0x18181824;
+    data_array[12] = 0x00000018;
+    dsi_set_cmdq(data_array, 13, 1);
+    MDELAY(5);
+
+    data_array[0] = 0x003B3902;
+    data_array[1] = 0x190C00e0;
+    data_array[2] = 0x29262320;
+    data_array[3] = 0x70615128;
+    data_array[4] = 0x8986766F;
+    data_array[5] = 0x959A998D;
+    data_array[6] = 0x5557B0A1;
+    data_array[7] = 0x645E5C58;
+    data_array[8] = 0x0C007F6B;
+    data_array[9] = 0x26232018;
+    data_array[10] = 0x61512829;
+    data_array[11] = 0x86766F70;
+    data_array[12] = 0x9A998D89;
+    data_array[13] = 0x57B0A195;
+    data_array[14] = 0x5E5C5855;
+    data_array[15] = 0x007F6B64;
+    dsi_set_cmdq(data_array, 16, 1);
+    MDELAY(5);
+   
+    
+      
+    data_array[0] = 0x00033902;
+    data_array[1] = 0x00731Fc0;
+    dsi_set_cmdq(data_array, 2, 1);
+    MDELAY(5);    
+      
+    data_array[0] = 0x00023902;
+    data_array[1] = 0x00000Bcc;
+    dsi_set_cmdq(data_array, 2, 1);
+    MDELAY(5);
+    data_array[0] = 0x00023902;
+    data_array[1] = 0x000002D4;
+    dsi_set_cmdq(data_array, 2, 1);
+    MDELAY(5);
+
+    data_array[0] = 0x00110500;
+    dsi_set_cmdq(data_array, 1, 1);
+    MDELAY(120);
+   
+    data_array[0] = 0x00083902;
+    data_array[1] = 0x508140BF;
+    data_array[2] = 0x02FC1A02;
+    dsi_set_cmdq(data_array, 3, 1);
+    MDELAY(5);
+   
+    
+    data_array[0] = 0x00290500;
+    dsi_set_cmdq(data_array, 1, 1);
+    MDELAY(20);
+    ///////////////////////////
+};
+
+
+static void lcm_init(void)
+{
+    SET_RESET_PIN(1);
+    MDELAY(10);
+    SET_RESET_PIN(0);
+    MDELAY(20);
+    SET_RESET_PIN(1);
+    MDELAY(120);
+
+    lcm_init_resgister();
+   // dsi_set_cmdq_V3(lcm_initialization_setting_V3, sizeof(lcm_initialization_setting_V3) / sizeof(LCM_setting_table_V3), 1);
+  //	dsi_set_cmdq_V3(lcm_initialization_setting,sizeof(lcm_initialization_setting)/sizeof(lcm_initialization_setting[0]),1);
+    //push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
+}
+
+static void lcm_suspend(void)
+{
+#ifndef BUILD_LK
+	SET_RESET_PIN(1);  //NOTE:should reset LCM firstly
+	MDELAY(10);
+	SET_RESET_PIN(0);
+	MDELAY(30);
+	SET_RESET_PIN(1);
+	MDELAY(120);
+//	push_table(lcm_deep_sleep_mode_in_setting, sizeof(lcm_deep_sleep_mode_in_setting) / sizeof(struct LCM_setting_table), 1);	//wqtao. enable
+#endif
+}
+
+static unsigned int lcm_compare_id(void);
+
+static void lcm_resume(void)
+{
+#ifndef BUILD_LK
+//        lcm_compare_id();
+	lcm_init();
+#endif
+}
+
+
+
+static unsigned int lcm_esd_check(void)
+{
+#ifndef BUILD_LK
+	int array[4];
+	unsigned char buffer[2];
+
+	if(lcm_esd_test)
+	{
+	    lcm_esd_test = FALSE;
+	    return TRUE;
+	}
+
+	/// please notice: the max return packet size is 1
+	/// if you want to change it, you can refer to the following marked code
+	/// but read_reg currently only support read no more than 4 bytes....
+	/// if you need to read more, please let BinHan knows.
+	/*
+	        unsigned int data_array[16];
+	        unsigned int max_return_size = 1;
+	        
+	        data_array[0]= 0x00003700 | (max_return_size << 16);    
+	        
+	        dsi_set_cmdq(&data_array, 1, 1);
+	*/
+
+	array[0]=0x00043902;
+	array[1]=0x9483FFB9;// page enable
+	dsi_set_cmdq(array, 2, 1);
+//		MDELAY(20);
+
+	array[0]=0x00083902; 
+	array[1]=0x009341BA;// page enable 
+	array[2]=0x1800A416; 
+	dsi_set_cmdq(array, 3, 1); 
+//		MDELAY(10); 
+
+	array[0] = 0x00023700;// return byte number
+	dsi_set_cmdq(array, 1, 1);
+//		MDELAY(10);
+	read_reg_v2(0x0a, buffer, 1);
+
+	#ifndef BUILD_LK
+	printk("[%s] hct_hx8394f_dsi_vdo_hd_* lcm esd check. arthur %x\n", __FUNCTION__, buffer[0]);
+	#endif
+
+	if(buffer[0] == 0x1c)
+	{
+	    return FALSE;
+	}
+	else
+	{            
+	    return TRUE;
+	}
+#endif
+}
+
+static unsigned int lcm_esd_recover(void)
+{
+	lcm_init();
+	return TRUE;
+}
+	
+static unsigned int lcm_compare_id(void)
+{
+	unsigned int id=0;
+	unsigned char buffer[2];
+	unsigned int array[16];  
+
+	SET_RESET_PIN(1);
+	MDELAY(1);
+	SET_RESET_PIN(0);
+	MDELAY(1);
+	SET_RESET_PIN(1);
+	MDELAY(120);//Must over 6 ms
+
+	array[0]=0x00043902;
+	array[1]=0x9483FFB9;// page enable
+	dsi_set_cmdq(array, 2, 1);
+	MDELAY(10);
+
+	array[0]=0x00033902; 
+	array[1]=0x008373BA;// page enable //9341
+	//array[2]=0x1800A416; 
+	dsi_set_cmdq(array, 2, 1); 
+	MDELAY(10); 
+
+	array[0] = 0x00023700;// return byte number
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(10);
+
+	read_reg_v2(0xF4, buffer, 2);
+	id = buffer[0]; 
+
+#ifdef BUILD_LK
+	printf("[HX8394D]%s,  id = 0x%x\n", __func__, id);
+#else
+	printk("[HX8394D]%s,  id = 0x%x\n", __func__, id);
+#endif
+
+    return (LCM_ID == id)?1:0;
+}
+
+// ---------------------------------------------------------------------------
+//  Get LCM Driver Hooks
+// ---------------------------------------------------------------------------
+LCM_DRIVER hct_hx8394f_dsi_vdo_hd_cmi = 
+{
+	.name			  = "hct_hx8394f_dsi_vdo_hd_cmi",
+	.set_util_funcs = lcm_set_util_funcs,
+	.get_params     = lcm_get_params,
+	.init           = lcm_init,
+	.suspend        = lcm_suspend,
+	.resume         = lcm_resume,	
+	.compare_id     = lcm_compare_id,	
+//	.esd_check   = lcm_esd_check,	
+//	.esd_recover   = lcm_esd_recover,	
+//	.update         = lcm_update,
+};
+
diff --git a/drivers/misc/mediatek/lcm/hct_ili9881_dsi_vdo_hd_cpt/Makefile b/drivers/misc/mediatek/lcm/hct_ili9881_dsi_vdo_hd_cpt/Makefile
new file mode 100755
index 0000000..3c0e119
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_ili9881_dsi_vdo_hd_cpt/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for misc devices that really don't fit anywhere else.
+#
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y +=hct_ili9881_dsi_vdo_hd_cpt.o
+
+
+
+
diff --git a/drivers/misc/mediatek/lcm/hct_ili9881_dsi_vdo_hd_cpt/hct_ili9881_dsi_vdo_hd_cpt.c b/drivers/misc/mediatek/lcm/hct_ili9881_dsi_vdo_hd_cpt/hct_ili9881_dsi_vdo_hd_cpt.c
new file mode 100755
index 0000000..7d9e696
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_ili9881_dsi_vdo_hd_cpt/hct_ili9881_dsi_vdo_hd_cpt.c
@@ -0,0 +1,689 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+#ifndef BUILD_LK
+#include <linux/string.h>
+#endif
+
+#include "lcm_drv.h"
+
+#ifdef BUILD_LK
+	#include <platform/mt_gpio.h>
+	#include <string.h>
+#elif defined(BUILD_UBOOT)
+	#include <asm/arch/mt_gpio.h>
+#else
+//	#include <mach/mt_gpio.h>
+#endif
+// ---------------------------------------------------------------------------
+//  Local Constants
+// ---------------------------------------------------------------------------
+
+#define FRAME_WIDTH                                         (720)
+#define FRAME_HEIGHT                                        (1280)
+#define LCM_ID                       (0x1283)
+
+#define REGFLAG_DELAY               (0XFE)
+#define REGFLAG_END_OF_TABLE        (0x100) // END OF REGISTERS MARKER
+
+
+#define LCM_DSI_CMD_MODE                                    0
+
+#ifndef TRUE
+    #define TRUE 1
+#endif
+
+#ifndef FALSE
+    #define FALSE 0
+#endif
+
+// ---------------------------------------------------------------------------
+//  Local Variables
+// ---------------------------------------------------------------------------
+
+static LCM_UTIL_FUNCS lcm_util = {0};
+
+#define SET_RESET_PIN(v)                                    (lcm_util.set_reset_pin((v)))
+
+#define UDELAY(n)                                           (lcm_util.udelay(n))
+#define MDELAY(n)                                           (lcm_util.mdelay(n))
+
+static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
+
+// ---------------------------------------------------------------------------
+//  Local Functions
+// ---------------------------------------------------------------------------
+
+#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)    lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
+#define dsi_set_cmdq(pdata, queue_size, force_update)       lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
+#define wrtie_cmd(cmd)                                      lcm_util.dsi_write_cmd(cmd)
+#define write_regs(addr, pdata, byte_nums)                  lcm_util.dsi_write_regs(addr, pdata, byte_nums)
+#define read_reg(cmd)                                           lcm_util.dsi_dcs_read_lcm_reg(cmd)
+#define read_reg_v2(cmd, buffer, buffer_size)               lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)
+
+ struct LCM_setting_table {
+    unsigned cmd;
+    unsigned char count;
+    unsigned char para_list[64];
+};
+
+
+static struct LCM_setting_table lcm_initialization_setting[] = {
+    
+    /*
+    Note :
+
+    Data ID will depends on the following rule.
+    
+        count of parameters > 1 => Data ID = 0x39
+        count of parameters = 1 => Data ID = 0x15
+        count of parameters = 0 => Data ID = 0x05
+
+    Structure Format :
+
+    {DCS command, count of parameters, {parameter list}}
+    {REGFLAG_DELAY, milliseconds of time, {}},
+
+    ...
+
+    Setting ending by predefined flag
+    
+    {REGFLAG_END_OF_TABLE, 0x00, {}}
+    */
+{0xFF,3,{0x98,0x81,0x07}},   //CMD_Page 7
+{0x03,1,{0x20 }},  //GIP_1
+{0x04,1,{0x06 }},
+{0x05,1,{0x00 }},
+{0x06,1,{0x1  }},
+{0x07,1,{0x00 }},
+{0x08,1,{0x00 }},
+{0x09,1,{0x00 }},
+{0x0A,1,{0x1  }},
+{0x0B,1,{0x2F }},
+{0x0C,1,{0x00 }},
+{0x0D,1,{0x00 }},
+{0x0E,1,{0x00 }},
+{0x0F,1,{0x00 }},
+{0x10,1,{0x44 }},
+{0x11,1,{0x02 }},
+{0x12,1,{0x03 }},
+{0x13,1,{0x00 }},
+{0x14,1,{0x00 }},
+{0x15,1,{0x00 }},
+{0x16,1,{0x2F }},
+{0x17,1,{0x2F }},
+{0x18,1,{0x00 }},
+{0x19,1,{0x00 }},
+{0x1A,1,{0x00 }},
+{0x1B,1,{0x50 }},
+{0x1C,1,{0xBB }},
+{0x1D,1,{0x0C }},
+{0x1E,1,{0x00 }},
+{0x1F,1,{0x00 }},
+{0x20,1,{0x00 }},
+{0x21,1,{0x00 }},
+{0x22,1,{0x00 }},
+{0x23,1,{0x00 }},
+{0x24,1,{0x30 }},
+{0x25,1,{0x00 }},
+{0x26,1,{0x00 }},
+{0x27,1,{0x03 }},
+{0x30,1,{0x1  }},//GIP_2
+{0x31,1,{0x23 }},
+{0x32,1,{0x45 }},
+{0x33,1,{0x67 }},
+{0x34,1,{0x89 }},
+{0x35,1,{0xAB }},
+{0x36,1,{0x1  }},
+{0x37,1,{0x23 }},
+{0x38,1,{0x45 }},
+{0x39,1,{0x67 }},
+{0x3A,1,{0x89 }},
+{0x3B,1,{0xAB }},
+{0x3C,1,{0xCD }},
+{0x3D,1,{0xEF }},
+
+{0x50,1,{0x11 }},  //GIP_3
+{0x51,1,{0x06 }},
+{0x52,1,{0x0C }},
+{0x53,1,{0x0D }},
+{0x54,1,{0x0E }},
+{0x55,1,{0x0F }},
+{0x56,1,{0x02 }},
+{0x57,1,{0x02 }},
+{0x58,1,{0x02 }},
+{0x59,1,{0x02 }},
+{0x5A,1,{0x02 }},
+{0x5B,1,{0x02 }},
+{0x5C,1,{0x02 }},
+{0x5D,1,{0x02 }},
+{0x5E,1,{0x02 }},
+{0x5F,1,{0x02 }},
+{0x60,1,{0x05 }},
+{0x61,1,{0x05 }},
+{0x62,1,{0x05 }},
+{0x63,1,{0x02 }},
+{0x64,1,{0x1  }},
+{0x65,1,{0x00 }},
+{0x66,1,{0x08 }},
+{0x67,1,{0x08 }},
+{0x68,1,{0x0C }},
+{0x69,1,{0x0D }},
+{0x6A,1,{0x0E }},
+{0x6B,1,{0x0F }},
+{0x6C,1,{0x02 }},
+{0x6D,1,{0x02 }},
+{0x6E,1,{0x02 }},
+{0x6F,1,{0x02 }},
+{0x70,1,{0x02 }},
+{0x71,1,{0x02 }},
+{0x72,1,{0x02 }},
+{0x73,1,{0x02 }},
+{0x74,1,{0x02 }},
+{0x75,1,{0x02 }},
+{0x76,1,{0x05 }},
+{0x77,1,{0x05 }},
+{0x78,1,{0x05 }},
+{0x79,1,{0x02 }},
+{0x7A,1,{0x1  }},
+{0x7B,1,{0x00 }},
+{0x7C,1,{0x06 }},
+
+{0xFF,3,{0x98,0x81,0x08}},  //CMD_Page 8
+{0x76,1,{0xB4 }},       //VGH pumping ratio 3x
+{0x78,1,{0x02 }},
+{0x74,1,{0x2B }},
+{0x8E,1,{0x15 }},
+{0x40,1,{0x1  }},
+{0x84,1,{0x81 }},
+{0x72,1,{0x25 }},
+{0xE3,1,{0x45 }},
+{0x7D,1,{0xCB }},
+{0x7E,1,{0x49 }},
+{0x49,1,{0x10 }},
+{0x2F,1,{0x1  }},
+
+{0xFF,3,{0x98,0x81,0x1}},   //CMD_Page 1
+{0x22,1,{0x0A }},
+{0x53,1,{0x6F }},
+{0x55,1,{0x75 }},
+{0x50,1,{0xB9 }},
+{0x51,1,{0xBA }},
+{0x31,1,{0x00 }},
+
+{0xA0,1,{0x08 }},  //VP255 Gamma P
+{0xA1,1,{0x14 }},  //VP251   
+{0xA2,1,{0x1d }},  //VP247  
+{0xA3,1,{0x0f }},
+{0xA4,1,{0x0d }},     
+{0xA5,1,{0x1f }},
+{0xA6,1,{0x14 }},
+{0xA7,1,{0x18 }},
+{0xA8,1,{0x7d }},
+{0xA9,1,{0x1d }},
+{0xAA,1,{0x2a }},
+{0xAB,1,{0x83 }},
+{0xAC,1,{0x1d }},
+{0xAD,1,{0x1d }},
+{0xAE,1,{0x50 }},
+{0xAF,1,{0x22 }},
+{0xB0,1,{0x23 }},
+{0xB1,1,{0x28 }},
+{0xB2,1,{0x53 }},
+{0xB3,1,{0x63 }},
+{0xB7,1,{0x39 }},
+
+{0xC0,1,{0x08 }},  //VN255 GAMMA N
+{0xC1,1,{0x13 }},  //VN251
+{0xC2,1,{0x1d }},   //VN247
+{0xC3,1,{0x0e }},
+{0xC4,1,{0x0e }},
+{0xC5,1,{0x1f }},
+{0xC6,1,{0x13 }},
+{0xC7,1,{0x18 }},
+{0xC8,1,{0x7e }},
+{0xC9,1,{0x1e }},
+{0xCA,1,{0x2b }},
+{0xCB,1,{0x83 }},
+{0xCC,1,{0x1e }},
+{0xCD,1,{0x1c }},
+{0xCE,1,{0x50 }},
+{0xCF,1,{0x23 }},
+{0xD0,1,{0x29 }},
+{0xD1,1,{0x53 }},
+{0xD2,1,{0x63 }},
+{0xD3,1,{0x39 }},
+
+{0xFF,3,{0x98,0x81,0x00 }},
+
+{0x35,1,{0x00}}, //TE ON
+//{0x35}1{,         
+    {0x11,1,{0x00}},  
+    {REGFLAG_DELAY,120,{}},
+
+    {0x29,1,{0x00}},//Display ON 
+    {REGFLAG_DELAY,20,{}},  
+
+// Setting ending by predefined flag
+    {REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+static struct LCM_setting_table lcm_sleep_out_setting[] = {
+    // Sleep Out
+    {0x11, 1, {0x00}},
+    {REGFLAG_DELAY, 120, {}},
+    // Display ON
+    //{0x2C, 1, {0x00}},
+    //{0x13, 1, {0x00}},
+    {0x29, 1, {0x00}},
+    {REGFLAG_DELAY, 20, {}},
+    {REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+
+static struct LCM_setting_table lcm_deep_sleep_mode_in_setting[] = {
+    // Display off sequence
+    {0x28, 1, {0x00}},
+    {REGFLAG_DELAY, 20, {}},
+
+    // Sleep Mode On
+    {0x10, 1, {0x00}},
+    {REGFLAG_DELAY, 120, {}},
+
+    {REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+static struct LCM_setting_table lcm_compare_id_setting[] = {
+    // Display off sequence
+    {0xf0, 5, {0x55, 0xaa, 0x52, 0x08, 0x01}},
+    {REGFLAG_DELAY, 10, {}},
+    {REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+static struct LCM_setting_table lcm_backlight_level_setting[] = {
+    {0x51, 1, {0xFF}},
+    {REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+//static int vcom=0x40;
+static void push_table(struct LCM_setting_table *table, unsigned int count, unsigned char force_update)
+{
+    unsigned int i;
+
+    for(i = 0; i < count; i++) {
+        
+        unsigned cmd;
+        cmd = table[i].cmd;
+        
+        switch (cmd) {
+			/*case 0xd9:
+			table[i].para_list[0]=vcom;
+			dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update);
+            vcom+=2;
+			break;
+			*/
+            case REGFLAG_DELAY :
+                MDELAY(table[i].count);
+                break;
+                
+            case REGFLAG_END_OF_TABLE :
+                break;
+                
+            default:
+                dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update);
+        }
+    }
+    
+}
+
+
+// ---------------------------------------------------------------------------
+//  LCM Driver Implementations
+// ---------------------------------------------------------------------------
+
+static void lcm_set_util_funcs(const LCM_UTIL_FUNCS *util)
+{
+    memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
+}
+
+
+static void lcm_get_params(LCM_PARAMS *params)
+{
+    memset(params, 0, sizeof(LCM_PARAMS));
+    params->type   = LCM_TYPE_DSI;
+    params->width  = FRAME_WIDTH;
+    params->height = FRAME_HEIGHT;
+
+    // enable tearing-free
+    params->dbi.te_mode             = LCM_DBI_TE_MODE_DISABLED;
+    params->dbi.te_edge_polarity        = LCM_POLARITY_RISING;
+
+
+
+    params->dsi.mode   = SYNC_EVENT_VDO_MODE;
+
+
+    // DSI
+    /* Command mode setting */
+    params->dsi.LANE_NUM                = LCM_FOUR_LANE;
+    //The following defined the fomat for data coming from LCD engine. 
+    params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
+    params->dsi.data_format.trans_seq   = LCM_DSI_TRANS_SEQ_MSB_FIRST; 
+    params->dsi.data_format.padding     = LCM_DSI_PADDING_ON_LSB;
+    params->dsi.data_format.format      = LCM_DSI_FORMAT_RGB888;
+    // Highly depends on LCD driver capability.
+    // Not support in MT6573
+    params->dsi.packet_size=256;
+    // Video mode setting       
+    params->dsi.intermediat_buffer_num = 2;
+    params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
+    params->dsi.vertical_sync_active                = 4;
+    params->dsi.vertical_backporch                  = 16;
+    params->dsi.vertical_frontporch                 = 15;
+    params->dsi.vertical_active_line                = FRAME_HEIGHT; 
+    params->dsi.horizontal_sync_active              = 10;
+    params->dsi.horizontal_backporch                = 64;
+    params->dsi.horizontal_frontporch               = 64;
+    params->dsi.horizontal_blanking_pixel              = 60;
+    params->dsi.horizontal_active_pixel            = FRAME_WIDTH;
+    // Bit rate calculation
+#if 0
+    params->dsi.pll_div1=1;     // div1=0,1,2,3;div1_real=1,2,4,4
+    params->dsi.pll_div2=1;     // div2=0,1,2,3;div2_real=1,2,4,4
+    params->dsi.fbk_sel=1;       // fbk_sel=0,1,2,3;fbk_sel_real=1,2,4,4
+    params->dsi.fbk_div =30;        // fref=26MHz, fvco=fref*(fbk_div+1)*2/(div1_real*div2_real)    
+#else
+    params->dsi.PLL_CLOCK=230;//227;//254;//254//247
+#endif
+}
+
+static void lcm_init(void)
+{
+    SET_RESET_PIN(1);
+    MDELAY(10);
+    SET_RESET_PIN(0);
+    MDELAY(20);
+    SET_RESET_PIN(1);
+    MDELAY(120);
+
+    push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
+#ifdef BUILD_LK
+    //printf("[erick-lk]%s\n", __func__);
+#else
+    //printk("[erick-k]%s\n", __func__);
+#endif
+}
+
+
+static void lcm_suspend(void)
+{
+#ifndef BUILD_LK
+    push_table(lcm_deep_sleep_mode_in_setting, sizeof(lcm_deep_sleep_mode_in_setting) / sizeof(struct LCM_setting_table), 1);   //wqtao. enable
+    #ifdef BUILD_LK
+        //printf("[erick-lk]%s\n", __func__);
+    #else
+        //printk("[erick-k]%s\n", __func__);
+    #endif
+#endif
+}
+
+
+static void lcm_resume(void)
+{
+#ifndef BUILD_LK
+    push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
+    #ifdef BUILD_LK
+        //printf("[erick-lk]%s\n", __func__);
+    #else
+        //printk("[erick-k]%s\n", __func__);
+    #endif
+#endif
+}
+
+#if (LCM_DSI_CMD_MODE)
+static void lcm_update(unsigned int x, unsigned int y,
+                       unsigned int width, unsigned int height)
+{
+    unsigned int x0 = x;
+    unsigned int y0 = y;
+    unsigned int x1 = x0 + width - 1;
+    unsigned int y1 = y0 + height - 1;
+
+    unsigned char x0_MSB = ((x0>>8)&0xFF);
+    unsigned char x0_LSB = (x0&0xFF);
+    unsigned char x1_MSB = ((x1>>8)&0xFF);
+    unsigned char x1_LSB = (x1&0xFF);
+    unsigned char y0_MSB = ((y0>>8)&0xFF);
+    unsigned char y0_LSB = (y0&0xFF);
+    unsigned char y1_MSB = ((y1>>8)&0xFF);
+    unsigned char y1_LSB = (y1&0xFF);
+
+    unsigned int data_array[16];
+
+
+    data_array[0]= 0x00053902;
+    data_array[1]= (x1_MSB<<24)|(x0_LSB<<16)|(x0_MSB<<8)|0x2a;
+    data_array[2]= (x1_LSB);
+    dsi_set_cmdq(data_array, 3, 1);
+
+    data_array[0]= 0x00053902;
+    data_array[1]= (y1_MSB<<24)|(y0_LSB<<16)|(y0_MSB<<8)|0x2b;
+    data_array[2]= (y1_LSB);
+    dsi_set_cmdq(data_array, 3, 1);
+
+    data_array[0]= 0x00290508; //HW bug, so need send one HS packet
+    dsi_set_cmdq(data_array, 1, 1);
+
+    data_array[0]= 0x002c3909;
+    dsi_set_cmdq(data_array, 1, 0);
+}
+#endif
+
+#if 0   //wqtao.        
+static void lcm_setbacklight(unsigned int level)
+{
+    unsigned int default_level = 145;
+    unsigned int mapped_level = 0;
+
+    //for LGE backlight IC mapping table
+    if(level > 255) 
+            level = 255;
+
+    if(level >0) 
+            mapped_level = default_level+(level)*(255-default_level)/(255);
+    else
+            mapped_level=0;
+
+    // Refresh value of backlight level.
+    lcm_backlight_level_setting[0].para_list[0] = mapped_level;
+
+    push_table(lcm_backlight_level_setting, sizeof(lcm_backlight_level_setting) / sizeof(struct LCM_setting_table), 1);
+}
+#endif
+
+static unsigned int lcm_esd_check(void)
+{
+#ifndef BUILD_LK
+    if(lcm_esd_test)
+    {
+        lcm_esd_test = FALSE;
+        return TRUE;
+    }
+
+    /// please notice: the max return packet size is 1
+    /// if you want to change it, you can refer to the following marked code
+    /// but read_reg currently only support read no more than 4 bytes....
+    /// if you need to read more, please let BinHan knows.
+    /*
+            unsigned int data_array[16];
+            unsigned int max_return_size = 1;
+            
+            data_array[0]= 0x00003700 | (max_return_size << 16);    
+            
+            dsi_set_cmdq(&data_array, 1, 1);
+    */
+
+    if(read_reg(0x0a) == 0x9c)
+    {
+        return FALSE;
+    }
+    else
+    {            
+        return TRUE;
+    }
+#endif
+}
+
+static unsigned int lcm_esd_recover(void)
+{
+    unsigned char para = 0;
+
+    SET_RESET_PIN(1);
+    SET_RESET_PIN(0);
+    MDELAY(1);
+    SET_RESET_PIN(1);
+    MDELAY(120);
+      push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
+    MDELAY(10);
+      push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
+    MDELAY(10);
+    dsi_set_cmdq_V2(0x35, 1, &para, 1);     ///enable TE
+    MDELAY(10);
+
+    return TRUE;
+}
+
+
+static unsigned int lcm_compare_id(void)
+{
+        int array[4];
+        char buffer[5];
+        char id_high=0;
+        char id_midd=0;
+        char id_low=0;
+        int id=0;
+        //Do reset here
+        SET_RESET_PIN(1);
+        SET_RESET_PIN(0);
+        MDELAY(25);       
+        SET_RESET_PIN(1);
+        MDELAY(50);      
+       
+        array[0]=0x00043902;
+        array[1]=0x018198FF;
+        dsi_set_cmdq(array, 3, 1);
+        MDELAY(10);
+        array[0]=0x00023700;
+        dsi_set_cmdq(array, 1, 1);
+        //read_reg_v2(0x04, buffer, 3);
+    
+        read_reg_v2(0x00, buffer,1);
+        id_high = buffer[0]; ///////////////////////0x98
+        read_reg_v2(0x01, buffer,1);
+        id_midd = buffer[1]; ///////////////////////0x81
+        read_reg_v2(0x02, buffer,1);
+        id_low = buffer[2]; ////////////////////////0x00
+       // id = (id_midd &lt;&lt; 8) | id_low;
+
+#ifdef BUILD_LK
+    //printf("[erick-lk]%s,  9881 id = 0x%08x,0x%08x\n", __func__, id_high,id_midd);
+#else
+    //printk("[erick-k]%s,  9881 id = 0x%08x,0x%08x\n", __func__, id_high,id_midd);
+#endif
+	if((0x98 == id_high)&&(0x81 == id_midd))
+	{
+		return 1;
+	}
+	else
+	{
+		return 0;
+	}
+    //return (0x98 == id_high)?1:0;
+}
+
+// ---------------------------------------------------------------------------
+//  Get LCM Driver Hooks
+// ---------------------------------------------------------------------------
+LCM_DRIVER hct_ili9881_dsi_vdo_hd_cpt = 
+{
+    .name           = "hct_ili9881_dsi_vdo_hd_cpt",
+    .set_util_funcs = lcm_set_util_funcs,
+    .get_params     = lcm_get_params,
+    .init           = lcm_init,
+    .suspend        = lcm_suspend,
+    .resume         = lcm_resume,   
+    .compare_id    = lcm_compare_id,    
+#if (LCM_DSI_CMD_MODE)
+    //.set_backlight    = lcm_setbacklight,
+    //.esd_check   = lcm_esd_check, 
+    //.esd_recover   = lcm_esd_recover, 
+    .update         = lcm_update,
+#endif  //wqtao
+};
+
diff --git a/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile b/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile
new file mode 100644
index 0000000..03f8000
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for misc devices that really don't fit anywhere else.
+#
+
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y += hct_otm1282a_dsi_vdo_hd_auo.o
+
+
diff --git a/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile~ b/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile~
new file mode 100644
index 0000000..0cf5d6d
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/Makefile~
@@ -0,0 +1,13 @@
+#
+# Makefile for misc devices that really don't fit anywhere else.
+#
+ifdef MTK_LEGCY
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+endif
+
+CFLAGS += -Wno-unused-variable -g
+CFLAGS += -Wno-unused-function -g
+
+obj-y += hct_otm1282a_dsi_vdo_hd_auo.o
+
+
diff --git a/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c b/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c
new file mode 100644
index 0000000..030839c
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c
@@ -0,0 +1,541 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+#ifndef BUILD_LK
+#include <linux/string.h>
+#endif
+
+#include "lcm_drv.h"
+
+#ifdef BUILD_LK
+	#include <platform/mt_gpio.h>
+	#include <string.h>
+#elif defined(BUILD_UBOOT)
+	#include <asm/arch/mt_gpio.h>
+#else
+//	#include <mach/mt_gpio.h>
+#endif
+// ---------------------------------------------------------------------------
+//  Local Constants
+// ---------------------------------------------------------------------------
+
+#define FRAME_WIDTH  (720)
+#define FRAME_HEIGHT (1280)
+
+#define LCM_ID_OTM1282 (0x1282)
+
+#ifndef TRUE
+    #define TRUE 1
+#endif
+
+#ifndef FALSE
+    #define FALSE 0
+#endif
+
+static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
+
+// ---------------------------------------------------------------------------
+//  Local Variables
+// ---------------------------------------------------------------------------
+
+static LCM_UTIL_FUNCS lcm_util = {0};
+
+#define SET_RESET_PIN(v)    (lcm_util.set_reset_pin((v)))
+
+#define UDELAY(n) (lcm_util.udelay(n))
+#define MDELAY(n) (lcm_util.mdelay(n))
+
+#define REGFLAG_DELAY                                                                   0XFE
+#define REGFLAG_END_OF_TABLE                                                            0x100   // END OF REGISTERS MARKER
+
+// ---------------------------------------------------------------------------
+//  Local Functions
+// ---------------------------------------------------------------------------
+
+#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)                lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
+#define dsi_set_cmdq(pdata, queue_size, force_update)           lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
+#define wrtie_cmd(cmd)                                                                          lcm_util.dsi_write_cmd(cmd)
+#define write_regs(addr, pdata, byte_nums)                                      lcm_util.dsi_write_regs(addr, pdata, byte_nums)
+#define read_reg(cmd)                                                                                   lcm_util.dsi_dcs_read_lcm_reg(cmd)
+#define read_reg_v2(cmd, buffer, buffer_size)                                   lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)   
+
+#define   LCM_DSI_CMD_MODE                                                      0
+
+struct LCM_setting_table {
+    unsigned cmd;
+    unsigned char count;
+    unsigned char para_list[64];
+};
+
+static struct LCM_setting_table lcm_initialization_setting[] = {
+
+	{0x0, 1, {0x00}},
+	{0xFF, 3, {0x12, 0x82, 0x01}},
+	{0x0, 1, {0x80}},
+	{0xFF, 2, {0x12, 0x82}},
+
+	{0x0, 1, {0x92}},
+	{0xFF, 2, {0x20, 0x02}},
+	{0x0, 1, {0xB4}},
+	{0xC0, 1, {0x40}},
+	{0x0, 1, {0x91}},
+	{0xB3, 2, {0x08, 0x10}},
+	{0x0, 1, {0xB3}},
+	{0xC0, 1, {0x33}},
+	{0x0, 1, {0x00}},
+	{0x1C, 1, {0x32}},
+	{0x0, 1, {0x84}},
+	{0xA4, 1, {0x00}},
+
+/*TE CLK change from 65Hz to 60 Hz*/
+	{0x0, 1, {0x80}},
+	{0xC0, 14, {0x00, 0x85, 0x00, 0x2C, 0x2C, 0x00, 0x7B, 0x2C, 0x2C, 0x00, 0x7B, 0x00, 0x2C, 0x2C}},
+
+	{0x0, 1, {0xA0}},
+	{0xC0, 7, {0x00, 0x00, 0x00, 0x07, 0x00, 0x19, 0x09}},
+
+	{0x0, 1, {0xD0}},
+	{0xC0, 7, {0x00, 0x00, 0x00, 0x07, 0x00, 0x19, 0x09}},
+
+	{0x0, 1, {0x80}},
+	{0xC1, 2, {0x55, 0x55}},
+	{0x0, 1, {0x90}},
+	{0xC1, 3, {0x66, 0x00, 0x00}},
+	{0x0, 1, {0x80}},
+	{0xC2, 4, {0x83, 0x01, 0x45, 0x45}},
+	{0x0, 1, {0x90}},
+	{0xC2, 15, {0xA9, 0x2C, 0x01, 0x00, 0x00, 0xAB, 0x2C, 0x01, 0x00, 0x00, 0xAA, 0x2C, 0x01, 0x00, 0x00}},
+	{0x0, 1, {0xA0}},
+	{0xC2, 5, {0xA8, 0x2C, 0x01, 0x00, 0x00}},
+	{0x0, 1, {0xEC}},
+	{0xC2, 1, {0x00}},
+	{0x0, 1, {0xFA}},
+	{0xC2, 3, {0x00, 0x80, 0x01}},
+	{0x0, 1, {0x80}},
+	{0xC3, 4, {0x83, 0x01, 0x45, 0x45}},
+	{0x0, 1, {0x90}},
+	{0xC3, 15, {0xA9, 0x2C, 0x01, 0x00, 0x00, 0xAB, 0x2C, 0x01, 0x00, 0x00, 0xAA, 0x2C, 0x01, 0x00, 0x00}},
+	{0x0, 1, {0xA0}},
+	{0xC3, 5, {0xA8, 0x2C, 0x01, 0x00, 0x00}},
+	{0x0, 1, {0xEC}},
+	{0xC3, 1, {0x00}},
+	{0x0, 1, {0x90}},
+	{0xCB, 15, {0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00}},
+	{0x0, 1, {0xA0}},
+	{0xCB, 15, {0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+	{0x0, 1, {0xB0}},
+	{0xCB, 15, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x50, 0xC0, 0x00, 0x00, 0x00, 0x00}},
+	{0x0, 1, {0xC0}},
+	{0xCB, 15, {0xFF, 0x28, 0xEB, 0x28, 0xEB, 0x14, 0x14, 0x14, 0x14, 0x00, 0x14, 0x14, 0xD7, 0x28, 0x28}},
+	{0x0, 1, {0xD0}},
+	{0xCB, 15, {0x28, 0x28, 0x14, 0x14, 0x14, 0xD7, 0x04, 0xF7, 0x04, 0x14, 0x14, 0x14, 0x14, 0x04, 0x04}},
+	{0x0, 1, {0xE0}},
+	{0xCB, 15, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x07, 0x14, 0x14, 0x00, 0x00}},
+	{0x0, 1, {0xF0}},
+	{0xCB, 12, {0x30, 0x03, 0xFC, 0x03, 0xF0, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+	{0x0, 1, {0x80}},
+	{0xCC, 10, {0x0F, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x10}},
+	{0x0, 1, {0xB0}},
+	{0xCC, 10, {0x0F, 0x06, 0x05, 0x04, 0x03, 0x07, 0x08, 0x09, 0x0A, 0x10}},
+	{0x0, 1, {0x8A}},
+	{0xCD, 1, {0x0B}},
+	{0x0, 1, {0xA0}},
+	{0xCD, 15, {0x12, 0x14, 0x15, 0x04, 0x05, 0x01, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x26, 0x25, 0x24}},
+	{0x0, 1, {0xB0}},
+	{0xCD, 15, {0x23, 0x22, 0x21, 0x20, 0x1F, 0x2D, 0x2D, 0x2D, 0x2D, 0x13, 0x0B, 0x0C, 0x2D, 0x2D, 0x2D}},
+	{0x0, 1, {0xC0}},
+	{0xCD, 10, {0x2D, 0x2D, 0x2D, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x1D, 0x2D}},
+	{0x0, 1, {0xD0}},
+	{0xCD, 15, {0x12, 0x14, 0x15, 0x02, 0x03, 0x01, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x26, 0x25, 0x24}},
+	{0x0, 1, {0xE0}},
+	{0xCD, 15, {0x23, 0x22, 0x21, 0x20, 0x1F, 0x2D, 0x2D, 0x2D, 0x2D, 0x13, 0x0B, 0x0C, 0x2D, 0x2D, 0x2D}},
+	{0x0, 1, {0xF0}},
+	{0xCD, 10, {0x2D, 0x2D, 0x2D, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x1D, 0x2D}},
+	{0x0, 1, {0x00}},
+	{0xD9, 1, {0x72}},
+	{0x0, 1, {0x00}},
+	{0xD8, 2, {0x34, 0x34}},
+	{0x0, 1, {0x90}},
+	{0xC5, 4, {0x92, 0xD6, 0xAD, 0xB0}},
+	{0x0, 1, {0xA0}},
+	{0xC5, 4, {0x92, 0xD6, 0xAD, 0xB0}},
+/*use gamma 2.2 parameters*/
+	{0x0, 1, {0x00}},
+/*Gamma Red+ setting*/
+	{0xE1, 24, {0x1B, 0x21, 0x2F, 0x3C, 0x46, 0x4E, 0x5B, 0x6D, 0x79, 0x89, 0x94, 0x9B, 0x60, 0x5D, 0x5A, 0x50, 0x42, 0x34, 0x2A, 0x24, 0x1F, 0x19, 0x18, 0x17}},
+	{0x0, 1, {0x00}},
+/*Gamma Red- setting*/
+	{0xE2, 24, {0x1B, 0x21, 0x2F, 0x3C, 0x46, 0x4E, 0x5B, 0x6D, 0x79, 0x89, 0x94, 0x9B, 0x60, 0x5D, 0x5A, 0x50, 0x42, 0x34, 0x2A, 0x24, 0x1F, 0x19, 0x18, 0x17}},
+	{0x0, 1, {0x00}},
+/*Gamma Green+ setting*/
+	{0xE3, 24, {0x1B, 0x21, 0x2F, 0x3C, 0x46, 0x4E, 0x5B, 0x6D, 0x79, 0x89, 0x94, 0x9B, 0x60, 0x5D, 0x5A, 0x50, 0x42, 0x34, 0x2A, 0x24, 0x1F, 0x19, 0x18, 0x17}},
+	{0x0, 1, {0x00}},
+/*Gamma Green- setting*/
+	{0xE4, 24, {0x1B, 0x21, 0x2F, 0x3C, 0x46, 0x4E, 0x5B, 0x6D, 0x79, 0x89, 0x94, 0x9B, 0x60, 0x5D, 0x5A, 0x50, 0x42, 0x34, 0x2A, 0x24, 0x1F, 0x19, 0x18, 0x17}},
+	{0x0, 1, {0x00}},
+/*Gamma Blue+ setting*/
+	{0xE5, 24, {0x1B, 0x21, 0x2F, 0x3C, 0x46, 0x4E, 0x5B, 0x6D, 0x79, 0x89, 0x94, 0x9B, 0x60, 0x5D, 0x5A, 0x50, 0x42, 0x34, 0x2A, 0x24, 0x1F, 0x19, 0x18, 0x17}},
+	{0x0, 1, {0x00}},
+/*Gamma Blue- setting*/
+	{0xE6, 24, {0x1B, 0x21, 0x2F, 0x3C, 0x46, 0x4E, 0x5B, 0x6D, 0x79, 0x89, 0x94, 0x9B, 0x60, 0x5D, 0x5A, 0x50, 0x42, 0x34, 0x2A, 0x24, 0x1F, 0x19, 0x18, 0x17}},
+	{0x0, 1, {0x93}},
+
+	{0xF5, 1, {0x10}},
+	{0x0, 1, {0x97}},
+	{0xC5, 2, {0x55, 0x50}},
+	{0x0, 1, {0xA7}},
+	{0xC5, 2, {0x55, 0x50}},
+/*Disable level 2 command*/
+	{0x0, 1, {0x80}},
+	{0xA5, 1, {0x0C}},
+	{0x0, 1, {0xB3}},
+	{0xC0, 1, {0x33}},
+	{0x0, 1, {0x80}},
+	{0xC4, 2, {0x04, 0x0F}},
+	{0x0, 1, {0xA0}},
+	{0xC1, 2, {0x02, 0xE0}},
+	{0x0, 1, {0x00}},
+	{0xFF, 3, {0xFF, 0xFF, 0xFF}},
+
+	// Sleep Out
+	{0x11, 1, {0x00}},
+	{REGFLAG_DELAY, 160, {}},
+
+	// Display ON
+	{0x29, 1, {0x00}},
+	{REGFLAG_DELAY, 60, {}},
+};
+static struct LCM_setting_table lcm_sleep_out_setting[] = {
+    // Sleep Out
+	{0x11, 0, {0x00}},
+	{REGFLAG_DELAY, 120, {}},
+
+    // Display ON
+	{0x29, 0, {0x00}},
+	{REGFLAG_DELAY, 10, {}},
+};
+
+static struct LCM_setting_table lcm_sleep_mode_in_setting[] = {
+        // Display off sequence
+        {0x28, 0, {0x00}},
+        {REGFLAG_DELAY, 100, {}},
+
+    // Sleep Mode On
+        {0x10, 0, {0x00}},
+        {REGFLAG_DELAY, 200, {}},
+};
+static struct LCM_setting_table lcm_compare_id_setting[] = {
+        // Display off sequence
+        {0xF0,  5,      {0x55, 0xaa, 0x52,0x08,0x00}},
+        {REGFLAG_DELAY, 10, {}},
+};
+
+
+static void push_table(struct LCM_setting_table *table, unsigned int count, unsigned char force_update)
+{
+        unsigned int i;
+	unsigned cmd;
+
+	for(i = 0; i < count; i++) {
+
+		cmd = table[i].cmd;
+
+		switch (cmd) {
+		case REGFLAG_DELAY :
+			MDELAY(table[i].count);
+			break;
+
+		case REGFLAG_END_OF_TABLE :
+			break;
+
+		default:
+			dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update);
+			MDELAY(2);
+		}
+	}
+        
+}
+
+// ---------------------------------------------------------------------------
+//  LCM Driver Implementations
+// ---------------------------------------------------------------------------
+
+static void lcm_set_util_funcs(const LCM_UTIL_FUNCS *util)
+{
+    memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
+}
+
+
+static void lcm_get_params(LCM_PARAMS *params)
+{
+	memset(params, 0, sizeof(LCM_PARAMS));
+
+	params->type   = LCM_TYPE_DSI;
+
+	params->width  = FRAME_WIDTH;
+	params->height = FRAME_HEIGHT;
+
+	params->dbi.te_mode 	= LCM_DBI_TE_MODE_DISABLED;
+	params->dsi.mode	= SYNC_EVENT_VDO_MODE;
+	params->dsi.intermediat_buffer_num = 4;
+
+
+	// 1 Three lane or Four lane
+	params->dsi.LANE_NUM               = LCM_FOUR_LANE;
+	//The following defined the fomat for data coming from LCD engine.
+	params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
+	params->dsi.data_format.trans_seq   = LCM_DSI_TRANS_SEQ_MSB_FIRST;
+	params->dsi.data_format.padding     = LCM_DSI_PADDING_ON_LSB;
+	params->dsi.data_format.format      = LCM_DSI_FORMAT_RGB888;
+
+	// Highly depends on LCD driver capability.
+	// Not support in MT6573
+	params->dsi.packet_size=256;
+
+	params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
+
+	params->dsi.vertical_sync_active                = 4;//0x3;// 3    2
+	params->dsi.vertical_backporch                  = 20;//0x10;// 20   1
+	params->dsi.vertical_frontporch                 = 20;//0x10; // 1  12
+  	params->dsi.vertical_frontporch_for_low_power 	= 20;
+	params->dsi.vertical_active_line                = FRAME_HEIGHT; 
+
+	params->dsi.ufoe_params.vlc_disable 		= 1;
+	params->dsi.ufoe_params.vlc_disable 		= 1;
+	params->dsi.ufoe_params.lr_mode_en 		= 1;
+
+	params->dsi.horizontal_sync_active              = 8;//0x0B;// 50  2
+	params->dsi.horizontal_backporch                = 65;//0x40 ;
+	params->dsi.horizontal_frontporch               = 75;//0x40 ;
+	params->dsi.horizontal_active_pixel             = FRAME_WIDTH;
+
+	params->dsi.cont_clock	= 0; //1;
+
+	params->dsi.esd_check_enable 			= 1;
+	params->dsi.customization_esd_check_enable	= 1;
+	params->dsi.lcm_esd_check_table[0].cmd		= 0x0a;
+	params->dsi.lcm_esd_check_table[0].count	= 1;
+	params->dsi.lcm_esd_check_table[0].para_list[0]	= 0x9c;
+
+	params->dsi.PLL_CLOCK=240;//227;//254;//254//247
+}
+
+static void lcm_init(void)
+{
+        SET_RESET_PIN(1);
+        MDELAY(50); 
+        SET_RESET_PIN(0);
+        MDELAY(50); 
+        
+        SET_RESET_PIN(1);
+        MDELAY(120);      
+
+        push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
+}
+
+static void lcm_suspend(void)
+{
+#ifndef BUILD_LK
+	push_table(lcm_sleep_mode_in_setting, sizeof(lcm_sleep_mode_in_setting) / sizeof(struct LCM_setting_table), 1);
+#endif
+}
+
+
+static void lcm_resume(void)
+{
+#ifndef BUILD_LK
+	push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
+#endif
+}
+         
+#if (LCM_DSI_CMD_MODE)
+static void lcm_update(unsigned int x, unsigned int y,
+                       unsigned int width, unsigned int height)
+{
+        unsigned int x0 = x;
+        unsigned int y0 = y;
+        unsigned int x1 = x0 + width - 1;
+        unsigned int y1 = y0 + height - 1;
+
+        unsigned char x0_MSB = ((x0>>8)&0xFF);
+        unsigned char x0_LSB = (x0&0xFF);
+        unsigned char x1_MSB = ((x1>>8)&0xFF);
+        unsigned char x1_LSB = (x1&0xFF);
+        unsigned char y0_MSB = ((y0>>8)&0xFF);
+        unsigned char y0_LSB = (y0&0xFF);
+        unsigned char y1_MSB = ((y1>>8)&0xFF);
+        unsigned char y1_LSB = (y1&0xFF);
+
+        unsigned int data_array[16];
+
+        data_array[0]= 0x00053902;
+        data_array[1]= (x1_MSB<<24)|(x0_LSB<<16)|(x0_MSB<<8)|0x2a;
+        data_array[2]= (x1_LSB);
+        dsi_set_cmdq(data_array, 3, 1);
+        
+        data_array[0]= 0x00053902;
+        data_array[1]= (y1_MSB<<24)|(y0_LSB<<16)|(y0_MSB<<8)|0x2b;
+        data_array[2]= (y1_LSB);
+        dsi_set_cmdq(data_array, 3, 1);
+
+        data_array[0]= 0x00290508; //HW bug, so need send one HS packet
+        dsi_set_cmdq(data_array, 1, 1);
+        
+        data_array[0]= 0x002c3909;
+        dsi_set_cmdq(data_array, 1, 0);
+
+}
+#endif
+
+static unsigned int lcm_compare_id(void)
+{
+        unsigned int id0,id1,id=0;
+        unsigned char buffer[5];
+        unsigned int array[16];  
+
+        SET_RESET_PIN(1);
+        SET_RESET_PIN(0);
+        MDELAY(1);
+        
+        SET_RESET_PIN(1);
+        MDELAY(20); 
+
+        array[0] = 0x00053700;// read id return two byte,version and id
+        dsi_set_cmdq(array, 1, 1);
+        
+        read_reg_v2(0xA1, buffer, 5);   //018B1283ff
+        id0 = buffer[2];
+        id1 = buffer[3];
+        id=(id0<<8)|id1;
+        
+    #ifdef BUILD_LK
+                ////printf("%s, LK otm1282a debug: otm1282a id = 0x%08x\n", __func__, id);
+    #else
+                //printk("%s, kernel otm1282a horse debug: otm1282a id = 0x%08x\n", __func__, id);
+    #endif
+
+    if(id == LCM_ID_OTM1282)
+        return 1;
+    else
+        return 0;
+}
+
+static unsigned int lcm_esd_check(void)
+{
+  #ifndef BUILD_LK
+	char  buffer[3];
+	int   array[4];
+
+	if(lcm_esd_test)
+	{
+		lcm_esd_test = FALSE;
+		return TRUE;
+	}
+
+	//hct_set_hs_read();
+	array[0] = 0x00013708;
+	dsi_set_cmdq(array, 1, 1);
+	read_reg_v2(0x0a, buffer, 1);
+
+	if(buffer[0]==0x9c)
+	{
+		return FALSE;
+	}
+	else
+	{                        
+		return TRUE;
+	}
+ #endif
+
+}
+
+static unsigned int lcm_esd_recover(void)
+{
+        lcm_init();
+        lcm_resume();
+
+        return TRUE;
+}
+
+LCM_DRIVER hct_otm1282a_dsi_vdo_hd_auo = 
+{
+	.name		= "hct_otm1282a_dsi_vdo_hd_auo",
+	.set_util_funcs	= lcm_set_util_funcs,
+	.get_params	= lcm_get_params,
+	.init		= lcm_init,
+	.suspend	= lcm_suspend,
+	.resume		= lcm_resume,
+	.compare_id	= lcm_compare_id,        
+#if (LCM_DSI_CMD_MODE)
+	//.set_backlight= lcm_setbacklight,
+	.update         = lcm_update,
+#endif
+	//.esd_check = lcm_esd_check,
+	//.esd_recover=lcm_esd_recover,
+};
diff --git a/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c~ b/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c~
new file mode 100644
index 0000000..0ba31d5
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_otm1282a_dsi_vdo_hd_auo/hct_otm1282a_dsi_vdo_hd_auo.c~
@@ -0,0 +1,902 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+#include "lcm_drv.h"
+
+#ifdef MTK_LEGACY
+
+#if defined(BUILD_LK)
+#include <platform/mt_gpio.h>
+#include <platform/mt_pmic.h>
+#else
+#include <mach/mt_gpio.h>
+#include <mach/mt_pm_ldo.h>
+#endif
+
+#if !defined(BUILD_LK)
+#include <linux/string.h>
+#endif
+
+
+#else /* MTK_LEGCAY*/
+
+#ifndef BUILD_LK
+#include <linux/string.h>
+#endif
+
+#ifdef BUILD_LK
+	#include <platform/mt_gpio.h>
+	#include <string.h>
+#elif defined(BUILD_UBOOT)
+	#include <asm/arch/mt_gpio.h>
+#else
+//	#include <mach/mt_gpio.h>
+#endif
+
+#endif /* MTK_LEGACY */
+
+
+#if defined(BUILD_LK)
+        #define LCM_DEBUG  printf
+        #define LCM_FUNC_TRACE() printf("huyl [uboot] %s\n",__func__)
+#else
+        #define LCM_DEBUG  printk
+        #define LCM_FUNC_TRACE() printk("huyl [kernel] %s\n",__func__)
+#endif
+// ---------------------------------------------------------------------------
+//  Local Constants
+// ---------------------------------------------------------------------------
+
+#define FRAME_WIDTH  (720)
+#define FRAME_HEIGHT (1280)
+
+#define LCM_ID_OTM1282 (0x1282)
+
+#ifndef TRUE
+    #define TRUE 1
+#endif
+
+#ifndef FALSE
+    #define FALSE 0
+#endif
+
+static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
+
+// ---------------------------------------------------------------------------
+//  Local Variables
+// ---------------------------------------------------------------------------
+
+static LCM_UTIL_FUNCS lcm_util = {0};
+
+#define SET_RESET_PIN(v)    (lcm_util.set_reset_pin((v)))
+
+#define UDELAY(n) (lcm_util.udelay(n))
+#define MDELAY(n) (lcm_util.mdelay(n))
+
+#define REGFLAG_DELAY                                                                   0XFE
+#define REGFLAG_END_OF_TABLE                                                            0x100   // END OF REGISTERS MARKER
+
+// ---------------------------------------------------------------------------
+//  Local Functions
+// ---------------------------------------------------------------------------
+
+#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)                lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
+#define dsi_set_cmdq(pdata, queue_size, force_update)           lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
+#define wrtie_cmd(cmd)                                                                          lcm_util.dsi_write_cmd(cmd)
+#define write_regs(addr, pdata, byte_nums)                                      lcm_util.dsi_write_regs(addr, pdata, byte_nums)
+#define read_reg(cmd)                                                                                   lcm_util.dsi_dcs_read_lcm_reg(cmd)
+#define read_reg_v2(cmd, buffer, buffer_size)                                   lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)   
+
+#define   LCM_DSI_CMD_MODE                                                      0
+
+struct LCM_setting_table {
+    unsigned cmd;
+    unsigned char count;
+    unsigned char para_list[64];
+};
+
+static struct LCM_setting_table lcm_initialization_setting[] = {
+
+{0x00,1,{0x00}},
+{0xff,3,{0x12,0x82,0x01}},
+
+{0x00,1,{0x80}},
+{0xff,2,{0x12,0x82}},
+
+{0x00,1,{0x92}},
+{0xff,2,{0x30,0x02}},//fae
+
+
+{0x00,1,{0xb4}},
+{0xc0,1,{0x40}},
+
+{0x00,1,{0x91}},
+{0xb3,2,{0x0c,0x10}},
+
+{0x00,1,{0xb3}},
+{0xc0,1,{0x33}},
+
+{0x00,1,{0x00}},
+{0x1c,1,{0x32}},//32
+
+{0x00,1,{0x84}},
+{0xa4,1,{0x00}},
+{0x00,1,{0x80}},
+{0xc0,14,{0x00,0x85,0x00,0x2c,0x2c,0x00,0x7b,0x2c,0x2c,0x00,0x7b,0x00,0x2c,0x2c}},
+
+{0x00,1,{0xa0}},
+{0xc0,7,{0x00,0x00,0x00,0x07,0x00,0x19,0x09}},
+
+{0x00,1,{0xd0}},
+{0xc0,7,{0x00,0x00,0x00,0x07,0x00,0x19,0x09}},
+
+{0x00,1,{0x80}},
+{0xc1,2,{0x55,0x55}},
+
+{0x00,1,{0x90}},
+{0xc1,3,{0x66,0x00,0x00}},
+
+{0x00,1,{0x80}},
+{0xc2,4,{0x83,0x01,0x45,0x45}},
+
+{0x00,1,{0x90}},
+{0xc2,15,{0xa9,0x2c,0x01,0x00,0x00,0xab,0x2c,0x01,0x00,0x00,0xaa,0x2c,0x01,0x00,0x00}},
+
+{0x00,1,{0xa0}},
+{0xc2,5,{0xa8,0x2c,0x01,0x00,0x00}},
+
+{0x00,1,{0xec}},
+{0xc2,1,{0x00}},
+
+{0x00,1,{0xfa}},
+{0xc2,3,{0x00,0x80,0x01}},
+
+{0x00,1,{0x80}},
+{0xc3,4,{0x83,0x01,0x45,0x45}},
+
+{0x00,1,{0x90}},
+{0xc3,15,{0xa9,0x2c,0x01,0x00,0x00,0xab,0x2c,0x01,0x00,0x00,0xaa,0x2c,0x01,0x00,0x00}},
+
+{0x00,1,{0xa0}},
+{0xc3,5,{0xa8,0x2c,0x01,0x00,0x00}},
+
+{0x00,1,{0xec}},
+{0xc3,1,{0x00}},
+
+{0x00,1,{0x90}},
+{0xcb,15,{0xc0,0x00,0xc0,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x00,0x00}},
+
+{0x00,1,{0xa0}},
+{0xcb,15,{0x00,0x00,0x00,0x00,0x00,0xc0,0x00,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
+
+{0x00,1,{0xb0}},
+{0xcb,15,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x50,0xc0,0x00,0x00,0x00,0x00}},
+
+{0x00,1,{0xc0}},
+{0xcb,15,{0xff,0x28,0xeb,0x28,0xeb,0x14,0x14,0x14,0x14,0x00,0x14,0x14,0xd7,0x28,0x28}},
+
+{0x00,1,{0xd0}},
+{0xcb,15,{0x28,0x28,0x14,0x14,0x14,0xd7,0x04,0xf7,0x04,0x14,0x14,0x14,0x14,0x04,0x04}},
+
+{0x00,1,{0xe0}},
+{0xcb,15,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x15,0x07,0x14,0x14,0x00,0x00}},
+
+{0x00,1,{0xf0}},
+{0xcb,12,{0x30,0x03,0xfc,0x03,0xf0,0x30,0x00,0x00,0x00,0x00,0x00,0x00}},
+
+{0x00,1,{0x80}},
+{0xcc,10,{0x0f,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x10}},
+
+{0x00,1,{0xb0}},
+{0xcc,10,{0x0f,0x06,0x05,0x04,0x03,0x07,0x08,0x09,0x0a,0x10}},
+
+{0x00,1,{0x8a}},
+{0xcd,1,{0x0b}},
+
+{0x00,1,{0xa0}},
+{0xcd,15,{0x12,0x14,0x15,0x04,0x05,0x01,0x0a,0x2d,0x2d,0x2d,0x2d,0x2d,0x26,0x25,0x24}},
+
+{0x00,1,{0xb0}},
+{0xcd,15,{0x23,0x22,0x21,0x20,0x1f,0x2d,0x2d,0x2d,0x2d,0x13,0x0b,0x0c,0x2d,0x2d,0x2d}},
+
+{0x00,1,{0xc0}},
+{0xcd,10,{0x2d,0x2d,0x2d,0x27,0x28,0x29,0x2a,0x2b,0x1d,0x2d}},
+
+{0x00,1,{0xd0}},
+{0xcd,15,{0x12,0x14,0x15,0x02,0x03,0x01,0x0a,0x2d,0x2d,0x2d,0x2d,0x2d,0x26,0x25,0x24}},
+
+{0x00,1,{0xe0}},
+{0xcd,15,{0x23,0x22,0x21,0x20,0x1f,0x2d,0x2d,0x2d,0x2d,0x13,0x0b,0x0c,0x2d,0x2d,0x2d}},
+
+{0x00,1,{0xf0}},
+{0xcd,10,{0x2d,0x2d,0x2d,0x27,0x28,0x29,0x2a,0x2b,0x1d,0x2d}},
+
+{0x00,1,{0x00}},
+{0xd9,1,{0x6e}},
+
+{0x00,1,{0x00}},
+{0xd8,2,{0x33,0x33}},
+
+{0x00,1,{0x90}},
+{0xc5,4,{0x92,0xd6,0xad,0xb0}},
+
+{0x00,1,{0xa0}},
+{0xc5,4,{0x92,0xd6,0xad,0xb0}},
+
+#if 1
+{0x00,1,{0x00}},
+{0xe1,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x99,0xa0,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
+{0x00,1,{0x00}},
+{0xe2,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x9a,0xa1,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
+{0x00,1,{0x00}},
+{0xe3,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x99,0xa0,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
+{0x00,1,{0x00}},
+{0xe4,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x9a,0xa1,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
+{0x00,1,{0x00}},
+{0xe5,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x99,0xa0,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
+{0x00,1,{0x00}},
+{0xe6,24,{0x1b,0x21,0x31,0x3f,0x49,0x52,0x5e,0x71,0x7d,0x8f,0x9a,0xa1,0x5b,0x57,0x54,0x48,0x39,0x2a,0x20,0x1a,0x15,0x10,0x0c,0x0a}},
+
+#else
+{0x00,1,{0x00}},
+{0xe1,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
+{0x00,1,{0x00}},
+{0xe2,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
+{0x00,1,{0x00}},
+{0xe3,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
+{0x00,1,{0x00}},
+{0xe4,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
+{0x00,1,{0x00}},
+{0xe5,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
+{0x00,1,{0x00}},
+{0xe6,24,{0x1b,0x21,0x2f,0x3c,0x46,0x4e,0x5b,0x6d,0x79,0x89,0x94,0x9b,0x60,0x5d,0x5a,0x50,0x42,0x34,0x2a,0x24,0x1f,0x19,0x18,0x17}},
+#endif
+
+{0x00,1,{0x93}},
+{0xf5,1,{0x10}},
+
+{0x00,1,{0x97}},
+{0xc5,2,{0x33,0x30}},
+
+{0x00,1,{0xa7}},
+{0xc5,2,{0x33,0x30}},
+
+{0x00,1,{0x80}},
+{0xa5,1,{0x0c}},
+
+{0x00,1,{0xb3}},
+{0xc0,1,{0x33}},
+
+{0x00,1,{0x80}},
+{0xc4,2,{0x04,0x0f}},
+
+{0x00,1,{0xa0}},
+{0xc1,2,{0xE8,0xe0}},
+
+{0x00,1,{0x00}},
+{0xff,3,{0xff,0xff,0xff}},
+
+/*
+{0x00,1,{0x00}},
+{0xff,3,{0x12,0x82,0x01}},
+	
+{0x00, 1 , {0x80}},
+{0xFF, 2 ,{0x12,0x82}},
+
+{0x00,1,{0x92}},
+{0xff,2,{0x30,0x02}},
+
+{0x00, 1 , {0x80}},
+{0xC0, 14 ,{0x00,0x85,0x00,0x2C,0x2C,0x00,0x7B,0x2C,0x2C,0x00,0x7B,0x00,0x2C,0x2C}},
+
+{0x00, 1 , {0xA0}},
+{0xC0,  7 ,{0x00,0x00,0x00,0x07,0x00,0x19,0x09}},
+
+{0x00, 1 , {0xD0}},
+{0xC0,  7 ,{0x00,0x00,0x07,0x0C,0x00,0x19,0x09}},
+
+{0x00, 1 , {0x80}},
+{0xC1,  2 ,{0x55,0x55}},
+
+{0x00, 1 , {0x90}},
+{0xC1,  3 ,{0x66,0x00,0x00}},
+
+{0x00, 1 , {0x80}},
+{0xC2,  4 ,{0x82,0x00,0x45,0x45}},
+
+{0x00, 1 , {0x90}},
+{0xC2, 15 ,{0xAB,0x2D,0x00,0x02,0x00,0xAA,0x2C,0x00,0x02,0x00,0xAB,0x2C,0x01,0x00,0x00}},
+
+{0x00, 1 , {0xA0}},
+{0xC2,  5 ,{0xA9,0x2C,0x01,0x00,0x00}},
+
+{0x00, 1 , {0xEC}},
+{0xC2,  1 ,{0x00}},
+
+{0x02,  1 ,{0xFA}},
+{0xC2,  3 ,{0x00,0x80,0x01}},
+
+{0x00, 1 , {0x80}},
+{0xC3,  4 ,{0x82,0x00,0x45,0x45}},
+
+{0x00, 1 , {0x90}},
+{0xC3, 15 ,{0xAB,0x2D,0x00,0x02,0x00,0xAA,0x2C,0x00,0x02,0x00,0xAB,0x2C,0x01,0x00,0x00}},
+
+{0x00, 1 , {0xA0}},
+{0xC3,  5 ,{0xA9,0x2C,0x01,0x00,0x00}},
+
+{0x00, 1 , {0xEC}},
+{0xC3,  1 ,{0x00}},
+
+{0x00, 1 , {0x90}},
+{0xCB, 15 ,{0xC0,0x00,0xC0,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0x00}},
+
+{0x00, 1 , {0xA0}},
+{0xCB, 15 ,{0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
+
+{0x00, 1 , {0xB0}},
+{0xCB, 15 ,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x50,0xC0,0x00,0x00,0x00,0x00}},
+
+{0x00, 1 , {0xC0}},
+{0xCB, 15 ,{0xFF,0x28,0xEB,0x28,0xEB,0x14,0x14,0x14,0x14,0x00,0x14,0x14,0xD7,0x28,0x28}},
+
+{0x00, 1 , {0xD0}},
+{0xCB, 15 ,{0x28,0x28,0x14,0x14,0x04,0xF7,0x04,0xF7,0x04,0x14,0x14,0x14,0x14,0x04,0x04}},
+
+{0x00, 1 , {0xE0}},
+{0xCB, 15 ,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x15,0x15,0x07,0x14,0x14,0x00,0x00}},
+
+{0x00, 1 , {0x80}},
+{0xF5,  1 ,{0x01}},
+
+{0x00, 1 , {0x81}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0x91}},
+{0xB0,  1 ,{0x9E}},
+
+{0x00, 1 , {0x90}},
+{0xA5,  1 ,{0x00}},
+
+{0x00, 1 , {0xD2}},
+{0xF5,  1 ,{0x20}},
+
+{0x00, 1 , {0x81}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0x83}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0x87}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0x89}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0x91}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0x93}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0x95}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0x97}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0x99}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0xA7}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0xC1}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0xC3}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0xC5}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0xC7}},
+{0xF5,  1 ,{0x18}},
+
+{0x00, 1 , {0xC9}},
+{0xF5,  1 ,{0x14}},
+
+{0x00, 1 , {0xF0}},
+{0xCB, 12 ,{0x30,0x03,0xFC,0x03,0xF0,0x30,0x00,0x00,0x00,0x00,0x00,0x00}},
+
+{0x00, 1 , {0x80}},
+{0xCC, 10 ,{0x0F,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x10}},
+
+{0x00, 1 , {0xB0}},
+{0xCC, 10 ,{0x0F,0x04,0x03,0x06,0x05,0x07,0x08,0x09,0x0A,0x10}},
+
+{0x00, 1 , {0x8A}},
+{0xCD,  1 ,{0x0B}},
+
+{0x00, 1 , {0xA0}},
+{0xCD, 15 ,{0x12,0x14,0x15,0x02,0x03,0x01,0x0A,0x2D,0x2D,0x2D,0x2D,0x2D,0x26,0x25,0x24}},
+
+{0x00, 1 , {0xB0}},
+{0xCD, 15 ,{0x23,0x22,0x21,0x20,0x1F,0x2D,0x2D,0x2D,0x2D,0x13,0x0B,0x0C,0x2D,0x2D,0x2D}},
+
+{0x00, 1 , {0xC0}},
+{0xCD, 10 ,{0x2D,0x2D,0x2D,0x27,0x28,0x29,0x2A,0x2B,0x1D,0x2D}},
+
+{0x00, 1 , {0xD0}},
+{0xCD, 15 ,{0x12,0x14,0x15,0x02,0x03,0x01,0x0A,0x2D,0x2D,0x2D,0x2D,0x2D,0x26,0x25,0x24}},
+
+{0x00, 1 , {0xE0}},
+{0xCD, 15 ,{0x23,0x22,0x21,0x20,0x1F,0x2D,0x2D,0x2D,0x2D,0x13,0x0B,0x0C,0x2D,0x2D,0x2D}},
+
+{0x00, 1 , {0xF0}},
+{0xCD, 10 ,{0x2D,0x2D,0x2D,0x27,0x28,0x29,0x2A,0x2B,0x1D,0x2D}},
+
+{0x00, 1 , {0x90}},
+{0xB4,  1 ,{0x11}},
+
+{0x00, 1 , {0x81}},
+{0xC4,  1 ,{0x04}},
+
+{0x00, 1 , {0xC0}},
+{0xF5,  4 ,{0x00,0x00,0x00,0x00}},
+
+{0x00, 1 , {0x80}},
+{0xA4,  1 ,{0x08}},
+
+{0x00, 1 , {0x00}},
+{0xD9,  1 ,{0x74}},
+
+{0x00, 1 , {0x90}},
+{0xC5,  4 ,{0x92,0xD6,0xB6,0xB4}},
+
+{0x00, 1 , {0xA0}},
+{0xC5,  4 ,{0x92,0xD6,0xB6,0xB4}},
+
+{0x00, 1 , {0x00}},
+{0xD9,  1 ,{0x74}},
+
+{0x00, 1 , {0x00}},
+{0xD8,  2 ,{0x72,0x72}},
+
+{0x00, 1 , {0x90}},
+{0xC5,  4 ,{0x92,0xD6,0xB6,0xB4}},
+
+{0x00, 1 , {0xA0}},
+{0xC5,  4 ,{0x92,0xD6,0xB6,0xB4}},
+
+{0x00, 1 , {0x00}},
+{0xE1, 24 ,{0x29,0x3B,0x45,0x4E,0x57,0x5D,0x68,0x78,0x7F,0x8F,0x97,0x9C,0x5D,0x5C,0x5A,0x51,0x45,0x2B,0x27,0x25,0x1A,0x18,0x17,0x15}},
+
+{0x00, 1 , {0x00}},
+{0xE2, 24 ,{0x30,0x3A,0x46,0x50,0x57,0x5F,0x6A,0x78,0x82,0x8F,0x97,0x9D,0x5F,0x5C,0x5A,0x52,0x45,0x2C,0x28,0x26,0x19,0x16,0x15,0x12}},
+
+{0x00, 1 , {0xCA}},
+{0xCB,  2 ,{0xD4,0xD4}},
+
+{0x00, 1 , {0xD3}},
+{0xCB,  1 ,{0xD4}},
+
+{0x00, 1 , {0x90}},
+{0xB4,  1 ,{0x11}},
+
+{0x00,1,{0x00}},
+{0xff,3,{0xff,0xff,0xff}},
+*/
+
+{0x00,	1,	{0xb8}}, 
+{0xb0, 1,	{0x05}},
+
+
+{0x35,1,{0x00}},
+
+{0x11,1,{0x00}},//SLEEP OUT
+{REGFLAG_DELAY,120,{}},
+                                                                                                                        
+{0x29,1,{0x00}},//Display ON 
+{REGFLAG_DELAY,20,{}},  
+{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+static struct LCM_setting_table lcm_sleep_out_setting[] = {
+    // Sleep Out
+        {0x11, 0, {0x00}},
+    {REGFLAG_DELAY, 120, {}},
+
+    // Display ON
+        {0x29, 0, {0x00}},
+        {REGFLAG_DELAY, 10, {}},
+        
+        {REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+
+static struct LCM_setting_table lcm_sleep_mode_in_setting[] = {
+        // Display off sequence
+        {0x28, 0, {0x00}},
+        {REGFLAG_DELAY, 100, {}},
+
+    // Sleep Mode On
+        {0x10, 0, {0x00}},
+        {REGFLAG_DELAY, 200, {}},
+        {REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+static struct LCM_setting_table lcm_compare_id_setting[] = {
+        // Display off sequence
+        {0xF0,  5,      {0x55, 0xaa, 0x52,0x08,0x00}},
+        {REGFLAG_DELAY, 10, {}},
+
+        {REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+
+static void push_table(struct LCM_setting_table *table, unsigned int count, unsigned char force_update)
+{
+        unsigned int i;
+
+    for(i = 0; i < count; i++) {
+                
+        unsigned cmd;
+        cmd = table[i].cmd;
+                
+        switch (cmd) {
+                        
+            case REGFLAG_DELAY :
+                MDELAY(table[i].count);
+                break;
+                                
+            case REGFLAG_END_OF_TABLE :
+                break;
+                                
+            default:
+                                dsi_set_cmdq_V2(cmd, table[i].count, table[i].para_list, force_update);
+                                MDELAY(2);
+        }
+    }
+        
+}
+
+
+
+
+// ---------------------------------------------------------------------------
+//  LCM Driver Implementations
+// ---------------------------------------------------------------------------
+
+static void lcm_set_util_funcs(const LCM_UTIL_FUNCS *util)
+{
+    memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
+}
+
+
+static void lcm_get_params(LCM_PARAMS *params)
+{
+
+            memset(params, 0, sizeof(LCM_PARAMS));
+        
+                params->type   = LCM_TYPE_DSI;
+
+                params->width  = FRAME_WIDTH;
+                params->height = FRAME_HEIGHT;
+
+                // enable tearing-free
+                params->dbi.te_mode                             = LCM_DBI_TE_MODE_DISABLED;
+                //params->dbi.te_edge_polarity          = LCM_POLARITY_RISING;
+
+
+                params->dsi.mode   = SYNC_EVENT_VDO_MODE; //SYNC_PULSE_VDO_MODE;//BURST_VDO_MODE; 
+
+        
+                // DSI
+                /* Command mode setting */
+                 // 1 Three lane or Four lane
+                params->dsi.LANE_NUM                            = LCM_FOUR_LANE;
+                //The following defined the fomat for data coming from LCD engine.
+                params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
+                params->dsi.data_format.trans_seq   = LCM_DSI_TRANS_SEQ_MSB_FIRST;
+                params->dsi.data_format.padding     = LCM_DSI_PADDING_ON_LSB;
+                params->dsi.data_format.format      = LCM_DSI_FORMAT_RGB888;
+
+                // Highly depends on LCD driver capability.
+                // Not support in MT6573
+                params->dsi.packet_size=256;
+
+                // Video mode setting           
+                params->dsi.intermediat_buffer_num = 2;//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage
+
+                params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
+          //      params->dsi.word_count=720*3;   
+
+                
+                params->dsi.vertical_sync_active                                = 4;//0x3;// 3    2
+                params->dsi.vertical_backporch                                  = 20;//0x10;// 20   1
+                params->dsi.vertical_frontporch                                 = 16;//0x10; // 1  12
+                params->dsi.vertical_active_line                                = FRAME_HEIGHT; 
+
+                params->dsi.horizontal_sync_active                              = 8;//0x0B;// 50  2
+                params->dsi.horizontal_backporch                                = 65;//0x40 ;
+                params->dsi.horizontal_frontporch                               = 75;//0x40 ;
+                params->dsi.horizontal_active_pixel                             = FRAME_WIDTH;
+
+    		params->dsi.cont_clock=0; //1;
+	
+		params->dsi.esd_check_enable = 1;
+		params->dsi.customization_esd_check_enable = 1;
+		params->dsi.lcm_esd_check_table[0].cmd = 0x0a;
+		params->dsi.lcm_esd_check_table[0].count = 1;
+		params->dsi.lcm_esd_check_table[0].para_list[0] = 0x9c;
+#if 0
+params->dsi.HS_PRPR=3;
+params->dsi.CLK_HS_POST=22;
+params->dsi.DA_HS_EXIT=20;
+#endif
+
+
+            //params->dsi.LPX=8; 
+
+                // Bit rate calculation
+                // 1 Every lane speed
+#if 0
+                params->dsi.pll_div1=0;         // div1=0,1,2,3;div1_real=1,2,4,4 ----0: 546Mbps  1:273Mbps
+                params->dsi.pll_div2=1;         // div2=0,1,2,3;div1_real=1,2,4,4       
+        params->dsi.fbk_sel=1;           // fbk_sel=0,1,2,3;fbk_sel_real=1,2,4,4
+                params->dsi.fbk_div =20;    // fref=26MHz, fvco=fref*(fbk_div+1)*2/(div1_real*div2_real)        
+#else
+        params->dsi.PLL_CLOCK=240;//227;//254;//254//247
+#endif
+}
+
+static void lcm_init(void)
+{
+        SET_RESET_PIN(1);
+        MDELAY(50); 
+        SET_RESET_PIN(0);
+        MDELAY(50); 
+        
+        SET_RESET_PIN(1);
+        MDELAY(120);      
+
+        push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
+}
+
+
+
+static void lcm_suspend(void)
+{
+#ifndef BUILD_LK
+#if 0
+        SET_RESET_PIN(1);
+          MDELAY(20);
+          SET_RESET_PIN(0);
+          MDELAY(20);
+
+          SET_RESET_PIN(1);
+          MDELAY(120);
+
+          push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
+#else
+        push_table(lcm_sleep_mode_in_setting, sizeof(lcm_sleep_mode_in_setting) / sizeof(struct LCM_setting_table), 1);
+#endif
+#endif
+
+}
+
+
+static void lcm_resume(void)
+{
+#ifndef BUILD_LK
+
+        //lcm_init();
+        push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
+#endif
+}
+         
+#if (LCM_DSI_CMD_MODE)
+static void lcm_update(unsigned int x, unsigned int y,
+                       unsigned int width, unsigned int height)
+{
+        unsigned int x0 = x;
+        unsigned int y0 = y;
+        unsigned int x1 = x0 + width - 1;
+        unsigned int y1 = y0 + height - 1;
+
+        unsigned char x0_MSB = ((x0>>8)&0xFF);
+        unsigned char x0_LSB = (x0&0xFF);
+        unsigned char x1_MSB = ((x1>>8)&0xFF);
+        unsigned char x1_LSB = (x1&0xFF);
+        unsigned char y0_MSB = ((y0>>8)&0xFF);
+        unsigned char y0_LSB = (y0&0xFF);
+        unsigned char y1_MSB = ((y1>>8)&0xFF);
+        unsigned char y1_LSB = (y1&0xFF);
+
+        unsigned int data_array[16];
+
+        data_array[0]= 0x00053902;
+        data_array[1]= (x1_MSB<<24)|(x0_LSB<<16)|(x0_MSB<<8)|0x2a;
+        data_array[2]= (x1_LSB);
+        dsi_set_cmdq(data_array, 3, 1);
+        
+        data_array[0]= 0x00053902;
+        data_array[1]= (y1_MSB<<24)|(y0_LSB<<16)|(y0_MSB<<8)|0x2b;
+        data_array[2]= (y1_LSB);
+        dsi_set_cmdq(data_array, 3, 1);
+
+        data_array[0]= 0x00290508; //HW bug, so need send one HS packet
+        dsi_set_cmdq(data_array, 1, 1);
+        
+        data_array[0]= 0x002c3909;
+        dsi_set_cmdq(data_array, 1, 0);
+
+}
+#endif
+
+static unsigned int lcm_compare_id(void)
+{
+        unsigned int id0,id1,id=0;
+        unsigned char buffer[5];
+        unsigned int array[16];  
+
+//return 1;
+        SET_RESET_PIN(1);
+        SET_RESET_PIN(0);
+        MDELAY(1);
+        
+        SET_RESET_PIN(1);
+        MDELAY(20); 
+
+        array[0] = 0x00053700;// read id return two byte,version and id
+        dsi_set_cmdq(array, 1, 1);
+        
+        read_reg_v2(0xA1, buffer, 5);   //018B1283ff
+        id0 = buffer[2];
+        id1 = buffer[3];
+        id=(id0<<8)|id1;
+        
+    #ifdef BUILD_LK
+                printf("%s, LK otm1282a debug: otm1282a id = 0x%08x\n", __func__, id);
+    #else
+                printk("%s, kernel otm1282a horse debug: otm1282a id = 0x%08x\n", __func__, id);
+    #endif
+
+    if(id == LCM_ID_OTM1282)
+        return 1;
+    else
+        return 0;
+
+
+}
+
+//extern void hct_set_hs_read();
+//extern void hct_restore_HS_read();
+
+
+static unsigned int lcm_esd_check(void)
+{
+  #ifndef BUILD_LK
+        char  buffer[3];
+        int   array[4];
+
+        if(lcm_esd_test)
+        {
+                lcm_esd_test = FALSE;
+                return TRUE;
+        }
+
+
+	//hct_set_hs_read();
+	array[0] = 0x00013708;
+	dsi_set_cmdq(array, 1, 1);
+	 read_reg_v2(0x0a, buffer, 1);
+	// printk("otm1282 lcm_esd_check %x %x\n",buffer[0]);
+	//hct_restore_HS_read();
+
+
+      //  array[0] = 0x00013700;
+        //dsi_set_cmdq(array, 1, 1);
+
+     //   read_reg_v2(0x36, buffer, 1);
+        if(buffer[0]==0x9c)
+        {
+                return FALSE;
+        }
+        else
+        {                        
+                return TRUE;
+        }
+ #endif
+
+}
+
+static unsigned int lcm_esd_recover(void)
+{
+        lcm_init();
+        lcm_resume();
+
+        return TRUE;
+}
+
+LCM_DRIVER hct_otm1282a_dsi_vdo_hd_auo = 
+{
+    .name                       = "hct_otm1282a_dsi_vdo_hd_auo",
+        .set_util_funcs = lcm_set_util_funcs,
+        .get_params     = lcm_get_params,
+        .init           = lcm_init,
+        .suspend        = lcm_suspend,
+        .resume         = lcm_resume,
+        .compare_id    = lcm_compare_id,        
+#if (LCM_DSI_CMD_MODE)
+        //.set_backlight        = lcm_setbacklight,
+    .update         = lcm_update,
+#endif
+ //.esd_check = lcm_esd_check,
+ //.esd_recover=lcm_esd_recover,
+};
diff --git a/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile b/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile
new file mode 100644
index 0000000..76a5a8c
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for misc devices that really don't fit anywhere else.
+#
+
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y += hct_rm68200_dsi_vdo_hd_cpt.o
+
+
+
+
diff --git a/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile~ b/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile~
new file mode 100644
index 0000000..89914fa
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/Makefile~
@@ -0,0 +1,15 @@
+#
+# Makefile for misc devices that really don't fit anywhere else.
+#
+ifdef MTK_LEGCY
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+endif
+
+ccflags-y += -Wno-unused-variable -g
+ccflags-y += -Wno-unused-function -g
+
+obj-y += hct_rm68200_dsi_vdo_hd_cpt.o
+
+
+
+
diff --git a/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c b/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c
new file mode 100644
index 0000000..0c3106d
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c
@@ -0,0 +1,752 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+#ifndef BUILD_LK
+#include <linux/string.h>
+#endif
+
+#include "lcm_drv.h"
+
+#ifdef BUILD_LK
+	#include <platform/mt_gpio.h>
+	#include <string.h>
+#elif defined(BUILD_UBOOT)
+	#include <asm/arch/mt_gpio.h>
+#else
+//	#include <mach/mt_gpio.h>
+#endif
+
+// ---------------------------------------------------------------------------
+//  Local Constants
+// ---------------------------------------------------------------------------
+
+#define FRAME_WIDTH  										(720)
+#define FRAME_HEIGHT 										(1280)
+#define LCM_ID                       						(0x1284)
+
+#define REGFLAG_DELAY             							(0XFFFE)
+#define REGFLAG_END_OF_TABLE      							(0xFFFF)	// END OF REGISTERS MARKER
+
+
+#define LCM_DSI_CMD_MODE									0
+
+#ifndef TRUE
+    #define TRUE 1
+#endif
+
+#ifndef FALSE
+    #define FALSE 0
+#endif
+
+// ---------------------------------------------------------------------------
+//  Local Variables
+// ---------------------------------------------------------------------------
+
+static LCM_UTIL_FUNCS lcm_util = {0};
+
+#define SET_RESET_PIN(v)    								(lcm_util.set_reset_pin((v)))
+
+#define UDELAY(n) 											(lcm_util.udelay(n))
+#define MDELAY(n) 											(lcm_util.mdelay(n))
+
+#define LCM_RM68200_ID 		(0x6820)
+
+static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
+
+// ---------------------------------------------------------------------------
+//  Local Functions
+// ---------------------------------------------------------------------------
+
+#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)	lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
+#define dsi_set_cmdq(pdata, queue_size, force_update)		lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
+#define wrtie_cmd(cmd)										lcm_util.dsi_write_cmd(cmd)
+#define write_regs(addr, pdata, byte_nums)					lcm_util.dsi_write_regs(addr, pdata, byte_nums)
+#define read_reg(cmd)											lcm_util.dsi_dcs_read_lcm_reg(cmd)
+#define read_reg_v2(cmd, buffer, buffer_size)				lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)
+
+ struct LCM_setting_table {
+    unsigned cmd;
+    unsigned char count;
+    unsigned char para_list[64];
+};
+
+
+static struct LCM_setting_table lcm_initialization_setting[] = {
+
+	/*
+Note :
+
+Data ID will depends on the following rule.
+
+count of parameters > 1      => Data ID = 0x39
+count of parameters = 1      => Data ID = 0x15
+count of parameters = 0      => Data ID = 0x05
+
+Struclcm_deep_sleep_mode_in_settingture Format :
+
+{DCS command, count of parameters, {parameter list}}
+{REGFLAG_DELAY, milliseconds of time, {}},
+
+...
+
+Setting ending by predefined flag
+
+{REGFLAG_END_OF_TABLE, 0x00, {}}
+*/
+//RM38200+HSD5.94 YKL CODE
+{0xfe, 1, {0x01}},
+{0x24, 1, {0xc0}},
+{0x25, 1, {0x53}},
+{0x26, 1, {0x00}},
+{0x2b, 1, {0xe5}},
+{0x27, 1, {0x0a}},
+{0x29, 1, {0x0a}},
+{0x2f, 1, {0x44}},
+{0x34, 1, {0x55}},
+{0x1b, 1, {0x00}},
+{0x12, 1, {0x08}},
+{0x46, 1, {0x86}},
+{0x52, 1, {0xa0}},
+{0x53, 1, {0x00}},
+{0x54, 1, {0xa0}},
+{0x55, 1, {0x00}},
+{0x5f, 1, {0x12}},
+{0xfe, 1, {0x03}},
+{0x0, 1, {0x05}},
+{0x1, 1, {0x16}},
+{0x2, 1, {0x01}},
+{0x3, 1, {0x08}},
+{0x4, 1, {0x00}},
+{0x5, 1, {0x00}},
+{0x6, 1, {0x50}},
+{0x7, 1, {0x00}},
+{0x8, 1, {0x00}},
+{0x9, 1, {0x00}},
+{0xa, 1, {0x00}},
+{0xb, 1, {0x00}},
+{0xc, 1, {0x00}},
+{0xd, 1, {0x00}},
+{0xe, 1, {0x05}},
+{0xf, 1, {0x06}},
+{0x10, 1, {0x07}},
+{0x11, 1, {0x08}},
+{0x12, 1, {0x00}},
+{0x13, 1, {0x40}},
+{0x14, 1, {0x00}},
+{0x15, 1, {0xc5}},
+{0x16, 1, {0x08}},
+{0x17, 1, {0x09}},
+{0x18, 1, {0x0a}},
+{0x19, 1, {0x0b}},
+{0x1a, 1, {0x0c}},
+{0x1b, 1, {0x00}},
+{0x1c, 1, {0x40}},
+{0x1d, 1, {0x00}},
+{0x1e, 1, {0x85}},
+{0x1f, 1, {0x08}},
+{0x20, 1, {0x00}},
+{0x21, 1, {0x00}},
+{0x22, 1, {0x05}},
+{0x23, 1, {0x04}},
+{0x24, 1, {0x06}},
+{0x25, 1, {0x2d}},
+{0x26, 1, {0x00}},
+{0x27, 1, {0x08}},
+{0x28, 1, {0x0a}},
+{0x29, 1, {0x2d}},
+{0x2a, 1, {0x00}},
+{0x2b, 1, {0x00}},
+{0x2d, 1, {0x00}},
+{0x2f, 1, {0x00}},
+{0x30, 1, {0x00}},
+{0x31, 1, {0x00}},
+{0x32, 1, {0x00}},
+{0x33, 1, {0x00}},
+{0x34, 1, {0x00}},
+{0x35, 1, {0x00}},
+{0x36, 1, {0x00}},
+{0x37, 1, {0x00}},
+{0x38, 1, {0x00}},
+{0x39, 1, {0x00}},
+{0x3a, 1, {0x00}},
+{0x3b, 1, {0x00}},
+{0x3d, 1, {0x00}},
+{0x3f, 1, {0x00}},
+{0x40, 1, {0x00}},
+{0x41, 1, {0x00}},
+{0x42, 1, {0x00}},
+{0x43, 1, {0x00}},
+{0x44, 1, {0x00}},
+{0x45, 1, {0x00}},
+{0x46, 1, {0x00}},
+{0x47, 1, {0x00}},
+{0x48, 1, {0x00}},
+{0x49, 1, {0x00}},
+{0x4a, 1, {0x00}},
+{0x4b, 1, {0x00}},
+{0x4c, 1, {0x00}},
+{0x4d, 1, {0x00}},
+{0x4e, 1, {0x00}},
+{0x4f, 1, {0x00}},
+{0x50, 1, {0x00}},
+{0x51, 1, {0x00}},
+{0x52, 1, {0x00}},
+{0x53, 1, {0x00}},
+{0x54, 1, {0x00}},
+{0x55, 1, {0x00}},
+{0x56, 1, {0x00}},
+{0x58, 1, {0x00}},
+{0x59, 1, {0x00}},
+{0x5a, 1, {0x00}},
+{0x5b, 1, {0x00}},
+{0x5c, 1, {0x00}},
+{0x5d, 1, {0x00}},
+{0x5e, 1, {0x00}},
+{0x5f, 1, {0x00}},
+{0x60, 1, {0x00}},
+{0x61, 1, {0x00}},
+{0x62, 1, {0x00}},
+{0x63, 1, {0x00}},
+{0x64, 1, {0x00}},
+{0x65, 1, {0x00}},
+{0x66, 1, {0x00}},
+{0x67, 1, {0x00}},
+{0x68, 1, {0x00}},
+{0x69, 1, {0x00}},
+{0x6a, 1, {0x00}},
+{0x6b, 1, {0x00}},
+{0x6c, 1, {0x00}},
+{0x6d, 1, {0x00}},
+{0x6e, 1, {0x00}},
+{0x6f, 1, {0x00}},
+{0x70, 1, {0x00}},
+{0x71, 1, {0x00}},
+{0x72, 1, {0x00}},
+{0x73, 1, {0x00}},
+{0x74, 1, {0x01}},
+{0x75, 1, {0x01}},
+{0x76, 1, {0x01}},
+{0x77, 1, {0x01}},
+{0x78, 1, {0x01}},
+{0x79, 1, {0x01}},
+{0x7a, 1, {0x00}},
+{0x7b, 1, {0x00}},
+{0x7c, 1, {0x00}},
+{0x7d, 1, {0x00}},
+{0x7e, 1, {0x01}},
+{0x7f, 1, {0x09}},
+{0x80, 1, {0x0b}},
+{0x81, 1, {0x0d}},
+{0x82, 1, {0x0f}},
+{0x83, 1, {0x3f}},
+{0x84, 1, {0x3f}},
+{0x85, 1, {0x1c}},
+{0x86, 1, {0x1c}},
+{0x87, 1, {0x3f}},
+{0x88, 1, {0x3f}},
+{0x89, 1, {0x3f}},
+{0x8a, 1, {0x3f}},
+{0x8b, 1, {0x3f}},
+{0x8c, 1, {0x3f}},
+{0x8d, 1, {0x3f}},
+{0x8e, 1, {0x3f}},
+{0x8f, 1, {0x3f}},
+{0x90, 1, {0x3f}},
+{0x91, 1, {0x1d}},
+{0x92, 1, {0x1c}},
+{0x93, 1, {0x03}},
+{0x94, 1, {0x02}},
+{0x95, 1, {0x1c}},
+{0x96, 1, {0x1d}},
+{0x97, 1, {0x3f}},
+{0x98, 1, {0x3f}},
+{0x99, 1, {0x3f}},
+{0x9a, 1, {0x3f}},
+{0x9b, 1, {0x3f}},
+{0x9c, 1, {0x3f}},
+{0x9d, 1, {0x3f}},
+{0x9e, 1, {0x3f}},
+{0x9f, 1, {0x3f}},
+{0xa0, 1, {0x3f}},
+{0xa2, 1, {0x1c}},
+{0xa3, 1, {0x1c}},
+{0xa4, 1, {0x3f}},
+{0xa5, 1, {0x3f}},
+{0xa6, 1, {0x0e}},
+{0xa7, 1, {0x0c}},
+{0xa9, 1, {0x0a}},
+{0xaa, 1, {0x08}},
+{0xab, 1, {0x00}},
+{0xac, 1, {0x02}},
+{0xad, 1, {0x0e}},
+{0xae, 1, {0x0c}},
+{0xaf, 1, {0x0a}},
+{0xb0, 1, {0x08}},
+{0xb1, 1, {0x3f}},
+{0xb2, 1, {0x3f}},
+{0xb3, 1, {0x1c}},
+{0xb4, 1, {0x1c}},
+{0xb5, 1, {0x3f}},
+{0xb6, 1, {0x3f}},
+{0xb7, 1, {0x3f}},
+{0xb8, 1, {0x3f}},
+{0xb9, 1, {0x3f}},
+{0xba, 1, {0x3f}},
+{0xbb, 1, {0x3f}},
+{0xbc, 1, {0x3f}},
+{0xbd, 1, {0x3f}},
+{0xbe, 1, {0x3f}},
+{0xbf, 1, {0x1c}},
+{0xc0, 1, {0x1d}},
+{0xc1, 1, {0x00}},
+{0xc2, 1, {0x01}},
+{0xc3, 1, {0x1d}},
+{0xc4, 1, {0x1c}},
+{0xc5, 1, {0x3f}},
+{0xc6, 1, {0x3f}},
+{0xc7, 1, {0x3f}},
+{0xc8, 1, {0x3f}},
+{0xc9, 1, {0x3f}},
+{0xca, 1, {0x3f}},
+{0xcb, 1, {0x3f}},
+{0xcc, 1, {0x3f}},
+{0xcd, 1, {0x3f}},
+{0xce, 1, {0x3f}},
+{0xcf, 1, {0x1c}},
+{0xd0, 1, {0x1c}},
+{0xd1, 1, {0x3f}},
+{0xd2, 1, {0x3f}},
+{0xd3, 1, {0x09}},
+{0xd4, 1, {0x0b}},
+{0xd5, 1, {0x0d}},
+{0xd6, 1, {0x0f}},
+{0xd7, 1, {0x03}},
+{0xdf, 1, {0x00}},
+{0xdc, 1, {0x02}},
+{0xde, 1, {0x08}},
+{0xfe, 1, {0x0e}},
+{0x1, 1, {0x75}},
+{0xfe, 1, {0x0c}},
+{0x8, 1, {0x06}},
+{0x9, 1, {0x06}},
+{0xfe, 1, {0x04}},
+{0x60, 1, {0x00}},
+{0x61, 1, {0x0c}},
+{0x62, 1, {0x12}},
+{0x63, 1, {0x0e}},
+{0x64, 1, {0x07}},
+{0x65, 1, {0x13}},
+{0x66, 1, {0x0f}},
+{0x67, 1, {0x0b}},
+{0x68, 1, {0x16}},
+{0x69, 1, {0x0c}},
+{0x6a, 1, {0x0e}},
+{0x6b, 1, {0x08}},
+{0x6c, 1, {0x0f}},
+{0x6d, 1, {0x0b}},
+{0x6e, 1, {0x04}},
+{0x6f, 1, {0x00}},
+{0x70, 1, {0x00}},
+{0x71, 1, {0x0c}},
+{0x72, 1, {0x12}},
+{0x73, 1, {0x0e}},
+{0x74, 1, {0x07}},
+{0x75, 1, {0x13}},
+{0x76, 1, {0x0f}},
+{0x77, 1, {0x0b}},
+{0x78, 1, {0x16}},
+{0x79, 1, {0x0c}},
+{0x7a, 1, {0x0e}},
+{0x7b, 1, {0x08}},
+{0x7c, 1, {0x0f}},
+{0x7d, 1, {0x0b}},
+{0x7e, 1, {0x04}},
+{0x7f, 1, {0x00}},
+{0xfe, 1, {0x00}},
+{0x58, 1, {0xad}},
+{0x35, 0, {}},
+{0x11, 0, {}},
+		{REGFLAG_DELAY, 120, {}},
+{0x29, 0, {}},
+		{REGFLAG_DELAY, 20, {}},
+
+		{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+
+static struct LCM_setting_table lcm_sleep_out_setting[] = {
+	// Sleep Out
+	{0x11, 0, {0x00}},
+	{REGFLAG_DELAY, 120, {}},
+
+	// Display ON
+	{0x29, 0, {0x00}},
+	{REGFLAG_DELAY, 50, {}},
+
+	{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+
+static struct LCM_setting_table lcm_sleep_in_setting[] = {
+	// Display off sequence
+	
+	{0x28, 0, {0x00}},
+	{REGFLAG_DELAY, 50, {}},
+
+	// Sleep Mode On
+	{0x10, 1, {0x00}},
+	{REGFLAG_DELAY, 150, {}},
+
+	{0x4f, 0, {0x01}},
+	{REGFLAG_DELAY, 150, {}},
+	
+
+	{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+static void push_table(struct LCM_setting_table *table, unsigned int count,
+		unsigned char force_update)
+{
+	unsigned int i;
+
+	for (i = 0; i < count; i++) {
+
+		unsigned cmd;
+		cmd = table[i].cmd;
+
+		switch (cmd) {
+
+		case REGFLAG_DELAY:
+			MDELAY(table[i].count);
+			break;
+
+		case REGFLAG_END_OF_TABLE:
+			break;
+
+		default:
+			dsi_set_cmdq_V2(cmd, table[i].count,
+					table[i].para_list, force_update);
+		}
+	}
+
+}
+
+
+// ---------------------------------------------------------------------------
+//  LCM Driver Implementations
+// ---------------------------------------------------------------------------
+
+static void lcm_set_util_funcs(const LCM_UTIL_FUNCS * util)
+{
+	memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
+}
+
+
+static void lcm_get_params(LCM_PARAMS * params)
+{
+	memset(params, 0, sizeof(LCM_PARAMS));
+
+	params->type = LCM_TYPE_DSI;
+
+	params->width = FRAME_WIDTH;
+	params->height = FRAME_HEIGHT;
+
+	// enable tearing-free
+	params->dbi.te_mode = LCM_DBI_TE_MODE_VSYNC_ONLY;//LCM_DBI_TE_MODE_DISABLED;
+	params->dbi.te_edge_polarity = LCM_POLARITY_RISING;
+
+#if (LCM_DSI_CMD_MODE)
+	params->dsi.mode = CMD_MODE;
+#else
+	params->dsi.mode   = SYNC_PULSE_VDO_MODE;//SYNC_EVENT_VDO_MODE;//BURST_VDO_MODE;////
+#endif
+
+	// DSI
+	/* Command mode setting */
+		params->dsi.LANE_NUM				= LCM_FOUR_LANE;
+	
+	//The following defined the fomat for data coming from LCD engine.
+	params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
+	params->dsi.data_format.trans_seq   = LCM_DSI_TRANS_SEQ_MSB_FIRST;
+	params->dsi.data_format.padding     = LCM_DSI_PADDING_ON_LSB;
+	params->dsi.data_format.format      = LCM_DSI_FORMAT_RGB888;
+	
+	
+	params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
+	
+#if (LCM_DSI_CMD_MODE)
+	params->dsi.intermediat_buffer_num = 0;//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage
+	params->dsi.word_count=FRAME_WIDTH*3;	//DSI CMD mode need set these two bellow params, different to 6577
+#else
+	params->dsi.intermediat_buffer_num = 0;	//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage
+#endif
+
+	// Video mode setting
+	params->dsi.packet_size=256;
+
+	params->dsi.vertical_sync_active				=  2;//2
+	params->dsi.vertical_backporch					= 14;//50;
+	params->dsi.vertical_frontporch					= 16;//50;
+	params->dsi.vertical_active_line				= FRAME_HEIGHT; 
+
+	params->dsi.horizontal_sync_active				= 8;//10
+	params->dsi.horizontal_backporch				= 80;//34; 
+	params->dsi.horizontal_frontporch				= 80;//24;
+	params->dsi.horizontal_active_pixel				= FRAME_WIDTH;
+
+	// Bit rate calculation
+//params->dsi.ssc_disable = 1;
+	//1 Every lane speed
+params->dsi.PLL_CLOCK=210;//195
+
+//ESD
+    params->dsi.esd_check_enable            = 1;
+    params->dsi.customization_esd_check_enable  = 1;
+    params->dsi.lcm_esd_check_table[0].cmd          = 0x0a;
+    params->dsi.lcm_esd_check_table[0].count        = 1;
+    params->dsi.lcm_esd_check_table[0].para_list[0] = 0x9c;
+
+    params->dsi.noncont_clock = 1;
+    params->dsi.noncont_clock_period = 1;
+
+}
+
+static void lcm_init(void)
+{
+
+	SET_RESET_PIN(1);
+	MDELAY(10);
+	SET_RESET_PIN(0);
+	MDELAY(50);
+	SET_RESET_PIN(1);
+	MDELAY(120);
+
+	push_table(lcm_initialization_setting,sizeof(lcm_initialization_setting) /sizeof(struct LCM_setting_table), 1);
+}
+
+static void lcm_suspend(void)
+{
+	unsigned int array[16];
+	array[0] = 0x00FE1500;
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(50);
+	array[0] = 0x00011500;
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(50);
+	array[0] = 0x00280500;
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(50);
+	array[0] = 0x00100500;
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(50);
+	array[0] = 0x014F1500;
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(50);
+}
+
+
+static void lcm_resume(void)
+{   
+	lcm_init();
+}
+
+
+static void lcm_update(unsigned int x, unsigned int y,
+		unsigned int width, unsigned int height)
+{
+	unsigned int x0 = x;
+	unsigned int y0 = y;
+	unsigned int x1 = x0 + width - 1;
+	unsigned int y1 = y0 + height - 1;
+
+	unsigned char x0_MSB = ((x0 >> 8) & 0xFF);
+	unsigned char x0_LSB = (x0 & 0xFF);
+	unsigned char x1_MSB = ((x1 >> 8) & 0xFF);
+	unsigned char x1_LSB = (x1 & 0xFF);
+	unsigned char y0_MSB = ((y0 >> 8) & 0xFF);
+	unsigned char y0_LSB = (y0 & 0xFF);
+	unsigned char y1_MSB = ((y1 >> 8) & 0xFF);
+	unsigned char y1_LSB = (y1 & 0xFF);
+
+	unsigned int data_array[16];
+
+	data_array[0] = 0x00053902;
+	data_array[1] =
+		(x1_MSB << 24) | (x0_LSB << 16) | (x0_MSB << 8) | 0x2a;
+	data_array[2] = (x1_LSB);
+	data_array[3] = 0x00053902;
+	data_array[4] =
+		(y1_MSB << 24) | (y0_LSB << 16) | (y0_MSB << 8) | 0x2b;
+	data_array[5] = (y1_LSB);
+	data_array[6] = 0x002c3909;
+
+	dsi_set_cmdq(data_array, 7, 0);
+
+}
+
+
+static unsigned int lcm_compare_id(void)
+{
+		int array[4];
+		char buffer[5];
+		char id_high=0;
+		char id_low=0;
+		int id1=0;
+		int id2=0;
+
+		SET_RESET_PIN(1);
+		MDELAY(10);
+		SET_RESET_PIN(0);
+		MDELAY(10);
+		SET_RESET_PIN(1);
+		MDELAY(200);
+		array[0]=0x01FE1500;
+		dsi_set_cmdq(array,1, 1);
+
+		array[0] = 0x00013700;
+		dsi_set_cmdq(array, 1, 1);
+		read_reg_v2(0xde, buffer, 1);
+
+		id_high = buffer[0];
+		read_reg_v2(0xdf, buffer, 1);
+		id_low = buffer[0];
+		id1 = (id_high<<8) | id_low;
+
+		return (LCM_RM68200_ID == id1)?1:0;
+
+}
+//no use
+static unsigned int lcm_esd_recover(void)
+{
+    unsigned char para = 0;
+	unsigned int data_array1[16];
+
+  
+
+    SET_RESET_PIN(1);
+    MDELAY(10);
+    SET_RESET_PIN(0);
+    MDELAY(30);
+    SET_RESET_PIN(1);
+    MDELAY(130);
+    #if 0
+	push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
+	MDELAY(10);
+	push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
+    	MDELAY(10);
+    #else
+        lcm_init();
+    #endif
+   
+   data_array1[0]= 0x00320500;
+   dsi_set_cmdq(data_array1, 1, 1);
+   MDELAY(50);
+
+    return 1;
+}
+static unsigned int lcm_esd_check(void)
+{
+    unsigned char buffer[1] ={0};
+    //unsigned int data_array[1];
+   // data_array[0] = 0x00013700;// read id return two byte,version and id 3 byte 
+  // dsi_set_cmdq(&data_array, 1, 1);
+   read_reg_v2(0x0a, buffer, 1);
+   
+#ifndef BUILD_LK
+        if(buffer[0] == 0x9C)
+        {
+            return false;
+        }
+        else
+        {      
+           //lcm_esd_recover();
+            return true;
+        }
+#endif
+}
+
+// ---------------------------------------------------------------------------
+//  Get LCM Driver Hooks
+// ---------------------------------------------------------------------------
+LCM_DRIVER hct_rm68200_dsi_vdo_hd_cpt = 
+{
+	.name			= "hct_rm68200_dsi_vdo_hd_cpt",
+	.set_util_funcs = lcm_set_util_funcs,
+	.get_params     = lcm_get_params,
+	.init           = lcm_init,
+	.suspend        = lcm_suspend,
+	.resume         = lcm_resume,	
+	.compare_id     = lcm_compare_id,	
+    .esd_check   	= lcm_esd_check,	
+    .esd_recover   	= lcm_esd_recover,	
+#if (LCM_DSI_CMD_MODE)
+    .update         = lcm_update,
+#endif	//wqtao
+};
+
diff --git a/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c~ b/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c~
new file mode 100644
index 0000000..533aa10
--- /dev/null
+++ b/drivers/misc/mediatek/lcm/hct_rm68200_dsi_vdo_hd_cpt/hct_rm68200_dsi_vdo_hd_cpt.c~
@@ -0,0 +1,1055 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2008
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+#ifndef BUILD_LK
+#include <linux/string.h>
+#endif
+
+#include "lcm_drv.h"
+
+#ifdef BUILD_LK
+	#include <platform/mt_gpio.h>
+	#include <string.h>
+#elif defined(BUILD_UBOOT)
+	#include <asm/arch/mt_gpio.h>
+#else
+//	#include <mach/mt_gpio.h>
+#endif
+
+// ---------------------------------------------------------------------------
+//  Local Constants
+// ---------------------------------------------------------------------------
+
+#define FRAME_WIDTH  										(720)
+#define FRAME_HEIGHT 										(1280)
+#define LCM_ID                       						(0x1284)
+
+#define REGFLAG_DELAY             							(0XFFFE)
+#define REGFLAG_END_OF_TABLE      							(0xFFFF)	// END OF REGISTERS MARKER
+
+
+#define LCM_DSI_CMD_MODE									0
+
+#ifndef TRUE
+    #define TRUE 1
+#endif
+
+#ifndef FALSE
+    #define FALSE 0
+#endif
+
+// ---------------------------------------------------------------------------
+//  Local Variables
+// ---------------------------------------------------------------------------
+
+static LCM_UTIL_FUNCS lcm_util = {0};
+
+#define SET_RESET_PIN(v)    								(lcm_util.set_reset_pin((v)))
+
+#define UDELAY(n) 											(lcm_util.udelay(n))
+#define MDELAY(n) 											(lcm_util.mdelay(n))
+
+#define LCM_RM68200_ID 		(0x6820)
+
+static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
+
+// ---------------------------------------------------------------------------
+//  Local Functions
+// ---------------------------------------------------------------------------
+
+#define dsi_set_cmdq_V2(cmd, count, ppara, force_update)	lcm_util.dsi_set_cmdq_V2(cmd, count, ppara, force_update)
+#define dsi_set_cmdq(pdata, queue_size, force_update)		lcm_util.dsi_set_cmdq(pdata, queue_size, force_update)
+#define wrtie_cmd(cmd)										lcm_util.dsi_write_cmd(cmd)
+#define write_regs(addr, pdata, byte_nums)					lcm_util.dsi_write_regs(addr, pdata, byte_nums)
+#define read_reg(cmd)											lcm_util.dsi_dcs_read_lcm_reg(cmd)
+#define read_reg_v2(cmd, buffer, buffer_size)				lcm_util.dsi_dcs_read_lcm_reg_v2(cmd, buffer, buffer_size)
+
+ struct LCM_setting_table {
+    unsigned cmd;
+    unsigned char count;
+    unsigned char para_list[64];
+};
+
+
+static struct LCM_setting_table lcm_initialization_setting[] = {
+
+	/*
+Note :
+
+Data ID will depends on the following rule.
+
+count of parameters > 1      => Data ID = 0x39
+count of parameters = 1      => Data ID = 0x15
+count of parameters = 0      => Data ID = 0x05
+
+Struclcm_deep_sleep_mode_in_settingture Format :
+
+{DCS command, count of parameters, {parameter list}}
+{REGFLAG_DELAY, milliseconds of time, {}},
+
+...
+
+Setting ending by predefined flag
+
+{REGFLAG_END_OF_TABLE, 0x00, {}}
+*/
+//RM38200+HSD5.94 YKL CODE
+{0xFE, 1,{0x01}},
+
+{0x24, 1,{0xC0}},
+
+{0x25, 1,{0x73}},
+
+{0x26, 1,{0x00}},
+
+{0x27, 1,{0x0A}},
+
+{0x29, 1,{0x0A}},
+
+{0x2B, 1,{0xE5}},
+
+{0x2F, 1,{0x44}},//44
+
+{0x34, 1,{0x45}},//45  4a
+
+//{0x17, 1,{0x10}},
+
+//{0x18, 1,{0x10}},
+
+//{0x19, 1,{0x10}},
+
+//{0x1A, 1,{0x0D}},
+
+{0x1B, 1,{0x00}},//00
+
+{0x12, 1,{0x08}},
+
+{0x46, 1,{0x5C}},//vcom 58
+
+{0x52, 1,{0xA8}},
+
+{0x53, 1,{0x00}},
+
+{0x54, 1,{0xA8}},
+
+{0x55, 1,{0x00}},
+
+
+{0xFE, 1,{0x03}},
+
+{0x00, 1,{0x05}},
+
+{0x01, 1,{0x14}},
+
+{0x02, 1,{0x01}},
+
+{0x03, 1,{0x00}},
+
+{0x04, 1,{0x00}},
+
+{0x05, 1,{0x00}},
+
+{0x06, 1,{0x00}},
+
+{0x07, 1,{0x00}},
+
+{0x08, 1,{0x00}},
+
+{0x09, 1,{0x00}},
+
+{0x0A, 1,{0x00}},
+
+{0x0B, 1,{0x00}},
+
+{0x0C, 1,{0x00}},
+
+{0x0D, 1,{0x00}},
+
+{0x0E, 1,{0x05}},
+
+{0x0F, 1,{0x06}},
+
+{0x10, 1,{0x07}},
+
+{0x11, 1,{0x08}},
+
+{0x12, 1,{0x00}},
+
+{0x13, 1,{0x40}},
+
+{0x14, 1,{0x00}},
+
+{0x15, 1,{0xC5}},
+
+{0x16, 1,{0x08}},
+
+{0x17, 1,{0x09}},
+
+{0x18, 1,{0x0A}},
+
+{0x19, 1,{0x0B}},
+
+{0x1A, 1,{0x0C}},
+
+{0x1B, 1,{0x00}},
+
+{0x1C, 1,{0x40}},
+
+{0x1D, 1,{0x00}},
+
+{0x1E, 1,{0x85}},
+
+{0x1F, 1,{0x08}},
+
+{0x20, 1,{0x00}},
+
+{0x21, 1,{0x00}},
+
+{0x22, 1,{0x05}},
+
+{0x23, 1,{0x0C}},
+
+{0x24, 1,{0x00}},
+
+{0x25, 1,{0x2D}},
+
+{0x26, 1,{0x00}},
+
+{0x27, 1,{0x10}},
+
+{0x28, 1,{0x00}},
+
+{0x29, 1,{0x2D}},
+
+{0x2A, 1,{0x00}},
+
+{0x2B, 1,{0x00}},
+
+{0x2D, 1,{0x00}},
+
+{0x2F, 1,{0x00}},
+
+{0x30, 1,{0x00}},
+
+{0x31, 1,{0x00}},
+
+{0x32, 1,{0x00}},
+
+{0x33, 1,{0x00}},
+
+{0x34, 1,{0x00}},
+
+{0x35, 1,{0x00}},
+
+{0x36, 1,{0x00}},
+
+{0x37, 1,{0x00}},
+
+{0x38, 1,{0x00}},
+
+{0x39, 1,{0x00}},
+
+{0x3A, 1,{0x00}},
+
+{0x3B, 1,{0x00}},
+
+{0x3D, 1,{0x00}},
+
+{0x3F, 1,{0x00}},
+
+{0x40, 1,{0x00}},
+
+{0x41, 1,{0x00}},
+
+{0x42, 1,{0x00}},
+
+{0x43, 1,{0x00}},
+
+{0x44, 1,{0x00}},
+
+{0x45, 1,{0x00}},
+
+{0x46, 1,{0x00}},
+
+{0x47, 1,{0x00}},
+
+{0x48, 1,{0x00}},
+
+{0x49, 1,{0x00}},
+
+{0x4A, 1,{0x00}},
+
+{0x4B, 1,{0x00}},
+
+{0x4C, 1,{0x00}},
+
+{0x4D, 1,{0x00}},
+
+{0x4E, 1,{0x00}},
+
+{0x4F, 1,{0x00}},
+
+{0x50, 1,{0x00}},
+
+{0x51, 1,{0x00}},
+
+{0x52, 1,{0x00}},
+
+{0x53, 1,{0x00}},
+
+{0x54, 1,{0x00}},
+
+{0x55, 1,{0x00}},
+
+{0x56, 1,{0x00}},
+
+{0x58, 1,{0x00}},
+
+{0x59, 1,{0x00}},
+
+{0x5A, 1,{0x00}},
+
+{0x5B, 1,{0x00}},
+
+{0x5C, 1,{0x00}},
+
+{0x5D, 1,{0x00}},
+
+{0x5E, 1,{0x00}},
+
+{0x5F, 1,{0x00}},
+
+{0x60, 1,{0x00}},
+
+{0x61, 1,{0x00}},
+
+{0x62, 1,{0x00}},
+
+{0x63, 1,{0x00}},
+
+{0x64, 1,{0x00}},
+
+{0x65, 1,{0x00}},
+
+{0x66, 1,{0x00}},
+
+{0x67, 1,{0x00}},
+
+{0x68, 1,{0x00}},
+
+{0x69, 1,{0x00}},
+
+{0x6A, 1,{0x00}},
+
+{0x6B, 1,{0x00}},
+
+{0x6C, 1,{0x00}},
+
+{0x6D, 1,{0xBC}},
+
+{0x6E, 1,{0x20}},
+
+{0x6F, 1,{0x00}},
+
+{0x70, 1,{0x00}},
+
+{0x71, 1,{0x88}},
+
+{0x72, 1,{0x00}},
+
+{0x73, 1,{0x00}},
+
+{0x74, 1,{0x01}},//01
+
+{0x75, 1,{0x01}},//01
+
+{0x76, 1,{0x01}},//01
+
+{0x77, 1,{0x01}},//01
+
+{0x78, 1,{0x01}},//01
+
+{0x79, 1,{0x01}},//01
+
+{0x7A, 1,{0x00}},
+
+{0x7B, 1,{0x00}},
+
+{0x7C, 1,{0x00}},
+
+{0x7D, 1,{0x00}},
+
+{0x7E, 1,{0x0D}},
+
+{0x7F, 1,{0x0F}},
+
+{0x80, 1,{0x09}},
+
+{0x81, 1,{0x0B}},
+
+{0x82, 1,{0x01}},
+
+{0x83, 1,{0x03}},
+
+{0x84, 1,{0x1C}},
+
+{0x85, 1,{0x1C}},
+
+{0x86, 1,{0x1C}},
+
+{0x87, 1,{0x3F}},
+
+{0x88, 1,{0x1D}},
+
+{0x89, 1,{0x1C}},
+
+{0x8A, 1,{0x3F}},
+
+{0x8B, 1,{0x1A}},
+
+{0x8C, 1,{0x1B}},
+
+{0x8D, 1,{0x3F}},
+
+{0x8E, 1,{0x3F}},
+
+{0x8F, 1,{0x3F}},
+
+{0x90, 1,{0x3F}},
+
+{0x91, 1,{0x3F}},
+
+{0x92, 1,{0x3F}},
+
+{0x93, 1,{0x3F}},
+
+{0x94, 1,{0x3F}},
+
+{0x95, 1,{0x3F}},
+
+{0x96, 1,{0x3F}},
+
+{0x97, 1,{0x3F}},
+
+{0x98, 1,{0x3F}},
+
+{0x99, 1,{0x3F}},
+
+{0x9A, 1,{0x3F}},
+
+{0x9B, 1,{0x19}},
+
+{0x9C, 1,{0x18}},
+
+{0x9D, 1,{0x3F}},
+
+{0x9E, 1,{0x1C}},
+
+{0x9F, 1,{0x1D}},
+
+{0xA0, 1,{0x3F}},
+
+{0xA2, 1,{0x1C}},
+
+{0xA3, 1,{0x1C}},
+
+{0xA4, 1,{0x1C}},
+
+{0xA5, 1,{0x02}},
+
+{0xA6, 1,{0x00}},
+
+{0xA7, 1,{0x0A}},
+
+{0xA9, 1,{0x08}},
+
+{0xAA, 1,{0x0E}},
+
+{0xAB, 1,{0x0C}},
+
+{0xAC, 1,{0x0A}},
+
+{0xAD, 1,{0x08}},
+
+{0xAE, 1,{0x0E}},
+
+{0xAF, 1,{0x0C}},
+
+{0xB0, 1,{0x02}},
+
+{0xB1, 1,{0x00}},
+
+{0xB2, 1,{0x1C}},
+
+{0xB3, 1,{0x1C}},
+
+{0xB4, 1,{0x1C}},
+
+{0xB5, 1,{0x3F}},
+
+{0xB6, 1,{0x1C}},
+
+{0xB7, 1,{0x1D}},
+
+{0xB8, 1,{0x3F}},
+
+{0xB9, 1,{0x1A}},
+
+{0xBA, 1,{0x1B}},
+
+{0xBB, 1,{0x3F}},
+
+{0xBC, 1,{0x3F}},
+
+{0xBD, 1,{0x3F}},
+
+{0xBE, 1,{0x3f}},//3F
+
+{0xBF, 1,{0x3F}},
+
+{0xC0, 1,{0x3F}},
+
+{0xC1, 1,{0x3F}},
+
+{0xC2, 1,{0x3F}},
+
+{0xC3, 1,{0x3F}},
+
+{0xC4, 1,{0x3F}},
+
+{0xC5, 1,{0x3F}},
+
+{0xC6, 1,{0x3F}},
+
+{0xC7, 1,{0x3F}},
+
+{0xC8, 1,{0x3F}},
+
+{0xC9, 1,{0x19}},
+
+{0xCA, 1,{0x18}},
+
+{0xCB, 1,{0x3F}},
+
+{0xCC, 1,{0x1D}},
+
+{0xCD, 1,{0x1C}},
+
+{0xCE, 1,{0x3F}},
+
+{0xCF, 1,{0x1C}},
+
+{0xD0, 1,{0x1C}},
+
+{0xD1, 1,{0x1C}},
+
+{0xD2, 1,{0x01}},
+
+{0xD3, 1,{0x03}},
+
+{0xD4, 1,{0x0D}},
+
+{0xD5, 1,{0x0F}},
+
+{0xD6, 1,{0x09}},
+
+{0xD7, 1,{0x0B}},
+
+{0xDC, 1,{0x02}},
+
+{0xDE, 1,{0x0C}},
+
+{0xDF, 1,{0x00}},
+
+
+
+{0xFE, 1,{0x0E}},
+
+{0x01, 1,{0x75}},
+
+{0x1B, 1,{0x00}},
+
+{0x1C, 1,{0x00}},
+
+{0xFE, 1,{0x0C}},
+
+{0x08, 1,{0x03}},
+
+{0x09, 1,{0x03}},
+
+{0xFE, 1,{0x04}},
+
+{0x60, 1,{0x00}},
+
+{0x61, 1,{0x0A}},
+
+{0x62, 1,{0x11}},
+
+{0x63, 1,{0x0E}},
+
+{0x64, 1,{0x07}},
+
+{0x65, 1,{0x12}},
+
+{0x66, 1,{0x0F}},
+
+{0x67, 1,{0x0A}},
+
+{0x68, 1,{0x17}},
+
+{0x69, 1,{0x0D}},
+
+{0x6A, 1,{0x10}},
+
+{0x6B, 1,{0x09}},
+
+{0x6C, 1,{0x10}},
+
+{0x6D, 1,{0x11}},
+
+{0x6E, 1,{0x0A}},
+
+{0x6F, 1,{0x00}},
+
+{0x70, 1,{0x00}},
+
+{0x71, 1,{0x0A}},
+
+{0x72, 1,{0x11}},
+
+{0x73, 1,{0x0E}},
+
+{0x74, 1,{0x07}},
+
+{0x75, 1,{0x12}},
+
+{0x76, 1,{0x0F}},
+
+{0x77, 1,{0x0A}},
+
+{0x78, 1,{0x17}},
+
+{0x79, 1,{0x0D}},
+
+{0x7A, 1,{0x10}},
+
+{0x7B, 1,{0x09}},
+
+{0x7C, 1,{0x10}},
+
+{0x7D, 1,{0x11}},
+
+{0x7E, 1,{0x0A}},
+
+{0x7F, 1,{0x00}},
+
+
+{0xFE, 1,{0x00}},
+
+//{0x58, 1,{0xA9}},  //ce
+
+		{0x35, 1, {0x00}},
+
+		{0x11, 1, {0x00}},
+		{REGFLAG_DELAY, 120, {}},
+		{0x29, 1, {0x00}},
+	
+		{REGFLAG_DELAY, 20, {}},
+		{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+
+static struct LCM_setting_table lcm_sleep_out_setting[] = {
+	// Sleep Out
+	{0x11, 0, {0x00}},
+	{REGFLAG_DELAY, 120, {}},
+
+	// Display ON
+	{0x29, 0, {0x00}},
+	{REGFLAG_DELAY, 50, {}},
+
+	{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+
+static struct LCM_setting_table lcm_sleep_in_setting[] = {
+	// Display off sequence
+	
+	{0x28, 0, {0x00}},
+	{REGFLAG_DELAY, 50, {}},
+
+	// Sleep Mode On
+	{0x10, 1, {0x00}},
+	{REGFLAG_DELAY, 150, {}},
+
+	{0x4f, 0, {0x01}},
+	{REGFLAG_DELAY, 150, {}},
+	
+
+	{REGFLAG_END_OF_TABLE, 0x00, {}}
+};
+
+static void push_table(struct LCM_setting_table *table, unsigned int count,
+		unsigned char force_update)
+{
+	unsigned int i;
+
+	for (i = 0; i < count; i++) {
+
+		unsigned cmd;
+		cmd = table[i].cmd;
+
+		switch (cmd) {
+
+		case REGFLAG_DELAY:
+			MDELAY(table[i].count);
+			break;
+
+		case REGFLAG_END_OF_TABLE:
+			break;
+
+		default:
+			dsi_set_cmdq_V2(cmd, table[i].count,
+					table[i].para_list, force_update);
+		}
+	}
+
+}
+
+
+// ---------------------------------------------------------------------------
+//  LCM Driver Implementations
+// ---------------------------------------------------------------------------
+
+static void lcm_set_util_funcs(const LCM_UTIL_FUNCS * util)
+{
+	memcpy(&lcm_util, util, sizeof(LCM_UTIL_FUNCS));
+}
+
+
+static void lcm_get_params(LCM_PARAMS * params)
+{
+	memset(params, 0, sizeof(LCM_PARAMS));
+
+	params->type = LCM_TYPE_DSI;
+
+	params->width = FRAME_WIDTH;
+	params->height = FRAME_HEIGHT;
+
+	// enable tearing-free
+	params->dbi.te_mode = LCM_DBI_TE_MODE_VSYNC_ONLY;//LCM_DBI_TE_MODE_DISABLED;
+	params->dbi.te_edge_polarity = LCM_POLARITY_RISING;
+
+#if (LCM_DSI_CMD_MODE)
+	params->dsi.mode = CMD_MODE;
+#else
+	params->dsi.mode   = SYNC_PULSE_VDO_MODE;//SYNC_EVENT_VDO_MODE;//BURST_VDO_MODE;////
+#endif
+
+	// DSI
+	/* Command mode setting */
+		params->dsi.LANE_NUM				= LCM_FOUR_LANE;
+	
+	//The following defined the fomat for data coming from LCD engine.
+	params->dsi.data_format.color_order = LCM_COLOR_ORDER_RGB;
+	params->dsi.data_format.trans_seq   = LCM_DSI_TRANS_SEQ_MSB_FIRST;
+	params->dsi.data_format.padding     = LCM_DSI_PADDING_ON_LSB;
+	params->dsi.data_format.format      = LCM_DSI_FORMAT_RGB888;
+	
+	
+	params->dsi.PS=LCM_PACKED_PS_24BIT_RGB888;
+	
+#if (LCM_DSI_CMD_MODE)
+	params->dsi.intermediat_buffer_num = 0;//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage
+	params->dsi.word_count=FRAME_WIDTH*3;	//DSI CMD mode need set these two bellow params, different to 6577
+#else
+	params->dsi.intermediat_buffer_num = 0;	//because DSI/DPI HW design change, this parameters should be 0 when video mode in MT658X; or memory leakage
+#endif
+
+	// Video mode setting
+	params->dsi.packet_size=256;
+
+	params->dsi.vertical_sync_active				=  2;//2
+	params->dsi.vertical_backporch					= 14;//50;
+	params->dsi.vertical_frontporch					= 16;//50;
+	params->dsi.vertical_active_line				= FRAME_HEIGHT; 
+
+	params->dsi.horizontal_sync_active				= 8;//10
+	params->dsi.horizontal_backporch				= 80;//34; 
+	params->dsi.horizontal_frontporch				= 80;//24;
+	params->dsi.horizontal_active_pixel				= FRAME_WIDTH;
+
+	// Bit rate calculation
+//params->dsi.ssc_disable = 1;
+	//1 Every lane speed
+params->dsi.PLL_CLOCK=210;//195
+
+//ESD
+    params->dsi.esd_check_enable            = 1;
+    params->dsi.customization_esd_check_enable  = 1;
+    params->dsi.lcm_esd_check_table[0].cmd          = 0x0a;
+    params->dsi.lcm_esd_check_table[0].count        = 1;
+    params->dsi.lcm_esd_check_table[0].para_list[0] = 0x9c;
+
+    params->dsi.noncont_clock = 1;
+    params->dsi.noncont_clock_period = 1;
+
+}
+
+static void lcm_init(void)
+{
+
+	SET_RESET_PIN(1);
+	MDELAY(10);
+	SET_RESET_PIN(0);
+	MDELAY(50);
+	SET_RESET_PIN(1);
+	MDELAY(120);
+
+	push_table(lcm_initialization_setting,sizeof(lcm_initialization_setting) /sizeof(struct LCM_setting_table), 1);
+}
+
+static void lcm_suspend(void)
+{
+	unsigned int array[16];
+	array[0] = 0x00FE1500;
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(50);
+	array[0] = 0x00011500;
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(50);
+	array[0] = 0x00280500;
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(50);
+	array[0] = 0x00100500;
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(50);
+	array[0] = 0x014F1500;
+	dsi_set_cmdq(array, 1, 1);
+	MDELAY(50);
+}
+
+
+static void lcm_resume(void)
+{   
+	lcm_init();
+}
+
+
+static void lcm_update(unsigned int x, unsigned int y,
+		unsigned int width, unsigned int height)
+{
+	unsigned int x0 = x;
+	unsigned int y0 = y;
+	unsigned int x1 = x0 + width - 1;
+	unsigned int y1 = y0 + height - 1;
+
+	unsigned char x0_MSB = ((x0 >> 8) & 0xFF);
+	unsigned char x0_LSB = (x0 & 0xFF);
+	unsigned char x1_MSB = ((x1 >> 8) & 0xFF);
+	unsigned char x1_LSB = (x1 & 0xFF);
+	unsigned char y0_MSB = ((y0 >> 8) & 0xFF);
+	unsigned char y0_LSB = (y0 & 0xFF);
+	unsigned char y1_MSB = ((y1 >> 8) & 0xFF);
+	unsigned char y1_LSB = (y1 & 0xFF);
+
+	unsigned int data_array[16];
+
+	data_array[0] = 0x00053902;
+	data_array[1] =
+		(x1_MSB << 24) | (x0_LSB << 16) | (x0_MSB << 8) | 0x2a;
+	data_array[2] = (x1_LSB);
+	data_array[3] = 0x00053902;
+	data_array[4] =
+		(y1_MSB << 24) | (y0_LSB << 16) | (y0_MSB << 8) | 0x2b;
+	data_array[5] = (y1_LSB);
+	data_array[6] = 0x002c3909;
+
+	dsi_set_cmdq(data_array, 7, 0);
+
+}
+
+
+static unsigned int lcm_compare_id(void)
+{
+		int array[4];
+		char buffer[5];
+		char id_high=0;
+		char id_low=0;
+		int id1=0;
+		int id2=0;
+
+		SET_RESET_PIN(1);
+		MDELAY(10);
+		SET_RESET_PIN(0);
+		MDELAY(10);
+		SET_RESET_PIN(1);
+		MDELAY(200);
+		array[0]=0x01FE1500;
+		dsi_set_cmdq(array,1, 1);
+
+		array[0] = 0x00013700;
+		dsi_set_cmdq(array, 1, 1);
+		read_reg_v2(0xde, buffer, 1);
+
+		id_high = buffer[0];
+		read_reg_v2(0xdf, buffer, 1);
+		id_low = buffer[0];
+		id1 = (id_high<<8) | id_low;
+
+		#if defined(BUILD_LK)
+		printf("rm68200a %s id1 = 0x%04x, id2 = 0x%04x\n", __func__, id1,id2);
+		#else
+		printk("rm68200a %s id1 = 0x%04x, id2 = 0x%04x\n", __func__, id1,id2);
+		#endif
+		return (LCM_RM68200_ID == id1)?1:0;
+
+}
+//no use
+static unsigned int lcm_esd_recover(void)
+{
+    unsigned char para = 0;
+	unsigned int data_array1[16];
+
+#ifndef BUILD_LK
+    printk("RM68190 lcm_esd_recover enter\n");
+#endif
+    
+
+    SET_RESET_PIN(1);
+    MDELAY(10);
+    SET_RESET_PIN(0);
+    MDELAY(30);
+    SET_RESET_PIN(1);
+    MDELAY(130);
+    #if 0
+	push_table(lcm_initialization_setting, sizeof(lcm_initialization_setting) / sizeof(struct LCM_setting_table), 1);
+	MDELAY(10);
+	push_table(lcm_sleep_out_setting, sizeof(lcm_sleep_out_setting) / sizeof(struct LCM_setting_table), 1);
+    	MDELAY(10);
+    #else
+        lcm_init();
+    #endif
+   
+   data_array1[0]= 0x00320500;
+   dsi_set_cmdq(data_array1, 1, 1);
+   MDELAY(50);
+
+    return 1;
+}
+static unsigned int lcm_esd_check(void)
+{
+    unsigned char buffer[1] ={0};
+    //unsigned int data_array[1];
+   // data_array[0] = 0x00013700;// read id return two byte,version and id 3 byte 
+  // dsi_set_cmdq(&data_array, 1, 1);
+   read_reg_v2(0x0a, buffer, 1);
+   
+#ifndef BUILD_LK
+    printk("RM68190 lcm_esd_check enter %x\n",buffer[0]);
+#endif
+#ifndef BUILD_LK
+        if(buffer[0] == 0x9C)
+        {
+          #ifndef BUILD_LK
+          printk("RM68190 lcm_esd_check false \n");
+          #endif
+
+            return false;
+        }
+        else
+        {      
+           #ifndef BUILD_LK
+          printk("RM68190 lcm_esd_check true \n");
+          #endif
+           //lcm_esd_recover();
+            return true;
+        }
+#endif
+}
+
+// ---------------------------------------------------------------------------
+//  Get LCM Driver Hooks
+// ---------------------------------------------------------------------------
+LCM_DRIVER hct_rm68200_dsi_vdo_hd_cpt = 
+{
+	.name			= "hct_rm68200_dsi_vdo_hd_cpt",
+	.set_util_funcs = lcm_set_util_funcs,
+	.get_params     = lcm_get_params,
+	.init           = lcm_init,
+	.suspend        = lcm_suspend,
+	.resume         = lcm_resume,	
+	.compare_id     = lcm_compare_id,	
+    .esd_check   	= lcm_esd_check,	
+    .esd_recover   	= lcm_esd_recover,	
+#if (LCM_DSI_CMD_MODE)
+    .update         = lcm_update,
+#endif	//wqtao
+};
+
diff --git a/drivers/misc/mediatek/lcm/mt65xx_lcm_list.c b/drivers/misc/mediatek/lcm/mt65xx_lcm_list.c
index f176a15..a887e86 100644
--- a/drivers/misc/mediatek/lcm/mt65xx_lcm_list.c
+++ b/drivers/misc/mediatek/lcm/mt65xx_lcm_list.c
@@ -237,8 +237,28 @@ extern LCM_DRIVER nt35510_dsi_cmd_lcm_drv;
 extern LCM_DRIVER rm69032_dsi_cmd_lcm_drv;
 extern LCM_DRIVER st7789h2_dbi_lcm_drv;
 
+extern LCM_DRIVER hct_rm68200_dsi_vdo_hd_cpt;
+extern LCM_DRIVER hct_otm1282a_dsi_vdo_hd_auo;
+extern LCM_DRIVER hct_ili9881_dsi_vdo_hd_cpt;
+extern LCM_DRIVER hct_hx8394f_dsi_vdo_hd_cmi;
+
 LCM_DRIVER* lcm_driver_list[] =
 {
+#if defined(HCT_OTM1282A_DSI_VDO_HD_AUO)
+	&hct_otm1282a_dsi_vdo_hd_auo,
+#endif
+
+#if defined(HCT_HX8394F_DSI_VDO_HD_CMI)
+	&hct_hx8394f_dsi_vdo_hd_cmi,
+#endif
+
+#if defined(HCT_RM68200_DSI_VDO_HD_CPT)
+	&hct_rm68200_dsi_vdo_hd_cpt,
+#endif
+#if defined(HCT_ILI9881_DSI_VDO_HD_CPT)
+	&hct_ili9881_dsi_vdo_hd_cpt,
+#endif
+
 #if defined(OTM1284A_HD720_DSI_VDO_TM)
 	&otm1284a_hd720_dsi_vdo_tm_lcm_drv,
 #endif
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/Makefile
new file mode 100755
index 0000000..fb6ac1e
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/Makefile
@@ -0,0 +1,67 @@
+
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+ifneq ($(CONFIG_ARCH_MTK_PROJECT),)
+ARCH_MTK_PROJECT := $(shell echo $(CONFIG_ARCH_MTK_PROJECT))
+obj-y   += core/
+obj-y   += dct/dct/
+endif
+
+#obj-y   +=  lcm/
+obj-y   +=  camera/camera/
+obj-$(CONFIG_MTK_VIBRATOR)   +=  vibrator/
+obj-$(CONFIG_MTK_LEDS)   +=  leds/
+#obj-y   +=  keypad/
+#obj-y   +=  sound/
+obj-y   +=  accdet/
+
+ifeq ($(CONFIG_MTK_SENSOR_SUPPORT),y)
+ifeq ($(CONFIG_MTK_CM36652_NEW),y)
+obj-y	+=  alsps/cm36652-new/
+endif
+
+ifeq ($(CONFIG_MTK_MC3410_NEW),y)
+obj-y   +=  accelerometer/mc3410-new/
+endif
+
+ifeq ($(CONFIG_MTK_KXTJ2_1009_AUTO),y)
+obj-y   +=  accelerometer/KXTJ2_1009_auto/
+endif
+ifeq ($(CONFIG_MTK_MC3XXX),y)
+obj-y   +=  accelerometer/mc3xxx/
+endif
+ifeq ($(CONFIG_MTK_KXTJ2_1009_NEW),y)
+obj-y   +=  accelerometer/KXTJ2_1009-new/
+endif
+ifeq ($(CONFIG_MTK_MC3XXX_AUTO),y)
+obj-y   +=  accelerometer/mc3xxx_auto/
+endif
+
+
+ifeq ($(CONFIG_MTK_CM36652_NEW),y)
+obj-y   +=  alsps/cm36652-new/
+endif
+
+ifeq ($(CONFIG_MTK_STK3X1X_NEW),y)
+obj-y   +=  alsps/stk3x1x-new/
+endif
+
+ifeq ($(CONFIG_MTK_STK3X1X_DRIVER),y)
+obj-y	+=  alsps/stk3x1x_driver/
+endif
+
+ifeq ($(CONFIG_MTK_EPL2182_NEW),y)
+obj-y	+=  alsps/epl2182/
+endif
+ifeq ($(CONFIG_MTK_MMC3416X),y)
+obj-y   +=  magnetometer/mmc3416x/
+endif
+
+ifeq ($(CONFIG_MTK_ITG1010_NEW),y)
+obj-y   +=  gyroscope/ITG1010-new/
+endif
+
+ifeq ($(CONFIG_MTK_AKM09911_NEW),y)
+obj-y	+=  magnetometer/akm09911-new/
+endif
+endif
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/Makefile
new file mode 100755
index 0000000..e71effe
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/Makefile
@@ -0,0 +1,3 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y := accdet_custom.o
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom.c
new file mode 100755
index 0000000..5d60e6c
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom.c
@@ -0,0 +1,28 @@
+#include "accdet_custom_def.h"
+#include <accdet_custom.h>
+
+//key press customization: long press time
+struct headset_key_custom headset_key_custom_setting = {
+	2000
+};
+
+struct headset_key_custom* get_headset_key_custom_setting(void)
+{
+	return &headset_key_custom_setting;
+}
+
+#if defined  ACCDET_EINT || defined ACCDET_EINT_IRQ
+static struct headset_mode_settings cust_headset_settings = {
+	0x500, 0x200, 1, 0x1f0, 0x800, 0x800, 0x20
+};
+#else
+//ACCDET only mode register settings
+static struct headset_mode_settings cust_headset_settings = {
+	0x900, 0x600, 1, 0x5f0, 0x3000, 0x3000, 0x400
+};
+#endif
+
+struct headset_mode_settings* get_cust_headset_settings(void)
+{
+	return &cust_headset_settings;
+}
\ No newline at end of file
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom.h
new file mode 100755
index 0000000..9cbde46
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom.h
@@ -0,0 +1,14 @@
+struct headset_mode_settings{
+    int pwm_width;	//pwm frequence
+    int pwm_thresh;	//pwm duty 
+    int fall_delay;	//falling stable time
+    int rise_delay;	//rising stable time
+    int debounce0;	//hook switch or double check debounce
+    int debounce1;	//mic bias debounce
+    int debounce3;	//plug out debounce
+};
+
+//key press customization: long press time
+struct headset_key_custom{
+	int headset_long_press_time;
+};
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom_def.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom_def.h
new file mode 100755
index 0000000..3cecabc
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accdet/accdet_custom_def.h
@@ -0,0 +1,28 @@
+// Headset mode MIC define
+typedef enum
+{
+	ACCDET_MIC_MODE_ACC = 1,
+	ACCDET_MIC_MODE_LOW_COST_WITHOUT_IN_BIAS = 2,
+	ACCDET_MIC_MODE_LOW_COST_WITH_IN_BIAS = 6,
+} ACCDET_MIC_MODE;
+#define ACCDET_MIC_MODE	(1)//6
+
+// use accdet + EINT solution
+#define ACCDET_EINT   //ACC mode
+#ifndef ACCDET_EINT
+#define ACCDET_EINT_IRQ  //DCC mode
+#endif
+//#define ACCDET_PIN_SWAP
+//#define ACCDET_PIN_RECOGNIZATION
+//#define ACCDET_HIGH_VOL_MODE
+#ifdef ACCDET_HIGH_VOL_MODE
+#define ACCDET_MIC_VOL 7     //2.5v
+#else
+#define ACCDET_MIC_VOL 2     //1.9v
+#endif
+
+#define ACCDET_SHORT_PLUGOUT_DEBOUNCE
+#define ACCDET_SHORT_PLUGOUT_DEBOUNCE_CN 20
+//#define FOUR_KEY_HEADSET
+
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile
new file mode 100755
index 0000000..c2ff2dc
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y	:=  kxtj2_1009_cust_acc.o
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile~ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile~
new file mode 100755
index 0000000..c2ff2dc
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/Makefile~
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y	:=  kxtj2_1009_cust_acc.o
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/kxtj2_1009_cust_acc.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/kxtj2_1009_cust_acc.c
new file mode 100755
index 0000000..3ba5b1e
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/accelerometer/KXTJ2_1009-new/kxtj2_1009_cust_acc.c
@@ -0,0 +1,52 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+#include <linux/types.h>
+#include <cust_acc.h>
+//#include <mach/mt6575_pm_ldo.h>
+#include <mach/mt_pm_ldo.h>
+
+/*---------------------------------------------------------------------------*/
+static struct acc_hw cust_acc_hw = {
+    .i2c_num = 2,	//0,
+    .direction = 5,	//1,	//6,		//2,  // 0,  // 1,	/* from 0-7 *  0  5 /
+    .power_id = MT65XX_POWER_NONE,  /*!< LDO is not used */
+    .power_vol= VOL_DEFAULT,        /*!< LDO is not used */
+    .firlen = 0, //old value 16                /*!< don't enable low pass fileter */
+};
+/*---------------------------------------------------------------------------*/
+struct acc_hw* kxtj2_1009_get_cust_acc_hw(void) 
+{
+    return &cust_acc_hw;
+}
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/alsps/epl2182/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/alsps/epl2182/Makefile
new file mode 100644
index 0000000..b9b1943
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/alsps/epl2182/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y	:=  cust_alsps.o
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/alsps/epl2182/cust_alsps.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/alsps/epl2182/cust_alsps.c
new file mode 100644
index 0000000..0032db1
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/alsps/epl2182/cust_alsps.c
@@ -0,0 +1,72 @@
+#include <linux/types.h>
+#include <mach/mt_pm_ldo.h>
+#include <cust_alsps.h>
+#include <mach/upmu_common.h>
+#if defined(CONFIG_T93_PROJ)
+ #if defined(CONFIG_T93E_TS_PROJ)
+  #define PS_HIGH 0X3E8
+  #define PS_LOW  0x320
+ #elif defined(CONFIG_T93Q_LF_PROJ)
+  #define PS_HIGH 0X352
+  #define PS_LOW  0x320
+ #else
+  #define PS_HIGH 0X226
+  #define PS_LOW  0x210
+ #endif
+#endif
+
+#if defined(CONFIG_T89P_YX_PROJ)
+ #define PS_HIGH 2400
+ #define PS_LOW  2300
+#endif
+
+#if defined(CONFIG_T985B_DWS_PROJ)
+ #define PS_HIGH 3000
+ #define PS_LOW  2000
+#endif
+
+#if defined(CONFIG_T99G_DH_PROJ)
+ #define PS_HIGH 1800
+ #define PS_LOW  700
+#endif
+
+#if defined(CONFIG_T99F_LF_PROJ)
+ #define PS_HIGH 3000
+ #define PS_LOW  2000
+#endif
+
+#if defined(CONFIG_T99L_DWS_PROJ)
+ #define PS_HIGH 3000
+ #define PS_LOW  2000
+#endif
+
+#if defined(CONFIG_T991_PROJ)
+ #define PS_HIGH 2800
+ #define PS_LOW  2500
+#endif
+
+#ifndef PS_HIGH
+ #define PS_HIGH 0X1200
+ #define PS_LOW  0x1000
+#endif
+
+static struct alsps_hw cust_alsps_hw = {
+    .i2c_num    = 2,
+	.polling_mode_ps =0,
+	.polling_mode_als =1,
+    .power_id   = MT65XX_POWER_NONE,    /*LDO is not used*/
+    .power_vol  = VOL_DEFAULT,          /*LDO is not used*/
+    //.i2c_addr   = {0x0C, 0x48, 0x78, 0x00},
+
+    /* MTK: modified to support AAL */
+	.als_level	= {5, 8, 16, 32, 60, 90, 140, 180, 400, 900, 4000, 7000, 8000, 10000, 20000},
+	.als_value	= {0, 10, 20, 40, 90, 120, 160, 225, 280, 360, 640, 1280, 2600, 3800, 4700, 10240},
+    .ps_threshold_high = PS_HIGH,
+    .ps_threshold_low = PS_LOW,
+    .is_batch_supported_ps = false,
+    .is_batch_supported_als = false,
+};
+struct alsps_hw *get_cust_alsps_hw(void) {
+    return &cust_alsps_hw;
+}
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/Makefile
new file mode 100755
index 0000000..f7025fc
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for misc devices that really don't fit anywhere else.
+#
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y				+= dummyds.o kd_camera_hw.o
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/dummyds.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/dummyds.c
new file mode 100755
index 0000000..e69de29
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.c
new file mode 100755
index 0000000..a732a4a
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.c
@@ -0,0 +1,1676 @@
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_camera_feature.h"
+
+/******************************************************************************
+ * Debug configuration
+******************************************************************************/
+#define PFX "[kd_camera_hw]"
+#define PK_DBG_NONE(fmt, arg...)    do {} while (0)
+#define PK_DBG_FUNC(fmt, args...)    pr_debug(PFX  fmt, ##args)
+
+#define DEBUG_CAMERA_HW_K
+#ifdef DEBUG_CAMERA_HW_K
+#define PK_DBG PK_DBG_FUNC
+#define PK_ERR(fmt, arg...)   pr_err(fmt, ##arg)
+#define PK_XLOG_INFO(fmt, args...) \
+                do {    \
+                   pr_debug(PFX  fmt, ##args); \
+                } while(0)
+#else
+#define PK_DBG(a,...)
+#define PK_ERR(a,...)
+#define PK_XLOG_INFO(fmt, args...)
+#endif
+
+#ifndef FALSE
+  #define FALSE 0
+#endif
+#ifndef TRUE
+  #define TRUE 1
+#endif
+
+/*
+#ifndef BOOL
+typedef unsigned char BOOL;
+#endif
+*/
+
+/* Mark: need to verify whether ISP_MCLK1_EN is required in here //Jessy @2014/06/04*/
+extern void ISP_MCLK1_EN(BOOL En);
+
+int cntVCAMD =0;
+int cntVCAMA =0;
+int cntVCAMIO =0;
+int cntVCAMAF =0;
+int cntVCAMD_SUB =0;
+
+static DEFINE_SPINLOCK(kdsensor_pw_cnt_lock);
+
+
+bool _hwPowerOn(MT65XX_POWER powerId, int powerVolt, char *mode_name){
+
+	if( hwPowerOn( powerId,  powerVolt, mode_name))
+	{
+	    spin_lock(&kdsensor_pw_cnt_lock);
+		if(powerId==CAMERA_POWER_VCAM_D)
+			cntVCAMD+= 1;
+		else if(powerId==CAMERA_POWER_VCAM_A)
+			cntVCAMA+= 1;
+		else if(powerId==CAMERA_POWER_VCAM_IO)
+			cntVCAMIO+= 1;
+		else if(powerId==CAMERA_POWER_VCAM_AF)
+			cntVCAMAF+= 1;
+		else if(powerId==SUB_CAMERA_POWER_VCAM_D)
+			cntVCAMD_SUB+= 1;
+		spin_unlock(&kdsensor_pw_cnt_lock);
+		return true;
+	}
+	return false;
+}
+
+bool _hwPowerDown(MT65XX_POWER powerId, char *mode_name){
+
+	if( hwPowerDown( powerId, mode_name))
+	{
+	    spin_lock(&kdsensor_pw_cnt_lock);
+		if(powerId==CAMERA_POWER_VCAM_D)
+			cntVCAMD-= 1;
+		else if(powerId==CAMERA_POWER_VCAM_A)
+			cntVCAMA-= 1;
+		else if(powerId==CAMERA_POWER_VCAM_IO)
+			cntVCAMIO-= 1;
+		else if(powerId==CAMERA_POWER_VCAM_AF)
+			cntVCAMAF-= 1;
+		else if(powerId==SUB_CAMERA_POWER_VCAM_D)
+			cntVCAMD_SUB-= 1;
+		spin_unlock(&kdsensor_pw_cnt_lock);
+		return true;
+	}
+	return false;
+}
+
+void checkPowerBeforClose( char* mode_name)
+{
+
+	int i= 0;
+
+	PK_DBG("[checkPowerBeforClose]cntVCAMD:%d, cntVCAMA:%d,cntVCAMIO:%d, cntVCAMAF:%d, cntVCAMD_SUB:%d,\n",
+		cntVCAMD, cntVCAMA,cntVCAMIO,cntVCAMAF,cntVCAMD_SUB);
+
+
+	for(i=0;i<cntVCAMD;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_D,mode_name);
+	for(i=0;i<cntVCAMA;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_A,mode_name);
+	for(i=0;i<cntVCAMIO;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_IO,mode_name);
+	for(i=0;i<cntVCAMAF;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name);
+	for(i=0;i<cntVCAMD_SUB;i++)
+		hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name);
+
+	 cntVCAMD =0;
+	 cntVCAMA =0;
+	 cntVCAMIO =0;
+	 cntVCAMAF =0;
+	 cntVCAMD_SUB =0;
+
+}
+
+
+
+int kdCISModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM SensorIdx, char *currSensorName, BOOL On, char* mode_name)
+{
+
+u32 pinSetIdx = 0;//default main sensor
+bool camera_pdn_reverse = FALSE;
+bool camera_pdn1_reverse = FALSE;
+
+#define IDX_PS_CMRST 0
+#define IDX_PS_CMPDN 4
+#define IDX_PS_MODE 1
+#define IDX_PS_ON   2
+#define IDX_PS_OFF  3
+
+
+u32 pinSet[3][8] = {
+                        //for main sensor
+                     {  CAMERA_CMRST_PIN, // The reset pin of main sensor uses GPIO10 of mt6306, please call mt6306 API to set
+                        CAMERA_CMRST_PIN_M_GPIO,   /* mode */
+                        GPIO_OUT_ONE,              /* ON state */
+                        GPIO_OUT_ZERO,             /* OFF state */
+                        CAMERA_CMPDN_PIN,
+                        CAMERA_CMPDN_PIN_M_GPIO,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                     },
+                     //for sub sensor
+                     {  CAMERA_CMRST1_PIN,
+                        CAMERA_CMRST1_PIN_M_GPIO,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                        CAMERA_CMPDN1_PIN,
+                        CAMERA_CMPDN1_PIN_M_GPIO,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                     },
+                     //for main_2 sensor
+                     {  GPIO_CAMERA_INVALID,
+                        GPIO_CAMERA_INVALID,   /* mode */
+                        GPIO_OUT_ONE,               /* ON state */
+                        GPIO_OUT_ZERO,              /* OFF state */
+                        GPIO_CAMERA_INVALID,
+                        GPIO_CAMERA_INVALID,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                     }
+                   };
+
+
+
+    if (DUAL_CAMERA_MAIN_SENSOR == SensorIdx){
+        pinSetIdx = 0;
+    }
+    else if (DUAL_CAMERA_SUB_SENSOR == SensorIdx) {
+        pinSetIdx = 1;
+    }
+    else if (DUAL_CAMERA_MAIN_2_SENSOR == SensorIdx) {
+        pinSetIdx = 2;
+    }
+
+    if((pinSetIdx == 0) &&
+       currSensorName &&
+       ((0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2235_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2145_MIPI_YUV, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_SP5409_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2155_MIPI_YUV, currSensorName))))
+    {
+        camera_pdn_reverse = TRUE;
+    }
+
+    if((pinSetIdx == 1) &&
+       currSensorName &&
+       ((0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_GC2235_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2145_MIPI_YUV, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC2155_MIPI_YUV, currSensorName)) ||
+        (0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)) ||
+		(0 == strcmp(SENSOR_DRVNAME_GC0310_MIPI_YUV, currSensorName))))
+    {
+        camera_pdn1_reverse = TRUE;
+    }
+
+    if(camera_pdn_reverse)
+    {
+        pinSet[0][IDX_PS_CMPDN+IDX_PS_ON] = GPIO_OUT_ZERO;
+        pinSet[0][IDX_PS_CMPDN+IDX_PS_OFF] = GPIO_OUT_ONE;
+    }
+
+    if(camera_pdn1_reverse)
+    {
+        pinSet[1][IDX_PS_CMPDN+IDX_PS_ON] = GPIO_OUT_ZERO;
+        pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF] = GPIO_OUT_ONE;
+    }
+
+    //power ON
+    if (On) {
+
+            ISP_MCLK1_EN(1);
+
+        PK_DBG("[PowerON]pinSetIdx:%d, currSensorName: %s\n", pinSetIdx, currSensorName);
+#ifdef GPIO_CAMERA_AF_EN_PIN
+		mt_set_gpio_mode(GPIO_CAMERA_AF_EN_PIN,GPIO_MODE_00);
+		mt_set_gpio_dir(GPIO_CAMERA_AF_EN_PIN,GPIO_DIR_OUT);
+		mt_set_gpio_out(GPIO_CAMERA_AF_EN_PIN,GPIO_OUT_ONE);
+#endif
+
+
+        if ((currSensorName && (0 == strcmp(currSensorName,"imx135mipiraw")))||
+            (currSensorName && (0 == strcmp(currSensorName,"imx220mipiraw"))))
+        {
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1000,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(2);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+        }
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName))) \
+                                                                                                      )
+        {
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+#endif
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+        //        goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1600,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(5);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1600,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            mdelay(2);
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+
+            mdelay(20);
+        }
+        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K3M2_MIPI_RAW, currSensorName))){
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                    PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }
+            }
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                    PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }
+            }
+            //VCAM_D
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1100,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name)){
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name)){
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name)){
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                    PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
+            mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                    PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                    PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                    PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+            }
+       }
+        else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_GC2035_YUV, currSensorName)))
+        {
+
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+                mdelay(5); 
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }
+            }    
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }
+            } 
+
+            //VCAM_D        
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
+             //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(5);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                      PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
+            mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                        PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                        PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                        PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+
+            }
+        }
+        else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K4H5YC_MIPI_RAW, currSensorName)))
+        {
+
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+                 
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }
+            }    
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }
+            } 
+
+            //VCAM_D        
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+             //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                      PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
+            mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                        PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                        PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                        PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+
+            }
+        }
+        else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K5E2YA_MIPI_RAW, currSensorName))){
+        #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+        #endif
+     
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }    
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }    
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA LENS] set gpio         failed!! (CMPDN)\n");
+                }    
+            }    
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }    
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }    
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){
+                      PK_DBG("[CAMERA SENSOR] set gpio       failed!! (CMRST)\n");
+                }    
+            }    
+            mdelay(1);
+
+            //VCAM_D        
+#if 1
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            mdelay(1);
+#endif
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            mdelay(1);
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(1);
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            mdelay(1);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+           if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){
+                      PK_DBG("[CAMERA LENS] set gpio mode  failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){
+                      PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){
+                      PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
+                }
+            }
+
+
+            mdelay(2);
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){
+                        PK_DBG("[CAMERA SENSOR] set gpio     mode failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){
+                        PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");
+                }
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){
+                        PK_DBG("[CAMERA SENSOR] set gpio        failed!! (CMRST)\n");
+                }
+
+            }
+        }
+
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName))) \
+			||(currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV9760_MIPI_RAW, currSensorName)))\
+                                                                                                      )
+        {
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+        //        goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+#if 1
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+
+            mdelay(5);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            mdelay(2);
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+
+            mdelay(20);
+        }
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI551_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI545_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5670_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5693_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8865_MIPI_RAW, currSensorName)))   \
+                                                                                                      )
+        {
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+            mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+        //        goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+#if 1
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+
+            mdelay(5);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            mdelay(2);
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+
+            mdelay(20);
+        }
+        else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0310_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP5409_MIPI_RAW, currSensorName)))      ||\ 
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2145_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2235_MIPI_RAW, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName))) \
+                                                                                                  )
+        {
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		#ifdef GPIO_CAMERASUB_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+#if 0
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            mdelay(50);
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+         //       goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+          //      goto _kdCISModulePowerOn_exit_;
+            }
+#if 1
+            mdelay(10);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+           //      goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            mdelay(1);
+
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+#if 1//def VANZO_FEATURE_GC2755MIPIRAW_FOCUS_EN
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+#endif
+            mdelay(50);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+                mdelay(5);
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+            mdelay(5);
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+                mdelay(5);
+                //if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            mdelay(5);
+        }
+        else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0330_YUV,currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0330_YUV,currSensorName))) \
+				                                                                                   )
+        {
+    #ifdef GPIO_CAMERA_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+    #endif
+#if 0
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            mdelay(50);
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+         //       goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+           //      goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+          //      goto _kdCISModulePowerOn_exit_;
+            }
+#if 0
+            mdelay(10);
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+           //      goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            mdelay(1);
+
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1800,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(50);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+                mdelay(5);
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+            mdelay(5);
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+                mdelay(5);
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            mdelay(5);
+        }
+        else
+        {
+		#ifdef GPIO_CAMERA_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERA_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERA_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ONE);
+		#endif
+		
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_D
+            if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K2P8_MIPI_RAW, currSensorName)))
+            {
+                if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            }
+            else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)))
+            {
+                if(pinSetIdx == 0 && TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            }
+            else { // Main VCAMD max 1.5V
+                if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+
+            }
+            if(TRUE != hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+
+
+             //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(5);
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            mdelay(1);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+        }
+    }
+    else {//power OFF
+
+        PK_DBG("[PowerOFF]pinSetIdx:%d\n", pinSetIdx);
+            ISP_MCLK1_EN(0);
+#ifdef GPIO_CAMERA_AF_EN_PIN
+			mt_set_gpio_out(GPIO_CAMERA_AF_EN_PIN,GPIO_OUT_ZERO);
+#endif
+
+
+        if ((currSensorName && (0 == strcmp(currSensorName,"imx135mipiraw")))||
+            (currSensorName && (0 == strcmp(currSensorName,"imx220mipiraw"))))
+
+        {
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            //Set Reset Pin Low
+             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName))) \
+                                                                                                      )
+        {
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName))) \
+			||(currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV9760_MIPI_RAW, currSensorName)))\
+                                                                                                      )
+        {
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+#if 0
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI551_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_HI545_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5670_MIPI_RAW, currSensorName))) ||\
+                 (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8865_MIPI_RAW, currSensorName)))   \
+                                                                                                      )
+        {
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+
+#if 1
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0310_MIPI_YUV, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP2508_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_SP5409_MIPI_RAW, currSensorName)))      ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2755_MIPI_RAW, currSensorName))) ||\
+                  (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName))) \
+                                                                                                  )
+        {
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
+		#ifdef GPIO_CAMERASUB_LDO_EN_PIN
+           mt_set_gpio_mode(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_MODE_00);
+           mt_set_gpio_dir(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_DIR_OUT);
+           mt_set_gpio_out(GPIO_CAMERASUB_LDO_EN_PIN,GPIO_OUT_ZERO);
+		#endif
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            #if 0
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+            #endif
+#if 1
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+    //             goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+#if 1//VANZO_FEATURE_GC2755MIPIRAW_FOCUS_EN
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+
+        } 
+        else if ((currSensorName && (0 == strcmp(SENSOR_DRVNAME_GC2035_YUV, currSensorName))) \
+                                                                                                      )
+        {
+      #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+       else  if ((currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0330_YUV, currSensorName))) || \
+                (currSensorName &&(0 == strcmp(SENSOR_DRVNAME_GC0330_YUV,currSensorName))) \
+				                                                                                )
+        {
+                 #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+            #if 1
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+     //            goto _kdCISModulePowerOn_exit_;
+            }
+            #endif
+#if 0
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+    //             goto _kdCISModulePowerOn_exit_;
+            }
+#endif
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+     //           goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+      //          goto _kdCISModulePowerOn_exit_;
+            }
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+       //         goto _kdCISModulePowerOn_exit_;
+            }
+        }
+             else
+        {
+                 #ifdef GPIO_CAMERA_LDO_EN_PIN
+            mt_set_gpio_out(GPIO_CAMERA_LDO_EN_PIN,GPIO_OUT_ZERO);
+#endif
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                    if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)))
+	    {
+		if(pinSetIdx == 0 && TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D, mode_name))
+		 {
+		   PK_DBG("[CAMERA SENSOR] main imx220 Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
+		   goto _kdCISModulePowerOn_exit_;
+		 }
+	    } else {
+
+	         if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+	         {
+	            PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
+	            goto _kdCISModulePowerOn_exit_;
+	          }
+	   }
+            if(TRUE != hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D),       power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+
+    }
+
+    return 0;
+
+_kdCISModulePowerOn_exit_:
+    return -EIO;
+
+}
+
+EXPORT_SYMBOL(kdCISModulePowerOn);
+
+//!--
+//
+
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.c~ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.c~
new file mode 100755
index 0000000..d590e1b
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.c~
@@ -0,0 +1,1089 @@
+#include <linux/videodev2.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <asm/atomic.h>
+#include <linux/xlog.h>
+
+#include "kd_camera_hw.h"
+
+#include "kd_imgsensor.h"
+#include "kd_imgsensor_define.h"
+#include "kd_camera_feature.h"
+
+/******************************************************************************
+ * Debug configuration
+******************************************************************************/
+#define PFX "[kd_camera_hw]"
+#define PK_DBG_NONE(fmt, arg...)    do {} while (0)
+#define PK_DBG_FUNC(fmt, args...)    pr_debug(PFX  fmt, ##args)
+
+#define DEBUG_CAMERA_HW_K
+#ifdef DEBUG_CAMERA_HW_K
+#define PK_DBG PK_DBG_FUNC
+#define PK_ERR(fmt, arg...)   pr_err(fmt, ##arg)
+#define PK_XLOG_INFO(fmt, args...) \
+                do {    \
+                   pr_debug(PFX  fmt, ##args); \
+                } while(0)
+#else
+#define PK_DBG(a,...)
+#define PK_ERR(a,...)
+#define PK_XLOG_INFO(fmt, args...)
+#endif
+
+/*
+#ifndef BOOL
+typedef unsigned char BOOL;
+#endif
+*/
+
+/* Mark: need to verify whether ISP_MCLK1_EN is required in here //Jessy @2014/06/04*/
+extern void ISP_MCLK1_EN(BOOL En);
+
+int cntVCAMD =0;
+int cntVCAMA =0;
+int cntVCAMIO =0;
+int cntVCAMAF =0;
+int cntVCAMD_SUB =0;
+
+static DEFINE_SPINLOCK(kdsensor_pw_cnt_lock);
+
+
+bool _hwPowerOn(MT65XX_POWER powerId, int powerVolt, char *mode_name){
+
+	if( hwPowerOn( powerId,  powerVolt, mode_name))
+	{
+	    spin_lock(&kdsensor_pw_cnt_lock);
+		if(powerId==CAMERA_POWER_VCAM_D)
+			cntVCAMD+= 1;
+		else if(powerId==CAMERA_POWER_VCAM_A)
+			cntVCAMA+= 1;
+		else if(powerId==CAMERA_POWER_VCAM_IO)
+			cntVCAMIO+= 1;
+		else if(powerId==CAMERA_POWER_VCAM_AF)
+			cntVCAMAF+= 1;
+		else if(powerId==SUB_CAMERA_POWER_VCAM_D)
+			cntVCAMD_SUB+= 1;
+		spin_unlock(&kdsensor_pw_cnt_lock);
+		return true;
+	}
+	return false;
+}
+
+bool _hwPowerDown(MT65XX_POWER powerId, char *mode_name){
+
+	if( hwPowerDown( powerId, mode_name))
+	{
+	    spin_lock(&kdsensor_pw_cnt_lock);
+		if(powerId==CAMERA_POWER_VCAM_D)
+			cntVCAMD-= 1;
+		else if(powerId==CAMERA_POWER_VCAM_A)
+			cntVCAMA-= 1;
+		else if(powerId==CAMERA_POWER_VCAM_IO)
+			cntVCAMIO-= 1;
+		else if(powerId==CAMERA_POWER_VCAM_AF)
+			cntVCAMAF-= 1;
+		else if(powerId==SUB_CAMERA_POWER_VCAM_D)
+			cntVCAMD_SUB-= 1;
+		spin_unlock(&kdsensor_pw_cnt_lock);
+		return true;
+	}
+	return false;
+}
+
+void checkPowerBeforClose( char* mode_name)
+{
+
+	int i= 0;
+
+	PK_DBG("[checkPowerBeforClose]cntVCAMD:%d, cntVCAMA:%d,cntVCAMIO:%d, cntVCAMAF:%d, cntVCAMD_SUB:%d,\n",
+		cntVCAMD, cntVCAMA,cntVCAMIO,cntVCAMAF,cntVCAMD_SUB);
+
+
+	for(i=0;i<cntVCAMD;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_D,mode_name);
+	for(i=0;i<cntVCAMA;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_A,mode_name);
+	for(i=0;i<cntVCAMIO;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_IO,mode_name);
+	for(i=0;i<cntVCAMAF;i++)
+		hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name);
+	for(i=0;i<cntVCAMD_SUB;i++)
+		hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name);
+
+	 cntVCAMD =0;
+	 cntVCAMA =0;
+	 cntVCAMIO =0;
+	 cntVCAMAF =0;
+	 cntVCAMD_SUB =0;
+
+}
+
+
+
+int kdCISModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM SensorIdx, char *currSensorName, BOOL On, char* mode_name)
+{
+
+u32 pinSetIdx = 0;//default main sensor
+
+#define IDX_PS_CMRST 0
+#define IDX_PS_CMPDN 4
+#define IDX_PS_MODE 1
+#define IDX_PS_ON   2
+#define IDX_PS_OFF  3
+
+
+u32 pinSet[3][8] = {
+                        //for main sensor
+                     {  CAMERA_CMRST_PIN, // The reset pin of main sensor uses GPIO10 of mt6306, please call mt6306 API to set
+                        CAMERA_CMRST_PIN_M_GPIO,   /* mode */
+                        GPIO_OUT_ONE,              /* ON state */
+                        GPIO_OUT_ZERO,             /* OFF state */
+                        CAMERA_CMPDN_PIN,
+                        CAMERA_CMPDN_PIN_M_GPIO,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                     },
+                     //for sub sensor
+                     {  CAMERA_CMRST_PIN,
+                        CAMERA_CMRST_PIN_M_GPIO,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                        CAMERA_CMPDN1_PIN,
+                        CAMERA_CMPDN1_PIN_M_GPIO,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                     },
+                     //for main_2 sensor
+                     {  GPIO_CAMERA_INVALID,
+                        GPIO_CAMERA_INVALID,   /* mode */
+                        GPIO_OUT_ONE,               /* ON state */
+                        GPIO_OUT_ZERO,              /* OFF state */
+                        GPIO_CAMERA_INVALID,
+                        GPIO_CAMERA_INVALID,
+                        GPIO_OUT_ONE,
+                        GPIO_OUT_ZERO,
+                     }
+                   };
+
+
+
+    if (DUAL_CAMERA_MAIN_SENSOR == SensorIdx){
+        pinSetIdx = 0;
+    }
+    else if (DUAL_CAMERA_SUB_SENSOR == SensorIdx) {
+        pinSetIdx = 1;
+    }
+    else if (DUAL_CAMERA_MAIN_2_SENSOR == SensorIdx) {
+        pinSetIdx = 2;
+    }
+
+
+    //power ON
+    if (On) {
+
+            ISP_MCLK1_EN(1);
+
+        PK_DBG("[PowerON]pinSetIdx:%d, currSensorName: %s\n", pinSetIdx, currSensorName);
+
+        if ((currSensorName && (0 == strcmp(currSensorName,"imx135mipiraw")))||
+            (currSensorName && (0 == strcmp(currSensorName,"imx220mipiraw"))))
+        {
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1000,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(1);
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(2);
+
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+        }
+        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        {
+           // mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
+           // mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
+           // mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+			mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+			mdelay(2);
+            }
+
+	     //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(2);
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(2);
+
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(5);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(1);
+
+
+           if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])
+		{
+			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
+			mdelay(5);
+	
+			//RST pin
+			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
+			mdelay(5);
+		}
+		mdelay(50);
+
+	#if 1
+	        //disable inactive sensor
+	        //jeff modify for Q26 V1.1   
+	        //cause Main and Sub Cameras use the same RST pin.
+	        //so remove this part's CMRST.
+	       //disable sub
+	        if (GPIO_CAMERA_INVALID != pinSet[1][IDX_PS_CMRST]) {
+	  //          if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
+	  //          if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+	  //          if(mt_set_gpio_out(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
+	            if(mt_set_gpio_out(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
+	        }
+	#endif
+        }
+
+/////////////////////////////////////////////////
+	else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        {
+          //  mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
+          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
+          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+			mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+			mdelay(2);
+            }
+
+	   //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(2);
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(2);
+
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(5);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(2);
+
+
+            //PDN/STBY pin
+		if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])
+		{
+			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
+			mdelay(5);
+	
+			//RST pin
+			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
+			mdelay(5);
+		}
+		mdelay(50);
+
+	#if 1
+	        //disable inactive sensor
+	        //jeff modify for Q26 V1.1   
+	        //cause Main and Sub Cameras use the same RST pin.
+	        //so remove this part's CMRST.
+	       //disable sub
+	        if (GPIO_CAMERA_INVALID != pinSet[1][IDX_PS_CMRST]) {
+	  //          if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
+	  //          if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+	  //          if(mt_set_gpio_out(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
+	            if(mt_set_gpio_out(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
+	        }
+	#endif
+        }
+       else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        {
+          //  mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
+          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
+          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+			mdelay(2);
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+			mdelay(2);
+            }
+
+	   //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(2);
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(2);
+
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(5);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(2);
+
+
+            //PDN/STBY pin
+		if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])
+		{
+			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
+			mdelay(5);
+	
+			//RST pin
+			if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
+			mdelay(5);
+		}
+		mdelay(50);
+
+	#if 1
+	        //disable inactive sensor
+	        //jeff modify for Q26 V1.1   
+	        //cause Main and Sub Cameras use the same RST pin.
+	        //so remove this part's CMRST.
+	       //disable sub
+	        if (GPIO_CAMERA_INVALID != pinSet[1][IDX_PS_CMRST]) {
+	  //          if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_mode(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
+	  //          if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[1][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+	  //          if(mt_set_gpio_out(pinSet[1][IDX_PS_CMRST],pinSet[1][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
+	            if(mt_set_gpio_out(pinSet[1][IDX_PS_CMPDN],pinSet[1][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
+	        }
+	#endif
+        }
+     else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName)) && (pinSetIdx == 1))
+        {
+          //  mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
+          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
+          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
+            //First Power Pin low and Reset Pin Low
+           if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
+	            mdelay(10);
+
+	            //PDN pin
+	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
+	        }
+	//VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+	   //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+            
+
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(10);
+
+
+            #if 1
+	        //enable active sensor
+	        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+	            //PDN pin
+	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");}
+
+				
+	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
+	        //    if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
+	        //    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");}
+	        //    mdelay(1);
+
+	        }
+#endif
+	#if 1
+	        //disable inactive sensor
+	        //jeff modify for Q26 V1.1   
+	        //cause Main and Sub Cameras use the same RST pin.
+	        //so remove this part's CMRST.
+	        if (GPIO_CAMERA_INVALID != pinSet[0][IDX_PS_CMRST]) {
+	  //          if(mt_set_gpio_mode(pinSet[0][IDX_PS_CMRST],pinSet[0][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_mode(pinSet[0][IDX_PS_CMPDN],pinSet[0][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
+	  //          if(mt_set_gpio_dir(pinSet[0][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[0][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+	  //          if(mt_set_gpio_out(pinSet[0][IDX_PS_CMRST],pinSet[0][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
+	            if(mt_set_gpio_out(pinSet[0][IDX_PS_CMPDN],pinSet[0][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
+	        }
+	#endif
+        }
+///////////////////////////////////////////
+
+        else  if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)))
+        {
+           // mt_set_gpio_mode(GPIO_SPI_MOSI_PIN,GPIO_MODE_00);
+          //  mt_set_gpio_dir(GPIO_SPI_MOSI_PIN,GPIO_DIR_OUT);
+           // mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ONE);
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            mdelay(50);
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+
+            if(TRUE != _hwPowerOn(SUB_CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_D), power id = %d \n", SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(10);
+
+            //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+
+            mdelay(50);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+                mdelay(5);
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+
+            }
+            mdelay(5);
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+                mdelay(5);
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            mdelay(5);
+        }
+        else
+        {
+            //First Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_IO, VOL_1800, mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_A, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_A), power id = %d\n", CAMERA_POWER_VCAM_A);
+                goto _kdCISModulePowerOn_exit_;
+            }
+            //VCAM_D
+            if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_S5K2P8_MIPI_RAW, currSensorName)))
+            {
+                if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            }
+            else if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)))
+            {
+                if(pinSetIdx == 0 && TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1200,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+            }
+            else { // Main VCAMD max 1.5V
+                if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_D, VOL_1500,mode_name))
+                {
+                     PK_DBG("[CAMERA SENSOR] Fail to enable digital power\n");
+                     goto _kdCISModulePowerOn_exit_;
+                }
+
+            }
+
+
+             //AF_VCC
+            if(TRUE != _hwPowerOn(CAMERA_POWER_VCAM_AF, VOL_2800,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            mdelay(5);
+
+            //enable active sensor
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            mdelay(1);
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_ON])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+        }
+    }
+    else {//power OFF
+
+        PK_DBG("[PowerOFF]pinSetIdx:%d\n", pinSetIdx);
+            ISP_MCLK1_EN(0);
+
+        if ((currSensorName && (0 == strcmp(currSensorName,"imx135mipiraw")))||
+            (currSensorName && (0 == strcmp(currSensorName,"imx220mipiraw"))))
+
+        {
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            //Set Reset Pin Low
+             if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV5648_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        {
+             //PK_DBG("[OFF]sensorIdx:%d \n",SensorIdx);
+	        printk("[CAMERA SENSOR] jeff imx219 poweroff.\n"); //jeff add 
+	        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
+	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
+	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
+		}
+
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+//////////////////
+	else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV2680_MIPI_RAW, currSensorName)) && (pinSetIdx == 1))
+        {
+          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
+	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
+	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
+		}
+
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+	 else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        {
+          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
+	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
+	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
+		}
+
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_OV8858_MIPI_RAW, currSensorName)) && (pinSetIdx == 0))
+        {
+          //  mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+	        //    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! \n");}
+	            if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! \n");}
+	       //     if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! \n");}
+	            if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! \n");}
+	    	    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! \n");} //high == power down lens module
+	       //     if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! \n");} //low == reset sensor
+		}
+
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+//////////////////
+        else if (currSensorName && (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName)))
+        {
+           // mt_set_gpio_out(GPIO_SPI_MOSI_PIN,GPIO_OUT_ZERO);
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_ON])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+
+            if(TRUE != _hwPowerDown(SUB_CAMERA_POWER_VCAM_D,mode_name))
+            {
+                 PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",SUB_CAMERA_POWER_VCAM_D);
+                 goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+        else
+        {
+            //Set Power Pin low and Reset Pin Low
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
+                if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_MODE])){PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");}
+                if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN],GPIO_DIR_OUT)){PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");}
+                if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMPDN],pinSet[pinSetIdx][IDX_PS_CMPDN+IDX_PS_OFF])){PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");}
+            }
+
+
+            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
+                    if(mt_set_gpio_mode(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_MODE])){PK_DBG("[CAMERA SENSOR] set gpio mode failed!! (CMRST)\n");}
+                    if(mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMRST],GPIO_DIR_OUT)){PK_DBG("[CAMERA SENSOR] set gpio dir failed!! (CMRST)\n");}
+                    if(mt_set_gpio_out(pinSet[pinSetIdx][IDX_PS_CMRST],pinSet[pinSetIdx][IDX_PS_CMRST+IDX_PS_OFF])){PK_DBG("[CAMERA SENSOR] set gpio failed!! (CMRST)\n");}
+            }
+
+            if(currSensorName && (0 == strcmp(SENSOR_DRVNAME_IMX219_MIPI_RAW, currSensorName)))
+	    {
+		if(pinSetIdx == 0 && TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D, mode_name))
+		 {
+		   PK_DBG("[CAMERA SENSOR] main imx220 Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
+		   goto _kdCISModulePowerOn_exit_;
+		 }
+	    } else {
+
+	         if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_D,mode_name))
+	         {
+	            PK_DBG("[CAMERA SENSOR] Fail to OFF core power (VCAM_D), power id = %d \n",CAMERA_POWER_VCAM_D);
+	            goto _kdCISModulePowerOn_exit_;
+	          }
+	   }
+
+            //VCAM_A
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_A,mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF analog power (VCAM_A), power id= (%d) \n", CAMERA_POWER_VCAM_A);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //VCAM_IO
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_IO, mode_name)) {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF digital power (VCAM_IO), power id = %d \n", CAMERA_POWER_VCAM_IO);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+            //AF_VCC
+            if(TRUE != _hwPowerDown(CAMERA_POWER_VCAM_AF,mode_name))
+            {
+                PK_DBG("[CAMERA SENSOR] Fail to OFF AF power (VCAM_AF), power id = %d \n", CAMERA_POWER_VCAM_AF);
+                //return -EIO;
+                goto _kdCISModulePowerOn_exit_;
+            }
+
+        }
+
+    }
+
+    return 0;
+
+_kdCISModulePowerOn_exit_:
+    return -EIO;
+
+}
+
+EXPORT_SYMBOL(kdCISModulePowerOn);
+
+//!--
+//
+
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.h
new file mode 100755
index 0000000..d37afdf
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/camera/camera/kd_camera_hw.h
@@ -0,0 +1,51 @@
+#ifndef _KD_CAMERA_HW_H_
+#define _KD_CAMERA_HW_H_
+
+#include <mach/mt_gpio.h>
+
+#ifdef MTK_MT6306_SUPPORT
+#include <mach/dcl_sim_gpio.h>
+#endif
+
+#include <mach/mt_pm_ldo.h>
+#include "pmic_drv.h"
+
+//
+//Analog
+#define CAMERA_POWER_VCAM_A         PMIC_APP_MAIN_CAMERA_POWER_A
+//Digital
+#define CAMERA_POWER_VCAM_D         PMIC_APP_MAIN_CAMERA_POWER_D
+//AF
+#define CAMERA_POWER_VCAM_AF        PMIC_APP_MAIN_CAMERA_POWER_AF
+//digital io
+#define CAMERA_POWER_VCAM_IO        PMIC_APP_MAIN_CAMERA_POWER_IO
+//Digital for Sub
+#define SUB_CAMERA_POWER_VCAM_D     PMIC_APP_SUB_CAMERA_POWER_D
+
+
+//FIXME, should defined in DCT tool
+
+//Main sensor
+#define CAMERA_CMRST_PIN            GPIO_CAMERA_CMRST_PIN
+#define CAMERA_CMRST_PIN_M_GPIO     GPIO_CAMERA_CMRST_PIN_M_GPIO
+
+#define CAMERA_CMPDN_PIN            GPIO_CAMERA_CMPDN_PIN
+#define CAMERA_CMPDN_PIN_M_GPIO     GPIO_CAMERA_CMPDN_PIN_M_GPIO
+
+//FRONT sensor
+#define CAMERA_CMRST1_PIN           GPIO_CAMERA_CMRST1_PIN
+#define CAMERA_CMRST1_PIN_M_GPIO    GPIO_CAMERA_CMRST1_PIN_M_GPIO
+
+#define CAMERA_CMPDN1_PIN           GPIO_CAMERA_CMPDN1_PIN
+#define CAMERA_CMPDN1_PIN_M_GPIO    GPIO_CAMERA_CMPDN1_PIN_M_GPIO
+
+// Define I2C Bus Num
+#define SUPPORT_I2C_BUS_NUM1        0
+/* Vanzo:yucheng on: Mon, 06 Apr 2015 21:46:53 +0800
+ * Porting from wuzhiyong
+#define SUPPORT_I2C_BUS_NUM2        0
+ */
+#define SUPPORT_I2C_BUS_NUM2        0
+// End of Vanzo: yucheng
+
+#endif
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/codegen.dws b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/codegen.dws
new file mode 100755
index 0000000000000000000000000000000000000000..14d87b8fc4640ebfbef1cb101b038e33ffc95df4
GIT binary patch
literal 29749
zcmeHQ-I}Ag5q19mlg)oF=OXv9+dZ?BOANT1v@wpcJv&#t#y(-*AkUN4DRD$0gu!-q
z?@R`LAF5KRbdFRM&<5<zll|!jv)SzTX8XC>^258Ymv8gge~gauzk!0WDB2A+Y_OqE
ze7wrpp`0l)%=A<Gt{$v&)AI@Gbku#oh8;HOe=*y`E-R|1^kaTJq*a=257jQ)`YVDn
z0ipL5`cV3Q*a<?oUB}hFd=V~k|CL<nH;1a+Jw^GhO1Iapj;NGanXgORtKg@1K}aW#
z?t={*Y><C8n?x>(<0L%{?kSG%lLk)k(T_q&-K9nx<>@}E;(V8!4PGA+?F5EI@d>5v
zRrDi9pQIloiojU4S!4iP2Rx(`NB40KutEQW*<{DW2a{g|#}5bhNz9pj)FDw|cRB6$
ziaCfD=W?28eUixNr(UZ)j3y6)jGBSL2?b93kx5ILNuc7m30roI%M-+fF`=&8j2mRA
zh&@no9I+r-*r(-K?4KG(J#LKt+}OY)FLlj<z9!06`*CgJxG_>=QV(HkEXH`O1TK9i
zY#WIwCd`ONPBCd>LG6;5@EGOTAvs}pBXns@x(NN23A-Dc|JRscT|6G;nrGTry|z)O
zFQi|7Z4CC0_dJOXbN`YLcfx2HveO3Xmp08}ERCk54ru71qG)#U=BfF3uRkpWJ}eNs
zn?LP{f^!6S4sP*lsvoJLr0bLCXd1+}My${hU;`!!{cNjUyH9f2T|BSKBnpJe0RZS3
z$>LWdTfFAV4B6|g?Cv#JX2`~^jETa`yCxf#V^{V}WWy`tYC;l6747XK%(nhygu4k?
zlyT2pIYL189clCdFm#ll6l1$WYiJ{$j8xdLqqwCUqy3>e?!QUyLMM%%7}p^x_5+r5
z&~@?X4n1^)8j^sf5A`#2W_8QZ>IgALhG<CHU0sk4?tS?{JEnrdHYD1xQ+IR^Wm+w6
zzI8`RO3>-zZhhlE;lQnLU<_@*?&A`>SDo`m9}6)lX{U5oN!-FerQ4OHgu6Xm93Cq3
z#O1U)mVsOWXdf^L*iT7PEx$4iIenD7tcpV{Ef_tNyB;=DP-;KwZl8gwjGqE4YT<C4
zFTsIA>Fa2_xPmLs%3_F&6YrCnL=$((iZbgXBZv<GJEIB70y_)GhzwLP4Q;@p4{^10
zQTx{+dZ-ThU^);iBrhZz&Ie6`2<i5PWJ&KX(xB9RGT2F2t1aP$F}W%ENYqE_PQ31-
zIqyq9t|uh*8cEq&RNe6C%tbRu$4@9BDs3YbY}9L2ghyvCn!%?fLv+`#E=Y%|0rFho
zinI^L!44aBdm0mO4spjQ3}ZH6`Nf@WA9iK6*#<umVaynO?c?*H?H+G#;-p$-QEC1N
z-3?_SgFryt9wPjs86;P&r(IG#?TZh=B-AJxos5*)k2WnkY{8_^DA2)(LLCxC`&mo7
z?yv>_2-YYeoy?k%y5?)M#l>bYk|8$Q$bdHWS{2b@3q}&I61p=LQMC(fV1^C4I|Q=*
zzbpKK6?hkeGp8gTaUfBAX|1;ASnDL7u3{hLOJWmWOUw>!6iVB&HEd!JRP3X~+@Vtf
zL53*_8w<yU2-rtSOiEyU>e!eo3g$`qT=N#-30rbN=Lq9WImO#%%9osj%mK#0Mx?1>
zXJIa}P3i37+^*QyAhwTr_5({s5>&}HVsl31*zXgYb5PTD>Zd$!Oj73OX4@#CdDCCV
z8ajL_q3f+dY_t%z9z%TCw61*wqk(jq*aH>EYCNs8pV9#;#eF8-uQT&JW@T<t#GU6#
z1c1~8T1OuWeQm2<2gs7UChr@KAeuny*OGM}3X%v?6KI`lpfB56hE~@5pc4a0;7fw`
zk-;B*O{}cuOh)lB*@h3wr-aS9KyseGlu4hNH~K>{8N!w^3YTr*=`vyKXjuJIi3#Sx
z4Kt%I^RrWJ)nX4+9H(=SHgW$9u=RYYWAW6vj#fbG{?GxW$3aJIv<*0Z8#Z0siP1dn
zzaR5}m4MGc7Jk5r*=Z8)aoQkRXk%MT@e5QOLtI}1gFZ4`gVuTgwl&7bWP8G9BpUfS
z$3)M)PK}lr$`d#@k!Uo6^yMG=Z^0%mCHW{r*yQ9a;ls_h(U*8yzA+8C2fQ&~wK|pi
zD6jC{q+RhL-QVyM1Sq&1O4xJ}d!T{|8<*irV8}2fVbdi5>%wy@w!2Rs9h1tuS61a`
z9#(>kgp_(goHYH|*0M!t-U%G_C>A7rgs`Jf+E!C{2}iC_uZ+4T>LdJ(ak5z$=Xepp
z&P=>r1qB;%eF+{E`q@^ycF*Y(^U2L5{J^bjpMq`DXxS#JW9ug0EQr%1mM=A?4EKRe
zI{@pJjXoc9s0|AGOxQLOQ%sl<jhtfA#Ddx-F~PCLjpHGKA;+DPu<7zU)3C1?WjS8-
z?7q)TWMAIMG;liBY??{ip`%dR)@=4$qo_4yh4m0OS3&VNO$0D;RuVQ{bnx*0@9PB5
zFuhXn4Ac1F`N2e>XrmqsUS1~g!hGvG8M~W^s%40QY;HHzOyhSG8ITyzQD~zs#=3HU
z2w0}j7cDrvPhL-T_P%O}?s}@h`^BIGye_bza4OWrSXbQuF3)9!hS&NSs#aFahw@LO
zYdyrI7X;m7O3KZ(Ytn2!OMq$MgrwJ@b<Lu6&Dh#e^J*y5HN4g}yw=ZCoy~L&uXPQt
z_48DNnXW0QYj~}nr+TqW@9wMnYZDMFz>3DN>h0@My?Z^Xudk(I@EAa*1l!)eG8g*Q
zIVugu?1Lm6`$?mv_yj7B(ek;miAN5$IX~Lj))IX~F##U@hzse4aX1WKxdj_gx6GS!
zB?jBX)e^ccee;G7`iM1FVjO+@u>E<`e@IT)-3U!FxjZKLbrrdxJiCW_%8JGNSx39m
zHiY@VX8W1h9;3~sTEOCtT4XfdR^P_3whDevt^VmSu`~J44Cz6t%@~M6i7DA1yb{|F
z>n_OiK*pg}dc5(C=|gdhAFExoO*b+G+$8E5HkspAbkUe%GR35o6jMUnnh-c`%a>Cn
zt~@7QeR6H>9n-jM2jM%+4<Gl1pkNN%E`#}8y>X?$!`ju+eC@BWd-i+YBbS8|*XsIP
zC12<+yewXmw@q?Mmb#i^GQ~va!-bcS;q=j;cZR+7RG!=W)0xRju5!YzBk<hmGX-`E
z?4^HUf6+OJ&pKI>WDk-z`t18lW5LhKoT5#Zbb9f3`7Y1Qk4WLCx90=>_Rf|@|CJdL
z-#zsWZ*>ohzUz>;Mla8I-*>ukPYxflrfQ18ln2vcaQ0O23)7pMpPIpGaCYBwDM1$D
zbh?WYaeUwR2fXk2&pt=~DEeT(o!_0E-yCOqx%ZytJM-Tq4##~u!+XhxroEW`-58=I
zuGUFX?bqfGy?J52tdfu02<Q9wSRRVJiXTZ`uelar7;(@TFDZ>H?vr4$xZm|y<mn72
z@l&xm=4n!V*ou8yY||?hLJI^M7W%lm5)adKSg!G0N^7<gsEzcEad?rKBHis{zZnim
zU2s6)*t&7r*A4&jh#7i>9j7?_-cz!{e^^?`dBq*??an*@Jk#!8$}?QMhk=YF%F{yx
z+-A=r+WRyvPU-%m^t4VeKwL-hp{P5(6B~T-ywxC9=5*8=ii-y9n7r2oKXl2-(SwvV
z*kPe=4&9{dL$e5A05DFshjicAIfs4r@TlC$5f|Haw$B@XqOT(JvjHx9u|oE=&*ua(
zYixI@pg0&##s<WhFPu9k(hh*6jrlia%e(ix{Fv|L-<Fwa+sF9kx4a`X<ONDmOohWA
zKRlO5*|w^G?c08>ERtg%zhYG$SAG|MwG*d{?LRE!7#&onGRy6UA-u)Of}Sx5V|>VB
zKU2LF3$FDi6Rs*+%OZRp#3vBawY*G^cz0vEmY<dzvqbHK1UfzJ!ZF30`*F0Z?28Jg
zB$2~Z55H6wx@@&Kz}-B$6s*r*cA*Jw5@ZQyYa&@4%+^Hy`BfiTpWW?Y^U8i`vEe;z
zobk$Ga1WclznQ*1!aln@MZ7VCajL10Qlyuplld09`C~TPn%7XwZ49{2zg^5F9?BJ&
zihKxp&ttiU)ZQjFdp(!2d<<|&)p1<Z6L_1*=>u&1p~PO_WorMwVwrBsV&8GQt0Cu!
zDDo)TUkQEQy%#9+?E5U#eJm%wXjAUWUcPs8yRX)9uZwvb3VWnH?2A=e1^0-X*;1|^
xd=lJ&T-K|6w~}{=-qbZN+4FBF(;NA)_VSUyQHX2t<A=)pU10X>Mw;c==68W2ze@lB

literal 0
HcmV?d00001

diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/Makefile
new file mode 100755
index 0000000..d5d4d0a
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/Makefile
@@ -0,0 +1,3 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y := board.o
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/board-custom.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/board-custom.h
new file mode 100755
index 0000000..088a2b5
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/board-custom.h
@@ -0,0 +1,121 @@
+#ifndef __ARCH_ARM_MACH_MT6575_CUSTOM_BOARD_H
+#define __ARCH_ARM_MACH_MT6575_CUSTOM_BOARD_H
+
+#include <generated/autoconf.h>
+
+/*=======================================================================*/
+/* MT6575 SD                                                             */
+/*=======================================================================*/
+#ifdef CONFIG_FPGA_EARLY_PORTING
+#define CFG_DEV_MSDC0
+#else
+#ifdef CONFIG_MTK_EMMC_SUPPORT
+#define CFG_DEV_MSDC0
+#endif
+#define CFG_DEV_MSDC1
+#endif
+//#define CFG_DEV_MSDC1
+//#define CFG_DEV_MSDC2
+//#define CFG_DEV_MSDC3
+//#define CFG_DEV_MSDC4
+#if defined(CONFIG_MTK_COMBO) || defined(CONFIG_MTK_COMBO_MODULE)
+/*
+SDIO slot index number used by connectivity combo chip: may be MSDC0~4
+*/
+#define CONFIG_MTK_COMBO_SDIO_SLOT  (3)
+#else
+#undef CONFIG_MTK_COMBO_SDIO_SLOT
+#endif
+
+#if 0 /* FIXME. */
+/*=======================================================================*/
+/* MT6575 UART                                                           */
+/*=======================================================================*/
+#define CFG_DEV_UART1
+#define CFG_DEV_UART2
+#define CFG_DEV_UART3
+#define CFG_DEV_UART4
+
+#define CFG_UART_PORTS          (4)
+
+/*=======================================================================*/
+/* MT6575 I2C                                                            */
+/*=======================================================================*/
+#define CFG_DEV_I2C
+//#define CFG_I2C_HIGH_SPEED_MODE
+//#define CFG_I2C_DMA_MODE
+
+/*=======================================================================*/
+/* MT6575 ADB                                                            */
+/*=======================================================================*/
+#define ADB_SERIAL "E1K"
+
+#endif
+
+/*=======================================================================*/
+/* MT6575 NAND FLASH                                                     */
+/*=======================================================================*/
+#if 0
+#define RAMDOM_READ 1<<0
+#define CACHE_READ  1<<1
+/*******************************************************************************
+ * NFI & ECC Configuration 
+ *******************************************************************************/
+typedef struct
+{
+    u16 id;			//deviceid+menuid
+    u8  addr_cycle;
+    u8  iowidth;
+    u16 totalsize;	
+    u16 blocksize;
+    u16 pagesize;
+    u32 timmingsetting;
+    char devciename[14];
+    u32 advancedmode;   //
+}flashdev_info,*pflashdev_info;
+
+static const flashdev_info g_FlashTable[]={
+    //micro
+    {0xAA2C,  5,  8,  256,	128,  2048,  0x01113,  "MT29F2G08ABD",	0},
+    {0xB12C,  4,  16, 128,	128,  2048,  0x01113,  "MT29F1G16ABC",	0},
+    {0xBA2C,  5,  16, 256,	128,  2048,  0x01113,  "MT29F2G16ABD",	0}, 
+    {0xAC2C,  5,  8,  512,	128,  2048,  0x01113,  "MT29F4G08ABC",	0},
+    {0xBC2C,  5,  16, 512,	128,  2048,  0x44333,  "MT29F4G16ABD",	0},
+    //samsung 
+    {0xBAEC,  5,  16, 256,	128,  2048,  0x01123,  "K522H1GACE",	0},
+    {0xBCEC,  5,  16, 512,	128,  2048,  0x01123,  "K524G2GACB",	0},
+    {0xDAEC,  5,  8,  256,	128,  2048,  0x33222,  "K9F2G08U0A",	RAMDOM_READ},
+    {0xF1EC,  4,  8,  128,	128,  2048,  0x01123,  "K9F1G08U0A",	RAMDOM_READ},
+    {0xAAEC,  5,  8,  256,	128,  2048,  0x01123,  "K9F2G08R0A",	0},
+    //hynix
+    {0xD3AD,  5,  8,  1024, 256,  2048,  0x44333,  "HY27UT088G2A",	0},
+    {0xA1AD,  4,  8,  128,	128,  2048,  0x01123,  "H8BCSOPJOMCP",	0},
+    {0xBCAD,  5,  16, 512,	128,  2048,  0x01123,  "H8BCSOUNOMCR",	0},
+    {0xBAAD,  5,  16, 256,	128,  2048,  0x01123,  "H8BCSOSNOMCR",	0},
+    //toshiba
+    {0x9598,  5,  16, 816,	128,  2048,  0x00113,  "TY9C000000CMG", 0},
+    {0x9498,  5,  16, 375,	128,  2048,  0x00113,  "TY9C000000CMG", 0},
+    {0xC198,  4,  16, 128,	128,  2048,  0x44333,  "TC58NWGOS8C",	0},
+    {0xBA98,  5,  16, 256,	128,  2048,  0x02113,  "TC58NYG1S8C",	0},
+    //st-micro
+    {0xBA20,  5,  16, 256,	128,  2048,  0x01123,  "ND02CGR4B2DI6", 0},
+
+    // elpida
+    {0xBC20,  5,  16, 512,  128,  2048,  0x01123,  "04GR4B2DDI6",   0},
+    {0x0000,  0,  0,  0,	0,	  0,	 0, 	   "xxxxxxxxxxxxx", 0}
+};
+#endif
+	
+	
+#define NFI_DEFAULT_ACCESS_TIMING        (0x44333)
+
+//uboot only support 1 cs
+#define NFI_CS_NUM                  (2)
+#define NFI_DEFAULT_CS				(0)
+
+#define USE_AHB_MODE                	(1)
+
+#define PLATFORM_EVB                (1)
+
+#endif /* __ARCH_ARM_MACH_MT6575_CUSTOM_BOARD_H */
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/board.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/board.c
new file mode 100755
index 0000000..a25e72a
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/board.c
@@ -0,0 +1,1217 @@
+/* system header files */
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/mutex.h>
+#include <linux/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/mtd/nand.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+//#include <asm/mach-types.h>
+//#include <asm/mach/arch.h>
+//#include <asm/mach/irq.h>
+//#include <asm/mach/map.h>
+//#include <asm/mach/time.h>
+//#include <asm/setup.h>
+
+#include <mach/system.h>
+#include <mach/board.h>
+#include <mach/hardware.h>
+#include <mach/mt_gpio.h>
+#include <mach/mt_bt.h>
+#include <mach/eint.h>
+#include <mach/mtk_rtc.h>
+#include <mach/mt_typedefs.h>
+// Fix-me: marked for early porting
+#include <cust_gpio_usage.h>
+#include <cust_eint.h>
+#if defined(CONFIG_MTK_COMBO) || defined(CONFIG_MTK_COMBO_MODULE)
+#include <mach/mtk_wcn_cmb_stub.h>
+#if 0
+static void combo_bt_pcm_pin_on(void);
+static void combo_bt_pcm_pin_off(void);
+static void combo_fm_i2s_pin_on(void);
+static void combo_fm_i2s_pin_off(void);
+#endif
+#endif
+/* temp solution to avoid compile error */
+#define CUST_EINT_WIFI_NUM          0
+#define CUST_EINT_WIFI_SENSITIVE    0
+#define CUST_EINT_WIFI_DEBOUNCE_CN  0
+#define CUST_EINT_WIFI_DEBOUNCE_EN  0
+#define CUST_EINT_WIFI_POLARITY     0
+#define GPIO_WIFI_EINT_PIN          0
+#define GPIO_WIFI_EINT_PIN_M_EINT   0
+#define GPIO_WIFI_EINT_PIN_M_GPIO   0
+
+#if defined(CONFIG_MTK_COMBO) || defined(CONFIG_MTK_COMBO_MODULE)
+    /* combo chip */
+    #if defined(MTK_MT6620)  
+void mt6620_power_on(void);
+void mt6620_power_off(void);
+void mt6620_print_pin_configure(void);
+    #endif
+#endif
+#if defined(CONFIG_MTK_COMBO_SDIO_SLOT)
+#if 0
+static sdio_irq_handler_t combo_sdio_eirq_handler = NULL;
+static void *combo_sdio_eirq_data = NULL;
+#endif
+static void *combo_sdio_pm_data = NULL;
+static pm_callback_t combo_sdio_pm_cb = NULL;
+//static pm_message_t mt_wifi_pm_state = { .event = PM_EVENT_HIBERNATE };
+//static int mt_wifi_pm_late_cb = 0;
+
+	#if (CONFIG_MTK_COMBO_SDIO_SLOT == 0)
+		const static u32 combo_sdio_eint_pin = GPIO_WIFI_EINT_PIN;
+		const static u32 combo_sdio_eint_num = CUST_EINT_WIFI_NUM;
+		const static u32 combo_sdio_eint_m_eint = GPIO_WIFI_EINT_PIN_M_EINT;
+		const static u32 combo_sdio_eint_m_gpio = GPIO_WIFI_EINT_PIN_M_GPIO;
+		static unsigned char combo_port_pwr_map[4] = {0x0, 0xFF, 0xFF, 0xFF};
+		/*
+		index: port number of combo chip (1:SDIO1, 2:SDIO2, no SDIO0)
+		value: slot power status of  (0:off, 1:on, 0xFF:invalid)
+		*/
+	#elif (CONFIG_MTK_COMBO_SDIO_SLOT == 1)
+		const static u32 combo_sdio_eint_pin = GPIO_WIFI_EINT_PIN;
+		const static u32 combo_sdio_eint_num = CUST_EINT_WIFI_NUM;
+		const static u32 combo_sdio_eint_m_eint = GPIO_WIFI_EINT_PIN_M_EINT;
+		const static u32 combo_sdio_eint_m_gpio = GPIO_WIFI_EINT_PIN_M_GPIO;
+		static unsigned char combo_port_pwr_map[4] = {0xFF, 0x0, 0xFF, 0xFF};
+		/*
+		index: port number of combo chip (1:SDIO1, 2:SDIO2, no SDIO0)
+		value: slot power status of  (0:off, 1:on, 0xFF:invalid)
+		*/
+    #elif (CONFIG_MTK_COMBO_SDIO_SLOT == 2)
+		const static u32 combo_sdio_eint_pin = GPIO_WIFI_EINT_PIN;
+		const static u32 combo_sdio_eint_num = CUST_EINT_WIFI_NUM;
+		const static u32 combo_sdio_eint_m_eint = GPIO_WIFI_EINT_PIN_M_EINT;
+		const static u32 combo_sdio_eint_m_gpio = GPIO_WIFI_EINT_PIN_M_GPIO;
+		#if 0
+		static unsigned char combo_port_pwr_map[4] = {0xFF, 0xFF, 0x0, 0xFF};
+		#endif
+		/*
+		index: port number of combo chip (1:SDIO1, 2:SDIO2, no SDIO0)
+		value: slot power status of  (0:off, 1:on, 0xFF:invalid)
+		*/
+
+    #elif (CONFIG_MTK_COMBO_SDIO_SLOT == 3)
+		/* jump ALL_INT_B to GPIO_WIFI_EINT_PIN(EINT4) instead of using GPIO_COMBO_ALL_EINT_PIN */
+		const static u32 combo_sdio_eint_pin = GPIO_WIFI_EINT_PIN;
+		const static u32 combo_sdio_eint_num = CUST_EINT_WIFI_NUM; /* CUST_EINT_COMBO_ALL_NUM */
+		const static u32 combo_sdio_eint_m_eint = GPIO_WIFI_EINT_PIN_M_EINT;
+		const static u32 combo_sdio_eint_m_gpio = GPIO_WIFI_EINT_PIN_M_GPIO;
+		static unsigned char combo_port_pwr_map[4] = {0xFF, 0xFF, 0xFF, 0x0};
+		/*
+		index: port number of combo chip (1:SDIO1, 2:SDIO2, no SDIO0)
+		value: slot power status of  (0:off, 1:on, 0xFF:invalid)
+		*/
+
+    #else
+    #error "unsupported CONFIG_MTK_COMBO_SDIO_SLOT" CONFIG_MTK_COMBO_SDIO_SLOT
+    #endif
+
+#else
+#endif
+/*=======================================================================*/
+/* Board Specific Devices Power Management                               */
+/*=======================================================================*/
+extern kal_bool pmic_chrdet_status(void);
+extern void rtc_pwm_enable_check(void);
+
+void mt_power_off(void)
+{
+	printk("mt_power_off\n");
+
+	// enable VRTC PWM if needed
+	rtc_pwm_enable_check();
+
+	/* pull PWRBB low */
+	/*Hong-Rong: FIXME for early porting*/
+	rtc_bbpu_power_down();
+
+	while (1) {
+#if defined(CONFIG_POWER_EXT)
+		//EVB
+		printk("EVB without charger\n");
+#else	
+		//Phone	
+		printk("Phone with charger\n");
+		if (pmic_chrdet_status() == KAL_TRUE)
+			arch_reset(0, "power_off_with_charger");
+#endif
+    }
+}
+
+/*=======================================================================*/
+/* Board Specific Devices                                                */
+/*=======================================================================*/
+/*GPS driver*/
+/*FIXME: remove mt3326 notation */
+struct mt3326_gps_hardware mt3326_gps_hw = {
+    .ext_power_on =  NULL,
+    .ext_power_off = NULL,
+};
+
+/*=======================================================================*/
+/* Board Specific Devices Init                                           */
+/*=======================================================================*/
+#if !defined(CONFIG_MTK_COMBO) && !defined(CONFIG_MTK_COMBO_MODULE)
+#endif
+#ifdef CONFIG_MTK_BT_SUPPORT
+void mt_bt_power_on(void)
+{
+    printk(KERN_INFO "+mt_bt_power_on\n");
+
+#if defined(CONFIG_MTK_COMBO) || defined(CONFIG_MTK_COMBO_MODULE)
+    /* combo chip product */
+    /*
+     * Ignore rfkill0/state call. Controll BT power on/off through device /dev/stpbt.
+     */
+#else 
+    /* standalone product */
+#endif
+
+    printk(KERN_INFO "-mt_bt_power_on\n");
+}
+EXPORT_SYMBOL(mt_bt_power_on);
+
+void mt_bt_power_off(void)
+{
+    printk(KERN_INFO "+mt_bt_power_off\n");
+
+#if defined(CONFIG_MTK_COMBO) || defined(CONFIG_MTK_COMBO_MODULE)
+    /* combo chip product */
+    /*
+     * Ignore rfkill0/state call. Controll BT power on/off through device /dev/stpbt.
+     */
+#else
+    /* standalone product */
+#endif
+
+    printk(KERN_INFO "-mt_bt_power_off\n");
+}
+EXPORT_SYMBOL(mt_bt_power_off);
+
+int mt_bt_suspend(pm_message_t state)
+{
+    printk(KERN_INFO "+mt_bt_suspend\n");
+    printk(KERN_INFO "-mt_bt_suspend\n");
+    return MT_BT_OK;
+}
+
+int mt_bt_resume(pm_message_t state)
+{
+    printk(KERN_INFO "+mt_bt_resume\n");
+    printk(KERN_INFO "-mt_bt_resume\n");
+    return MT_BT_OK;
+}
+#endif
+
+#if 0
+#if defined(CONFIG_MTK_COMBO) || defined(CONFIG_MTK_COMBO_MODULE)
+
+static void combo_bgf_eirq_handler(void)
+{
+    mt_combo_bgf_eirq_handler(NULL);
+}
+
+static void mt_combo_bgf_request_irq(void *data)
+{
+    mt65xx_eint_set_sens(CUST_EINT_COMBO_BGF_NUM, CUST_EINT_COMBO_BGF_SENSITIVE);
+    mt65xx_eint_set_hw_debounce(CUST_EINT_COMBO_BGF_NUM, CUST_EINT_COMBO_BGF_DEBOUNCE_CN);
+    mt65xx_eint_registration(CUST_EINT_COMBO_BGF_NUM,
+        CUST_EINT_COMBO_BGF_DEBOUNCE_EN,
+        CUST_EINT_COMBO_BGF_POLARITY,
+        combo_bgf_eirq_handler,
+        0);
+    mt65xx_eint_mask(CUST_EINT_COMBO_BGF_NUM); /*2*/
+    return;
+}
+
+/* Combo chip shared interrupt (BGF_INT_B) */
+void mt_combo_bgf_enable_irq(void)
+{
+    mt65xx_eint_unmask(CUST_EINT_COMBO_BGF_NUM);
+    return;
+}
+EXPORT_SYMBOL(mt_combo_bgf_enable_irq);
+
+void mt_combo_bgf_disable_irq(void)
+{
+    mt65xx_eint_mask(CUST_EINT_COMBO_BGF_NUM);
+    return;
+}
+EXPORT_SYMBOL(mt_combo_bgf_disable_irq);
+
+void mt6620_print_pin_configure(void)
+{
+	printk(KERN_INFO "[MT6620_PIN]=>GPIO pin configuration start<=\n");
+#ifdef GPIO_COMBO_6620_LDO_EN_PIN
+	printk(KERN_INFO "LDO_EN(GPIO%d)\n", GPIO_COMBO_6620_LDO_EN_PIN);
+#else
+	printk(KERN_INFO "LDO_EN(not defined)\n");	
+#endif
+
+#ifdef GPIO_COMBO_PMU_EN_PIN
+	printk(KERN_INFO "PMU_EN(GPIO%d)\n", GPIO_COMBO_PMU_EN_PIN);
+#else
+	printk(KERN_INFO "PMU_EN(not defined)\n");	
+#endif
+
+
+#ifdef GPIO_COMBO_RST_PIN
+	printk(KERN_INFO "RST(GPIO%d)\n", GPIO_COMBO_RST_PIN);
+#else
+	printk(KERN_INFO "RST(not defined)\n");	
+#endif
+#ifdef GPIO_COMBO_ALL_EINT_PIN
+	printk(KERN_INFO "ALL_EINT(GPIO%d)\n", GPIO_COMBO_ALL_EINT_PIN);
+#else
+	printk(KERN_INFO "ALL_EINT(not defined)\n");
+#endif
+#ifdef GPIO_COMBO_BGF_EINT_PIN
+	printk(KERN_INFO "BGF_EINT(GPIO%d)\n", GPIO_COMBO_BGF_EINT_PIN);
+#else
+	printk(KERN_INFO "BGF_EINT(not defined)\n");	
+#endif
+
+#ifdef CUST_EINT_COMBO_BGF_NUM
+	printk(KERN_INFO "BGF_EINT_NUM(%d)\n", CUST_EINT_COMBO_BGF_NUM);
+#else
+	printk(KERN_INFO "BGF_EINT_NUM(not defined)\n");	
+#endif
+
+#ifdef GPIO_WIFI_EINT_PIN
+	printk(KERN_INFO "WIFI_EINT(GPIO%d)\n", GPIO_WIFI_EINT_PIN);
+#else
+	printk(KERN_INFO "WIFI_EINT(not defined)\n");	
+#endif
+
+#ifdef CUST_EINT_WIFI_NUM
+	printk(KERN_INFO "WIFI_EINT_NUM(%d)\n", CUST_EINT_WIFI_NUM);
+#else
+	printk(KERN_INFO "WIFI_EINT_NUM(not defined)\n");	
+#endif
+
+#ifdef GPIO_UART_URXD3_PIN
+	printk(KERN_INFO "UART_RX(GPIO%d)\n", GPIO_UART_URXD3_PIN);
+#else
+	printk(KERN_INFO "UART_RX(not defined)\n");	
+#endif
+#ifdef GPIO_UART_UTXD3_PIN
+	printk(KERN_INFO "UART_TX(GPIO%d)\n", GPIO_UART_UTXD3_PIN);
+#else
+	printk(KERN_INFO "UART_TX(not defined)\n");	
+#endif
+#ifdef GPIO_PCM_DAICLK_PIN
+	printk(KERN_INFO "DAICLK(GPIO%d)\n", GPIO_PCM_DAICLK_PIN);
+#else
+	printk(KERN_INFO "DAICLK(not defined)\n");	
+#endif
+#ifdef GPIO_PCM_DAIPCMOUT_PIN
+	printk(KERN_INFO "PCMOUT(GPIO%d)\n", GPIO_PCM_DAIPCMOUT_PIN);
+#else
+	printk(KERN_INFO "PCMOUT(not defined)\n");	
+#endif
+#ifdef GPIO_PCM_DAIPCMIN_PIN
+	printk(KERN_INFO "PCMIN(GPIO%d)\n", GPIO_PCM_DAIPCMIN_PIN);
+#else
+	printk(KERN_INFO "PCMIN(not defined)\n");	
+#endif
+#ifdef GPIO_PCM_DAISYNC_PIN
+	printk(KERN_INFO "PCMSYNC(GPIO%d)\n", GPIO_PCM_DAISYNC_PIN);
+#else
+	printk(KERN_INFO "PCMSYNC(not defined)\n");	
+#endif
+#ifndef FM_ANALOG_INPUT
+	#ifdef GPIO_I2S0_CK_PIN
+		printk(KERN_INFO "I2S_CK(GPIO%d)\n", GPIO_I2S0_CK_PIN);
+	#else
+		printk(KERN_INFO "I2S_CK(GPIO%d)\n", GPIO_I2S0_CK_PIN);
+	#endif
+	#ifdef GPIO_I2S0_WS_PIN
+		printk(KERN_INFO "I2S_WS(GPIO%d)\n", GPIO_I2S0_WS_PIN);
+	#else
+		printk(KERN_INFO "I2S_WS(GPIO%d)\n", GPIO_I2S0_WS_PIN);
+	#endif
+	#ifdef GPIO_I2S0_DAT_PIN
+		printk(KERN_INFO "I2S_DAT(GPIO%d)\n", GPIO_I2S0_DAT_PIN);
+	#else
+		printk(KERN_INFO "I2S_DAT(GPIO%d)\n", GPIO_I2S0_DAT_PIN);
+	#endif
+#else
+	printk(KERN_INFO "fm analog input mode is set, no need to set I2S pins\n");
+#endif
+	printk(KERN_INFO "[MT6620_PIN]=>GPIO pin configuration end<=\n");
+	
+}
+
+void mt6620_power_on(void)
+{
+    int result = 0;
+    static int _32k_set = 0;
+	/*log MT6620 GPIO Settings*/
+	mt6620_print_pin_configure();
+    /* disable interrupt firstly */
+    mt_combo_bgf_disable_irq();
+
+#define MT6620_OFF_TIME (10) /* in ms, workable value */
+#define MT6620_RST_TIME (30) /* in ms, workable value */
+#define MT6620_STABLE_TIME (30) /* in ms, workable value */
+#define MT6620_EXT_INT_TIME (5) /* in ms, workable value */
+#define MT6620_32K_STABLE_TIME (100) /* in ms, test value */
+
+    
+    
+#if defined(CONFIG_MTK_COMBO_SDIO_SLOT) && (CONFIG_MTK_COMBO_SDIO_SLOT == 0)
+	printk(KERN_INFO "[mt6620] pull up sd0 bus(gpio169~gpio175(exclude gpio174))\n");
+    mt_set_gpio_pull_enable(GPIO172, GPIO_PULL_ENABLE);	//->CLK
+    mt_set_gpio_pull_select(GPIO172, GPIO_PULL_UP);		
+    mt_set_gpio_pull_enable(GPIO171, GPIO_PULL_ENABLE);	//->CMD
+    mt_set_gpio_pull_select(GPIO171, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO175, GPIO_PULL_ENABLE);	//->DAT0
+    mt_set_gpio_pull_select(GPIO175, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO173, GPIO_PULL_ENABLE);	//->DAT1
+    mt_set_gpio_pull_select(GPIO173, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO169, GPIO_PULL_ENABLE);	//->DAT2
+    mt_set_gpio_pull_select(GPIO169, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO170, GPIO_PULL_ENABLE);	//->DAT3
+    mt_set_gpio_pull_select(GPIO170, GPIO_PULL_UP);
+#elif (CONFIG_MTK_COMBO_SDIO_SLOT == 1)
+	#error "error:MSDC1 is not reserved for MT6620 on MT6575EVB"
+#elif (CONFIG_MTK_COMBO_SDIO_SLOT == 2)
+    printk(KERN_INFO "[mt6620] pull up sd2 bus(gpio182~187)\n");
+    mt_set_gpio_pull_enable(GPIO182, GPIO_PULL_ENABLE);	//->CLK
+    mt_set_gpio_pull_select(GPIO182, GPIO_PULL_UP);		
+    mt_set_gpio_pull_enable(GPIO184, GPIO_PULL_ENABLE);	//->CMD
+    mt_set_gpio_pull_select(GPIO184, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO186, GPIO_PULL_ENABLE);	//->DAT0
+    mt_set_gpio_pull_select(GPIO186, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO187, GPIO_PULL_ENABLE);	//->DAT1
+    mt_set_gpio_pull_select(GPIO187, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO185, GPIO_PULL_ENABLE);	//->DAT2
+    mt_set_gpio_pull_select(GPIO185, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO183, GPIO_PULL_ENABLE);	//->DAT3
+    mt_set_gpio_pull_select(GPIO183, GPIO_PULL_UP);
+#elif (CONFIG_MTK_COMBO_SDIO_SLOT == 3)
+	printk(KERN_INFO "[mt6620] pull up sd3 bus (GPIO89~GPIO94)\n");
+    mt_set_gpio_pull_enable(GPIO92, GPIO_PULL_ENABLE);	//->CLK
+    mt_set_gpio_pull_select(GPIO92, GPIO_PULL_UP);		
+    mt_set_gpio_pull_enable(GPIO91, GPIO_PULL_ENABLE);	//->CMD
+    mt_set_gpio_pull_select(GPIO91, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO94, GPIO_PULL_ENABLE);	//->DAT0
+    mt_set_gpio_pull_select(GPIO94, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO90, GPIO_PULL_ENABLE);	//->DAT1
+    mt_set_gpio_pull_select(GPIO90, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO89, GPIO_PULL_ENABLE);	//->DAT2
+    mt_set_gpio_pull_select(GPIO89, GPIO_PULL_UP);
+    mt_set_gpio_pull_enable(GPIO93, GPIO_PULL_ENABLE);	//->DAT3
+    mt_set_gpio_pull_select(GPIO93, GPIO_PULL_UP);
+#else
+	#error "error:unsupported CONFIG_MTK_COMBO_SDIO_SLOT" CONFIG_MTK_COMBO_SDIO_SLOT
+#endif
+
+    //printk(KERN_INFO "[mt6620] enable RTC CLK\n");
+	if(_32k_set == 0){
+		//rtc_gpio_export_32k(true); //old 32k export API
+		/*
+		* To fix RTC32k clocks stops after system reboot
+		*/
+		rtc_gpio_enable_32k(RTC_GPIO_USER_GPS);
+		_32k_set = 1;
+		printk("[mt6620]rtc_gpio_enable_32k(RTC_GPIO_USER_GPS) \n");
+	} else {
+		printk("[mt6620]not to rtc_gpio_enable_32k(RTC_GPIO_USER_GPS)\n");
+	}
+    msleep(MT6620_32K_STABLE_TIME);
+
+
+    /* UART Mode */
+    result += mt_set_gpio_mode(GPIO_UART_URXD3_PIN, GPIO_UART_URXD3_PIN_M_URXD);//GPIO_MODE_01->GPIO_UART_URXD3_PIN_M_URXD
+    result += mt_set_gpio_mode(GPIO_UART_UTXD3_PIN, GPIO_UART_UTXD3_PIN_M_UTXD);//GPIO_MODE_01->GPIO_UART_UTXD3_PIN_M_UTXD
+    //printk(KERN_INFO "[mt6620] set UART GPIO Mode [%d]\n", result);
+
+    /* FIXME! GeorgeKuo: added for MT6620 GPIO initialization */
+    /* disable pull */
+
+	mt_set_gpio_pull_enable(GPIO_COMBO_PMU_EN_PIN, GPIO_PULL_DISABLE);
+
+    mt_set_gpio_pull_enable(GPIO_COMBO_RST_PIN, GPIO_PULL_DISABLE);
+    /* set output */
+
+	mt_set_gpio_dir(GPIO_COMBO_PMU_EN_PIN, GPIO_DIR_OUT);
+
+    mt_set_gpio_dir(GPIO_COMBO_RST_PIN, GPIO_DIR_OUT);
+    /* set gpio mode */
+
+	mt_set_gpio_mode(GPIO_COMBO_PMU_EN_PIN, GPIO_MODE_GPIO);
+
+    mt_set_gpio_mode(GPIO_COMBO_RST_PIN, GPIO_MODE_GPIO);
+
+    /* SYSRST_B low */
+    mt_set_gpio_out(GPIO_COMBO_RST_PIN, GPIO_OUT_ZERO);
+    /* PMU_EN low */
+	mt_set_gpio_out(GPIO_COMBO_PMU_EN_PIN, GPIO_OUT_ZERO);
+
+    msleep(MT6620_OFF_TIME);
+
+    /* PMU_EN high, SYSRST_B low */
+	mt_set_gpio_out(GPIO_COMBO_PMU_EN_PIN, GPIO_OUT_ONE);
+    msleep(MT6620_RST_TIME);
+
+    /* SYSRST_B high */
+    mt_set_gpio_out(GPIO_COMBO_RST_PIN, GPIO_OUT_ONE);
+    msleep(MT6620_STABLE_TIME);
+
+    /* BT PCM bus default mode. Real control is done by audio and mt_combo.c */
+    mt_combo_audio_ctrl_ex(COMBO_AUDIO_STATE_1, 0);
+
+    /* EINT1 for BGF_INT_B */
+    mt_set_gpio_mode(GPIO_COMBO_BGF_EINT_PIN, GPIO_COMBO_BGF_EINT_PIN_M_GPIO);
+    mt_set_gpio_pull_enable(GPIO_COMBO_BGF_EINT_PIN, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_select(GPIO_COMBO_BGF_EINT_PIN, GPIO_PULL_UP);
+    mt_set_gpio_mode(GPIO_COMBO_BGF_EINT_PIN, GPIO_COMBO_BGF_EINT_PIN_M_EINT);
+
+    /* request IRQ (EINT1) */
+    mt_combo_bgf_request_irq(NULL);
+
+    printk(KERN_INFO "[mt6620] power on \n");
+
+    return;
+}
+EXPORT_SYMBOL(mt6620_power_on);
+
+void mt6620_power_off(void)
+{
+    printk(KERN_INFO "[mt6620] power off\n");
+
+    //printk(KERN_INFO "[mt6620] mt_combo_bgf_disable_irq\n");
+    mt_combo_bgf_disable_irq();
+
+    //printk(KERN_INFO "[mt6620] set BGF_EINT input pull down\n");
+    mt_set_gpio_mode(GPIO_COMBO_BGF_EINT_PIN, GPIO_COMBO_BGF_EINT_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_COMBO_BGF_EINT_PIN, GPIO_DIR_IN);
+    mt_set_gpio_pull_select(GPIO_COMBO_BGF_EINT_PIN, GPIO_PULL_DOWN);
+    mt_set_gpio_pull_enable(GPIO_COMBO_BGF_EINT_PIN, GPIO_PULL_ENABLE);
+
+    //printk(KERN_INFO "[mt6620] ALL_EINT NC\n");
+#ifdef GPIO_COMBO_ALL_EINT_PIN
+    //printk(KERN_INFO "[mt6620] set ALL_EINT input pull down\n");
+    mt_set_gpio_mode(GPIO_COMBO_ALL_EINT_PIN, GPIO_MODE_00);
+    mt_set_gpio_dir(GPIO_COMBO_ALL_EINT_PIN, GPIO_DIR_IN);
+    mt_set_gpio_pull_select(GPIO_COMBO_ALL_EINT_PIN, GPIO_PULL_DOWN);
+    mt_set_gpio_pull_enable(GPIO_COMBO_ALL_EINT_PIN, GPIO_PULL_ENABLE);
+#endif
+    //printk(KERN_INFO "[mt6620] set COMBO_AUDIO_STATE_0\n");
+    mt_combo_audio_ctrl_ex(COMBO_AUDIO_STATE_0, 0);
+
+//MT6620 I2S0 related pin defination has been added to the .dws file
+#ifndef FM_ANALOG_INPUT
+	mt_set_gpio_mode(GPIO_I2S0_CK_PIN, GPIO_I2S0_CK_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_I2S0_CK_PIN, GPIO_DIR_IN);
+    mt_set_gpio_pull_select(GPIO_I2S0_CK_PIN, GPIO_PULL_DOWN);
+    mt_set_gpio_pull_enable(GPIO_I2S0_CK_PIN, GPIO_PULL_ENABLE);
+    mt_set_gpio_mode(GPIO_I2S0_WS_PIN, GPIO_I2S0_WS_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_I2S0_WS_PIN, GPIO_DIR_IN);
+    mt_set_gpio_pull_select(GPIO_I2S0_WS_PIN, GPIO_PULL_DOWN);
+    mt_set_gpio_pull_enable(GPIO_I2S0_WS_PIN, GPIO_PULL_ENABLE);
+    mt_set_gpio_mode(GPIO_I2S0_DAT_PIN, GPIO_I2S0_DAT_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_I2S0_DAT_PIN, GPIO_DIR_IN);
+    mt_set_gpio_pull_select(GPIO_I2S0_DAT_PIN, GPIO_PULL_DOWN);
+    mt_set_gpio_pull_enable(GPIO_I2S0_DAT_PIN, GPIO_PULL_ENABLE);
+#endif    
+    //printk(KERN_INFO "[mt6620] set SYSRST_B 0 and PMU_EN 0 \n");
+    /* SYSRST_B low */
+    mt_set_gpio_out(GPIO_COMBO_RST_PIN, GPIO_OUT_ZERO);
+    /* PMU_EN low */
+	mt_set_gpio_out(GPIO_COMBO_PMU_EN_PIN, GPIO_OUT_ZERO);
+
+#if defined(CONFIG_MTK_COMBO_SDIO_SLOT) && (CONFIG_MTK_COMBO_SDIO_SLOT == 0)
+	printk(KERN_INFO "[mt6620] pull down sd0 bus(gpio169~gpio175(exclude gpio174))\n");
+    mt_set_gpio_pull_enable(GPIO172, GPIO_PULL_DOWN);	//->CLK
+    mt_set_gpio_pull_select(GPIO172, GPIO_PULL_ENABLE);		
+    mt_set_gpio_pull_enable(GPIO171, GPIO_PULL_DOWN);	//->CMD
+    mt_set_gpio_pull_select(GPIO171, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO175, GPIO_PULL_DOWN);	//->DAT0
+    mt_set_gpio_pull_select(GPIO175, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO173, GPIO_PULL_DOWN);	//->DAT1
+    mt_set_gpio_pull_select(GPIO173, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO169, GPIO_PULL_DOWN);	//->DAT2
+    mt_set_gpio_pull_select(GPIO169, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO170, GPIO_PULL_DOWN);	//->DAT3
+    mt_set_gpio_pull_select(GPIO170, GPIO_PULL_ENABLE);
+#elif (CONFIG_MTK_COMBO_SDIO_SLOT == 1)
+	#error "error:MSDC1 is not reserved for MT6620 on MT6575EVB"
+#elif (CONFIG_MTK_COMBO_SDIO_SLOT == 2)
+    printk(KERN_INFO "[mt6620] pull down sd2 bus(gpio182~187)\n");
+    mt_set_gpio_pull_enable(GPIO182, GPIO_PULL_DOWN);	//->CLK
+    mt_set_gpio_pull_select(GPIO182, GPIO_PULL_ENABLE);		
+    mt_set_gpio_pull_enable(GPIO184, GPIO_PULL_DOWN);	//->CMD
+    mt_set_gpio_pull_select(GPIO184, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO186, GPIO_PULL_DOWN);	//->DAT0
+    mt_set_gpio_pull_select(GPIO186, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO187, GPIO_PULL_DOWN);	//->DAT1
+    mt_set_gpio_pull_select(GPIO187, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO185, GPIO_PULL_DOWN);	//->DAT2
+    mt_set_gpio_pull_select(GPIO185, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO183, GPIO_PULL_DOWN);	//->DAT3
+    mt_set_gpio_pull_select(GPIO183, GPIO_PULL_ENABLE);
+#elif (CONFIG_MTK_COMBO_SDIO_SLOT == 3)
+	printk(KERN_INFO "[mt6620] pull down sd3 bus (GPIO89~GPIO94)\n");
+    mt_set_gpio_pull_enable(GPIO92, GPIO_PULL_DOWN);	//->CLK
+    mt_set_gpio_pull_select(GPIO92, GPIO_PULL_ENABLE);		
+    mt_set_gpio_pull_enable(GPIO91, GPIO_PULL_DOWN);	//->CMD
+    mt_set_gpio_pull_select(GPIO91, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO94, GPIO_PULL_DOWN);	//->DAT0
+    mt_set_gpio_pull_select(GPIO94, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO90, GPIO_PULL_DOWN);	//->DAT1
+    mt_set_gpio_pull_select(GPIO90, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO89, GPIO_PULL_DOWN);	//->DAT2
+    mt_set_gpio_pull_select(GPIO89, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_enable(GPIO93, GPIO_PULL_DOWN);	//->DAT3
+    mt_set_gpio_pull_select(GPIO93, GPIO_PULL_ENABLE);
+#else
+	#error "error:unsupported CONFIG_MTK_COMBO_SDIO_SLOT" CONFIG_MTK_COMBO_SDIO_SLOT
+#endif
+    //printk(KERN_INFO "[mt6620] set UART GPIO Mode output 0\n");
+    mt_set_gpio_mode(GPIO_UART_URXD3_PIN, GPIO_UART_URXD3_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_UART_URXD3_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_UART_URXD3_PIN, GPIO_OUT_ZERO);
+
+    mt_set_gpio_mode(GPIO_UART_UTXD3_PIN, GPIO_UART_UTXD3_PIN_M_GPIO);
+    mt_set_gpio_dir(GPIO_UART_UTXD3_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_UART_UTXD3_PIN, GPIO_OUT_ZERO);
+
+    //printk(KERN_INFO "[mt6620] disable RTC CLK \n");
+	printk("[mt6620]not to rtc_gpio_disable_32k(RTC_GPIO_USER_GPS)  \n");
+    return;
+}
+EXPORT_SYMBOL(mt6620_power_off);
+
+int mt_combo_gps_sync_pin_ctrl(int on)
+{
+    printk("[mt6620]ignore gps_sync function on mt6575_evb project.\n");
+}
+EXPORT_SYMBOL(mt_combo_gps_sync_pin_ctrl);
+
+static void combo_bt_pcm_pin_on(void)
+{
+    mt_set_gpio_mode(GPIO_PCM_DAICLK_PIN, GPIO_PCM_DAICLK_PIN_M_CLK);
+    mt_set_gpio_mode(GPIO_PCM_DAIPCMOUT_PIN, GPIO_PCM_DAIPCMOUT_PIN_M_DAIPCMOUT);
+    mt_set_gpio_mode(GPIO_PCM_DAIPCMIN_PIN, GPIO_PCM_DAIPCMIN_PIN_M_DAIPCMIN);
+    mt_set_gpio_mode(GPIO_PCM_DAISYNC_PIN, GPIO_PCM_DAISYNC_PIN_M_BTSYNC);	
+}
+
+static void combo_bt_pcm_pin_off(void)
+{
+    mt_set_gpio_mode(GPIO_PCM_DAICLK_PIN, GPIO_MODE_00);
+    mt_set_gpio_dir(GPIO_PCM_DAICLK_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_PCM_DAICLK_PIN, GPIO_OUT_ZERO);
+
+    mt_set_gpio_mode(GPIO_PCM_DAIPCMOUT_PIN, GPIO_MODE_00);
+    mt_set_gpio_dir(GPIO_PCM_DAIPCMOUT_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_PCM_DAIPCMOUT_PIN, GPIO_OUT_ZERO);
+
+    mt_set_gpio_mode(GPIO_PCM_DAIPCMIN_PIN, GPIO_MODE_00);
+    mt_set_gpio_dir(GPIO_PCM_DAIPCMIN_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_PCM_DAIPCMIN_PIN, GPIO_OUT_ZERO);
+
+    mt_set_gpio_mode(GPIO_PCM_DAISYNC_PIN, GPIO_MODE_00);
+    mt_set_gpio_dir(GPIO_PCM_DAISYNC_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_PCM_DAISYNC_PIN, GPIO_OUT_ZERO);
+}
+
+static void combo_fm_i2s_pin_on(void)
+{
+#ifndef FM_ANALOG_INPUT
+    mt_set_gpio_mode(GPIO_I2S0_CK_PIN, GPIO_MODE_01);	//GPIO_MODE_01->I2S0 mode
+    mt_set_gpio_mode(GPIO_I2S0_WS_PIN, GPIO_MODE_01);	//GPIO_MODE_01->I2S0 mode
+    mt_set_gpio_mode(GPIO_I2S0_DAT_PIN, GPIO_MODE_01);	//GPIO_MODE_01->I2S0 mode
+#else
+	printk("[mt6620]warnning:fm analog input mode is set, combo_fm_i2s_pin_on should not be called. \n");
+#endif
+}
+
+static void combo_fm_i2s_pin_off(void)
+{
+#ifndef FM_ANALOG_INPUT
+    mt_set_gpio_mode(GPIO_I2S0_CK_PIN, GPIO_MODE_00);
+    mt_set_gpio_dir(GPIO_I2S0_CK_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_I2S0_CK_PIN, GPIO_OUT_ZERO);
+
+    mt_set_gpio_mode(GPIO_I2S0_WS_PIN, GPIO_MODE_00);
+    mt_set_gpio_dir(GPIO_I2S0_WS_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_I2S0_WS_PIN, GPIO_OUT_ZERO);
+
+    mt_set_gpio_mode(GPIO_I2S0_DAT_PIN, GPIO_MODE_00);
+    mt_set_gpio_dir(GPIO_I2S0_DAT_PIN, GPIO_DIR_OUT);
+    mt_set_gpio_out(GPIO_I2S0_DAT_PIN, GPIO_OUT_ZERO);
+#else
+	printk("[mt6620]warnning:fm analog input mode is set, combo_fm_i2s_pin_off should not be called.\n");
+#endif    
+}
+
+
+
+void combo_audio_pin_conf(COMBO_AUDIO_STATE state)
+{
+    printk(KERN_INFO "combo_audio_pin_conf, state = [%d]\n", state);
+    switch(state)
+    {
+		case COMBO_AUDIO_STATE_0:
+			/*BT_PCM_OFF*/ 
+			combo_bt_pcm_pin_off();
+			/*FM_I2S0_OFF*/
+			combo_fm_i2s_pin_off();
+	    	break;
+		case COMBO_AUDIO_STATE_1:
+			/* BT_PCM_ON */
+			combo_bt_pcm_pin_on();
+			/*FM_I2S0_OFF*/
+			combo_fm_i2s_pin_off();
+	    	break;
+		case COMBO_AUDIO_STATE_2:
+	    	/*FM_I2S_ON*/
+			combo_fm_i2s_pin_on();
+	    	/*BT_PCM_OFF*/ 
+			combo_bt_pcm_pin_off();
+	    	break;
+		case COMBO_AUDIO_STATE_3:
+	    	/*FM_I2S_ON*/
+			combo_fm_i2s_pin_on();
+	    	/* BT_PCM_ON */
+			combo_bt_pcm_pin_on();
+		break;
+			printk(KERN_INFO "combo_audio_pin_conf,warnning: invalid state(%d)\n", state);
+		default:
+		break;
+    }
+}
+
+#if defined(CONFIG_MTK_COMBO_SDIO_SLOT)
+	static void combo_sdio_enable_eirq(void)
+	{
+	    mt65xx_eint_unmask(combo_sdio_eint_num);/* CUST_EINT_WIFI_NUM */
+	}
+	
+	static void combo_sdio_disable_eirq(void)
+	{
+	    mt65xx_eint_mask(combo_sdio_eint_num); /* CUST_EINT_WIFI_NUM */
+	}
+	
+	static void combo_sdio_eirq_handler_stub(void)
+	{
+	    if (combo_sdio_eirq_handler) {
+	        combo_sdio_eirq_handler(combo_sdio_eirq_data);
+	    }
+	}
+	
+	static void combo_sdio_request_eirq(sdio_irq_handler_t irq_handler, void *data)
+	{
+	    mt65xx_eint_set_sens(combo_sdio_eint_num, CUST_EINT_WIFI_SENSITIVE); /*CUST_EINT_WIFI_NUM */
+	    mt65xx_eint_set_hw_debounce(combo_sdio_eint_num, CUST_EINT_WIFI_DEBOUNCE_CN); /*CUST_EINT_WIFI_NUM */
+	    mt65xx_eint_registration(combo_sdio_eint_num/*CUST_EINT_WIFI_NUM */,
+	        CUST_EINT_WIFI_DEBOUNCE_EN,
+	        CUST_EINT_WIFI_POLARITY,
+	        combo_sdio_eirq_handler_stub,
+	        0);
+	    mt65xx_eint_mask(combo_sdio_eint_num);/*CUST_EINT_WIFI_NUM */
+	
+	    combo_sdio_eirq_handler = irq_handler;
+	    combo_sdio_eirq_data    = data;
+	}
+	
+	static void combo_sdio_register_pm(pm_callback_t pm_cb, void *data)
+	{
+	    /*printk( KERN_INFO "combo_sdio_register_pm (0x%p, 0x%p)\n", pm_cb, data);*/
+	    /* register pm change callback */
+	    combo_sdio_pm_cb = pm_cb;
+	    combo_sdio_pm_data = data;
+	}
+	
+	static void combo_sdio_on (int sdio_port_num) {
+	    pm_message_t state = { .event = PM_EVENT_USER_RESUME };
+	
+	    printk(KERN_INFO "combo_sdio_on (%d) \n", sdio_port_num);
+	
+	    /* 1. disable sdio eirq */
+	    combo_sdio_disable_eirq();
+	    mt_set_gpio_pull_enable(combo_sdio_eint_pin, GPIO_PULL_DISABLE); /* GPIO_WIFI_EINT_PIN */
+	    mt_set_gpio_mode(combo_sdio_eint_pin, combo_sdio_eint_m_eint); /* EINT mode */
+	
+	    /* 2. call sd callback */
+	    if (combo_sdio_pm_cb) {
+	        printk(KERN_INFO "combo_sdio_pm_cb(PM_EVENT_USER_RESUME, 0x%p, 0x%p) \n", combo_sdio_pm_cb, combo_sdio_pm_data);
+	        combo_sdio_pm_cb(state, combo_sdio_pm_data);
+	    }
+	    else {
+	        printk(KERN_WARNING "combo_sdio_on no sd callback!!\n");
+	    }
+	}
+	
+	static void combo_sdio_off (int sdio_port_num) {
+	    pm_message_t state = { .event = PM_EVENT_USER_SUSPEND };
+	
+	    printk(KERN_INFO "combo_sdio_off (%d) \n", sdio_port_num);
+	
+	    /* 1. call sd callback */
+	    if (combo_sdio_pm_cb) {
+	        printk(KERN_INFO "combo_sdio_off(PM_EVENT_USER_SUSPEND, 0x%p, 0x%p) \n", combo_sdio_pm_cb, combo_sdio_pm_data);
+	        combo_sdio_pm_cb(state, combo_sdio_pm_data);
+	    }
+	    else {
+	        printk(KERN_WARNING "combo_sdio_off no sd callback!!\n");
+	    }
+	
+	    /* 2. disable sdio eirq */
+	    combo_sdio_disable_eirq();
+	    /*printk(KERN_INFO "[mt6620] set WIFI_EINT input pull down\n");*/
+	    mt_set_gpio_mode(combo_sdio_eint_pin, combo_sdio_eint_m_gpio); /* GPIO mode */
+	    mt_set_gpio_dir(combo_sdio_eint_pin, GPIO_DIR_IN);
+	    mt_set_gpio_pull_select(combo_sdio_eint_pin, GPIO_PULL_DOWN);
+	    mt_set_gpio_pull_enable(combo_sdio_eint_pin, GPIO_PULL_ENABLE);
+	}
+	
+	int mt_combo_sdio_ctrl (unsigned int sdio_port_num, unsigned int on) {
+	/*FIXME: set sdio_port_num to CONFIG_MTK_COMBO_SDIO_SLOT*/
+		#if defined(CONFIG_MTK_COMBO_SDIO_SLOT)
+			sdio_port_num = CONFIG_MTK_COMBO_SDIO_SLOT;
+			printk(KERN_WARNING "mt_combo_sdio_ctrl: force set sdio port to (%d)\n", sdio_port_num);
+		#endif
+	    if ((sdio_port_num >= 4) || (combo_port_pwr_map[sdio_port_num] == 0xFF) ) {
+	        /* invalid sdio port number or slot mapping */
+	        printk(KERN_WARNING "mt_combo_sdio_ctrl invalid port(%d, %d)\n", sdio_port_num, combo_port_pwr_map[sdio_port_num]);
+	        return -1;
+	    }
+	    /*printk(KERN_INFO "mt_combo_sdio_ctrl (%d, %d)\n", sdio_port_num, on);*/
+	
+	    if (!combo_port_pwr_map[sdio_port_num] && on) {
+			/* on -> off */
+			printk(KERN_INFO "mt_combo_sdio_ctrl:force [sdio%d] off before on\n", sdio_port_num);
+	        combo_sdio_off(sdio_port_num);
+	        combo_port_pwr_map[sdio_port_num] = 0;
+	        /* off -> on */
+	        combo_sdio_on(sdio_port_num);
+	        combo_port_pwr_map[sdio_port_num] = 1;
+	    }
+	    else if (combo_port_pwr_map[sdio_port_num] && !on) {
+	        /* on -> off */
+	        combo_sdio_off(sdio_port_num);
+	        combo_port_pwr_map[sdio_port_num] = 0;
+	    }
+	    else {
+	        return -2;
+	    }
+	    return 0;
+	}
+#else
+	int mt_combo_sdio_ctrl (unsigned int sdio_port_num, unsigned int on) {
+	    printk(KERN_WARNING "mt_combo_sdio_ctrl but CONFIG_MTK_COMBO_SDIO_SLOT undefined!\n");
+	    return -1;
+	}
+
+#endif /* end of defined(CONFIG_MTK_COMBO_SDIO_SLOT) */
+EXPORT_SYMBOL(mt_combo_sdio_ctrl);
+
+int mt_combo_gps_lna_pin_ctrl(unsigned int on)
+{
+	printk(KERN_INFO "%s:(MT6575 platform, this operation is omitted @EVB project)\n", __FUNCTION__);
+	return 0;
+}
+EXPORT_SYMBOL(mt_combo_gps_lna_pin_ctrl);
+#endif /* end of  defined(CONFIG_MTK_COMBO) || defined(CONFIG_MTK_COMBO_MODULE) */
+#endif
+#if defined(CONFIG_WLAN)
+    #if !defined(CONFIG_MTK_COMBO_SDIO_SLOT)
+    #endif /* end of !defined(CONFIG_MTK_COMBO_SDIO_SLOT) */
+
+int mt_wifi_resume(pm_message_t state)
+{
+    int evt = state.event;
+
+    if (evt != PM_EVENT_USER_RESUME && evt != PM_EVENT_RESUME) {
+        return -1;
+    }
+
+    /*printk(KERN_INFO "[WIFI] %s Resume\n", evt == PM_EVENT_RESUME ? "PM":"USR");*/
+
+#if defined(CONFIG_MTK_COMBO) || defined(CONFIG_MTK_COMBO_MODULE)
+    /* combo chip product: notify combo driver to turn on Wi-Fi */
+    mtk_wcn_cmb_stub_func_ctrl(COMBO_FUNC_TYPE_WIFI, 1);
+
+#else /* standalone product */
+#endif
+
+    return 0;
+}
+
+int mt_wifi_suspend(pm_message_t state)
+{
+    int evt = state.event;
+#if defined(CONFIG_MTK_COMBO_SDIO_SLOT)
+    static int is_1st_suspend_from_boot = 1;
+#endif
+
+    if (evt != PM_EVENT_USER_SUSPEND && evt != PM_EVENT_SUSPEND) {
+        return -1;
+    }
+
+#if defined(CONFIG_MTK_COMBO) || defined(CONFIG_MTK_COMBO_MODULE)
+    #if defined(CONFIG_MTK_COMBO_SDIO_SLOT)
+    /* combo chip product: notify combo driver to turn on Wi-Fi */
+    if (is_1st_suspend_from_boot) {
+        pm_message_t state = { .event = PM_EVENT_USER_SUSPEND };
+
+        if (combo_sdio_pm_cb) {
+            is_1st_suspend_from_boot = 0;
+            /*              *** IMPORTANT DEPENDENDY***
+            RFKILL: set wifi and bt suspend by default in probe()
+            MT6573-SD: sd host is added to MMC stack and suspend is ZERO by default
+            (which means NOT suspended).
+
+            When boot up, RFKILL will set wifi off and this function gets
+            called. In order to successfully resume wifi at 1st time, pm_cb here
+            shall be called once to let MT6573-SD do sd host suspend and remove
+            sd host from MMC. Then wifi can be turned on successfully.
+
+            Boot->SD host added to MMC (suspend=0)->RFKILL set wifi off
+            ->SD host removed from MMC (suspend=1)->RFKILL set wifi on
+            */
+            printk(KERN_INFO "1st mt_wifi_suspend (PM_EVENT_USER_SUSPEND) \n");
+            combo_sdio_pm_cb(state, combo_sdio_pm_data);
+        }
+        else {
+            printk(KERN_WARNING "1st mt_wifi_suspend but no sd callback!!\n");
+        }
+    }
+    else {
+        /* combo chip product, notify combo driver */
+        mtk_wcn_cmb_stub_func_ctrl(COMBO_FUNC_TYPE_WIFI, 0);
+    }
+    #endif
+
+#else
+#endif
+    return 0;
+}
+
+void mt_wifi_power_on(void)
+{
+    pm_message_t state = { .event = PM_EVENT_USER_RESUME };
+
+    (void)mt_wifi_resume(state);
+}
+EXPORT_SYMBOL(mt_wifi_power_on);
+
+void mt_wifi_power_off(void)
+{
+    pm_message_t state = { .event = PM_EVENT_USER_SUSPEND };
+
+    (void)mt_wifi_suspend(state);
+}
+EXPORT_SYMBOL(mt_wifi_power_off);
+
+#endif /* end of defined(CONFIG_WLAN) */
+
+/* Board Specific Devices                                                */
+/*=======================================================================*/
+
+/*=======================================================================*/
+/* Board Specific Devices Init                                           */
+/*=======================================================================*/
+
+/*=======================================================================*/
+/* Board Devices Capability                                              */
+/*=======================================================================*/
+#define MSDC_SDIO_FLAG    (MSDC_EXT_SDIO_IRQ | MSDC_HIGHSPEED | MSDC_UHS1)
+
+#if defined(CFG_DEV_MSDC0)
+  #if defined(CONFIG_MTK_EMMC_SUPPORT)
+    struct msdc_ett_settings msdc0_ett_settings[] = {
+        /* common ett settings */
+        { MSDC_HS200_MODE, 0xb0,  (0x7 << 7), 0 }, //PATCH_BIT0[MSDC_PB0_INT_DAT_LATCH_CK_SEL]
+        { MSDC_HS200_MODE, 0xb0,  (0x1f<<10), 0 }, //PATCH_BIT0[MSDC_PB0_CKGEN_MSDC_DLY_SEL]
+        { MSDC_HS400_MODE, 0xb0,  (0x7 << 7), 0 }, //PATCH_BIT0[MSDC_PB0_INT_DAT_LATCH_CK_SEL]
+        { MSDC_HS400_MODE, 0xb0,  (0x1f<<10), 0 }, //PATCH_BIT0[MSDC_PB0_CKGEN_MSDC_DLY_SEL]
+        { MSDC_HS400_MODE, 0x188, (0x1f<< 2), 2 /*0x0*/ }, //EMMC50_PAD_DS_TUNE[MSDC_EMMC50_PAD_DS_TUNE_DLY1]
+        { MSDC_HS400_MODE, 0x188, (0x1f<<12), 18 /*0x13*/}, //EMMC50_PAD_DS_TUNE[MSDC_EMMC50_PAD_DS_TUNE_DLY3]
+
+        /* command & resp ett settings */
+        { MSDC_HS200_MODE, 0xb4,  (0x7 << 3), 1 }, //PATCH_BIT1[MSDC_PB1_CMD_RSP_TA_CNTR]
+        { MSDC_HS200_MODE, 0x4,   (0x1 << 1), 1 }, //MSDC_IOCON[MSDC_IOCON_RSPL]
+        { MSDC_HS200_MODE, 0xf0,  (0x1f<<16), 0 }, //PAD_TUNE[MSDC_PAD_TUNE_CMDRDLY]
+        { MSDC_HS200_MODE, 0xf0,  (0x1f<<22), 6 }, //PAD_TUNE[MSDC_PAD_TUNE_CMDRRDLY]
+
+        { MSDC_HS400_MODE, 0xb4,  (0x7 << 3), 1 }, //PATCH_BIT1[MSDC_PB1_CMD_RSP_TA_CNTR]
+        { MSDC_HS400_MODE, 0x4,   (0x1 << 1), 1 }, //MSDC_IOCON[MSDC_IOCON_RSPL]
+        { MSDC_HS400_MODE, 0xf0,  (0x1f<<16), 0 }, //PAD_TUNE[MSDC_PAD_TUNE_CMDRDLY]
+        { MSDC_HS400_MODE, 0xf0,  (0x1f<<22), 11 /*0x0*/ }, //PAD_TUNE[MSDC_PAD_TUNE_CMDRRDLY]
+
+        /* write ett settings */
+        { MSDC_HS200_MODE, 0xb4,  (0x7 << 0), 1 }, //PATCH_BIT1[MSDC_PB1_WRDAT_CRCS_TA_CNTR]
+        { MSDC_HS200_MODE, 0xf0,  (0x1f<< 0), 15 }, //PAD_TUNE[MSDC_PAD_TUNE_DATWRDLY]
+        { MSDC_HS200_MODE, 0x4,   (0x1 <<10), 1 }, //MSDC_IOCON[MSDC_IOCON_W_D0SPL]
+        { MSDC_HS200_MODE, 0xf8,  (0x1f<<24), 5 }, //DAT_RD_DLY0[MSDC_DAT_RDDLY0_D0]
+
+        /* read ett settings */
+        { MSDC_HS200_MODE, 0xf0,  (0x1f<< 8), 18}, //PAD_TUNE[MSDC_PAD_TUNE_DATRRDLY]
+        { MSDC_HS200_MODE, 0x4,   (0x1 << 2), 0 }, //MSDC_IOCON[MSDC_IOCON_R_D_SMPL]
+    }; 
+    struct msdc_hw msdc0_hw = {
+        .clk_src        = MSDC50_CLKSRC_400MHZ,
+        .cmd_edge       = MSDC_SMPL_FALLING,
+        .rdata_edge 	  = MSDC_SMPL_FALLING,
+        .wdata_edge 	  = MSDC_SMPL_FALLING,
+        .clk_drv        = 2,
+        .cmd_drv        = 2,
+        .dat_drv        = 2,
+        .rst_drv        = 2,
+        .ds_drv         = 2,
+        .data_pins      = 8,
+        .data_offset    = 0,
+    #ifndef CONFIG_MTK_EMMC_CACHE
+        .flags          = MSDC_SYS_SUSPEND | MSDC_HIGHSPEED |MSDC_DDR | MSDC_UHS1 | MSDC_HS400,
+    #else
+        .flags          = MSDC_SYS_SUSPEND | MSDC_HIGHSPEED | MSDC_CACHE |MSDC_DDR | MSDC_UHS1 | MSDC_HS400, 
+    #endif
+        .dat0rddly      = 0,
+        .dat1rddly      = 0,
+        .dat2rddly      = 0,
+        .dat3rddly      = 0,
+        .dat4rddly      = 0,
+        .dat5rddly      = 0,
+        .dat6rddly      = 0,
+        .dat7rddly      = 0,
+        .datwrddly      = 0,
+        .cmdrrddly      = 0,
+        .cmdrddly       = 0,
+        .ett_count      = 20, //should be same with ett_settings array size
+        .ett_settings   = (struct msdc_ett_settings *)msdc0_ett_settings,
+        .host_function	= MSDC_EMMC,
+        .boot           = MSDC_BOOT_EN,
+    };
+  #else
+    struct msdc_hw msdc0_hw = {
+        .clk_src              = MSDC50_CLKSRC_200MHZ,
+        .cmd_edge             = MSDC_SMPL_FALLING,
+        .rdata_edge           = MSDC_SMPL_FALLING,
+        .wdata_edge           = MSDC_SMPL_FALLING,
+        .clk_drv              = 1,
+        .cmd_drv              = 1,
+        .dat_drv              = 1,
+        .clk_drv_sd_18        = 1,         /* sdr104 mode */
+        .cmd_drv_sd_18        = 1,
+        .dat_drv_sd_18        = 1,
+        .clk_drv_sd_18_sdr50	= 1,         /* sdr50 mode */
+        .cmd_drv_sd_18_sdr50	= 1,
+        .dat_drv_sd_18_sdr50	= 1,
+        .clk_drv_sd_18_ddr50	= 1,         /* ddr50 mode */
+        .cmd_drv_sd_18_ddr50	= 1,
+        .dat_drv_sd_18_ddr50	= 1,
+        .data_pins            = 4,
+        .data_offset          = 0,
+      //#ifdef CUST_EINT_MSDC1_INS_NUM
+      #if 0
+        .flags                = MSDC_SYS_SUSPEND | MSDC_CD_PIN_EN | MSDC_REMOVABLE | MSDC_HIGHSPEED | MSDC_UHS1 |MSDC_DDR,    
+      #else
+        .flags                = MSDC_SYS_SUSPEND | MSDC_HIGHSPEED | MSDC_UHS1 |MSDC_DDR,   
+      #endif
+        .dat0rddly            = 0,
+        .dat1rddly            = 0,
+        .dat2rddly            = 0,
+        .dat3rddly            = 0,
+        .dat4rddly            = 0,
+        .dat5rddly            = 0,
+        .dat6rddly            = 0,
+        .dat7rddly            = 0,
+        .datwrddly            = 0,
+        .cmdrrddly            = 0,
+        .cmdrddly             = 0,
+        .ett_count            = 0, //should be same with ett_settings array size
+        .host_function        = MSDC_SD,
+        .boot	                = 0,
+        .cd_level             = MSDC_CD_LOW,
+    };
+  #endif
+#endif
+
+#if defined(CFG_DEV_MSDC1)
+    struct msdc_hw msdc1_hw = {
+        .clk_src              = MSDC30_CLKSRC_200MHZ,
+        .cmd_edge             = MSDC_SMPL_FALLING,
+        .rdata_edge           = MSDC_SMPL_FALLING,
+        .wdata_edge           = MSDC_SMPL_FALLING,
+        .clk_drv              = 3,
+        .cmd_drv              = 3,
+        .dat_drv              = 3,
+        .clk_drv_sd_18        = 3,         /* sdr104 mode */
+        .cmd_drv_sd_18        = 2,
+        .dat_drv_sd_18        = 2,
+        .clk_drv_sd_18_sdr50	= 3,         /* sdr50 mode */
+        .cmd_drv_sd_18_sdr50	= 2,
+        .dat_drv_sd_18_sdr50	= 2,
+        .clk_drv_sd_18_ddr50	= 3,         /* ddr50 mode */
+        .cmd_drv_sd_18_ddr50	= 2,
+        .dat_drv_sd_18_ddr50	= 2,
+        .data_pins            = 4,
+        .data_offset          = 0,
+    #ifdef CUST_EINT_MSDC1_INS_NUM
+        .flags                = MSDC_SYS_SUSPEND | MSDC_CD_PIN_EN | MSDC_REMOVABLE | MSDC_HIGHSPEED | MSDC_UHS1 |MSDC_DDR,    
+    #else
+        .flags                = MSDC_SYS_SUSPEND | MSDC_HIGHSPEED | MSDC_UHS1 |MSDC_DDR,   
+    #endif
+        .dat0rddly            = 0,
+        .dat1rddly            = 0,
+        .dat2rddly            = 0,
+        .dat3rddly            = 0,
+        .dat4rddly            = 0,
+        .dat5rddly            = 0,
+        .dat6rddly            = 0,
+        .dat7rddly            = 0,
+        .datwrddly            = 0,
+        .cmdrrddly            = 0,
+        .cmdrddly             = 0,
+        .ett_count            = 0, //should be same with ett_settings array size
+        .host_function        = MSDC_SD,
+        .boot	                = 0,
+        .cd_level             = MSDC_CD_LOW,
+    };
+#endif
+
+#if defined(CFG_DEV_MSDC2)
+#if defined(CONFIG_MTK_COMBO_SDIO_SLOT) && (CONFIG_MTK_COMBO_SDIO_SLOT == 2)
+    /* MSDC2 settings for MT66xx combo connectivity chip */
+    struct msdc_hw msdc2_hw = {	    
+        .clk_src        = MSDC30_CLKSRC_200MHZ,
+        .cmd_edge       = MSDC_SMPL_FALLING,
+        .rdata_edge     = MSDC_SMPL_FALLING,
+        .wdata_edge     = MSDC_SMPL_FALLING,
+        .clk_drv        = 1,
+        .cmd_drv        = 1,
+        .dat_drv        = 1,
+        .data_pins      = 4,
+        .data_offset    = 0,
+        //MT6620 use External IRQ, wifi uses high speed. here wifi manage his own suspend and resume, does not support hot plug
+        .flags          = MSDC_SDIO_FLAG,//MSDC_SYS_SUSPEND | MSDC_WP_PIN_EN | MSDC_CD_PIN_EN | MSDC_REMOVABLE,
+        .dat0rddly      = 0,
+        .dat1rddly      = 0,
+        .dat2rddly      = 0,
+        .dat3rddly      = 0,
+        .dat4rddly      = 0,
+        .dat5rddly      = 0,
+        .dat6rddly      = 0,
+        .dat7rddly      = 0,
+        .datwrddly      = 0,
+        .cmdrrddly      = 0,
+        .cmdrddly       = 0,
+        .host_function	= MSDC_SDIO,
+        .boot           = 0,
+        .request_sdio_eirq = combo_sdio_request_eirq,
+        .enable_sdio_eirq  = combo_sdio_enable_eirq,
+        .disable_sdio_eirq = combo_sdio_disable_eirq,
+        .register_pm       = combo_sdio_register_pm,
+    };
+#else
+    struct msdc_hw msdc2_hw = {
+        .clk_src              = MSDC30_CLKSRC_200MHZ,
+        .cmd_edge             = MSDC_SMPL_FALLING,
+        .rdata_edge           = MSDC_SMPL_FALLING,
+        .wdata_edge           = MSDC_SMPL_FALLING,
+        .clk_drv              = 3,
+        .cmd_drv              = 3,
+        .dat_drv              = 3,
+        .clk_drv_sd_18        = 3,         /* sdr104 mode */
+        .cmd_drv_sd_18        = 2,
+        .dat_drv_sd_18        = 2,
+        .clk_drv_sd_18_sdr50	= 3,         /* sdr50 mode */
+        .cmd_drv_sd_18_sdr50	= 2,
+        .dat_drv_sd_18_sdr50	= 2,
+        .clk_drv_sd_18_ddr50	= 3,         /* ddr50 mode */
+        .cmd_drv_sd_18_ddr50	= 2,
+        .dat_drv_sd_18_ddr50	= 2,
+        .data_pins            = 4,
+        .data_offset          = 0,
+        .flags                = MSDC_SYS_SUSPEND | MSDC_HIGHSPEED | MSDC_UHS1 |MSDC_DDR,  
+        .dat0rddly	          = 0,
+        .dat1rddly	          = 0,
+        .dat2rddly	          = 0,
+        .dat3rddly	          = 0,
+        .dat4rddly	          = 0,
+        .dat5rddly	          = 0,
+        .dat6rddly	          = 0,
+        .dat7rddly	          = 0,
+        .datwrddly	          = 0,
+        .cmdrrddly	          = 0,
+        .cmdrddly             = 0,
+        .ett_count            = 0, //should be same with ett_settings array size
+        .host_function        = MSDC_SD,
+        .boot	                = 0,
+        .cd_level             = MSDC_CD_LOW,
+};
+#endif
+#endif
+
+#if defined(CFG_DEV_MSDC3)
+#if defined(CONFIG_MTK_WCN_CMB_SDIO_SLOT) && (CONFIG_MTK_WCN_CMB_SDIO_SLOT == 3)
+    /* MSDC3 settings for MT66xx combo connectivity chip */
+    struct msdc_hw msdc3_hw = {
+        .clk_src        = MSDC30_CLKSRC_200MHZ,
+        .cmd_edge       = MSDC_SMPL_FALLING,
+        .rdata_edge     = MSDC_SMPL_FALLING,
+        .wdata_edge     = MSDC_SMPL_FALLING,
+        .clk_drv        = 1,
+        .cmd_drv        = 1,
+        .dat_drv        = 1,
+        .data_pins      = 4,
+        .data_offset    = 0,
+        //MT6620 use External IRQ, wifi uses high speed. here wifi manage his own suspend and resume, does not support hot plug
+        .flags          = MSDC_SDIO_FLAG,//MSDC_SYS_SUSPEND | MSDC_WP_PIN_EN | MSDC_CD_PIN_EN | MSDC_REMOVABLE,
+        .dat0rddly      = 0,
+        .dat1rddly      = 0,
+        .dat2rddly      = 0,
+        .dat3rddly      = 0,
+        .dat4rddly      = 0,
+        .dat5rddly      = 0,
+        .dat6rddly      = 0,
+        .dat7rddly      = 0,
+        .datwrddly      = 0,
+        .cmdrrddly      = 0,
+        .cmdrddly       = 0,
+        .cmdrtactr_sdr50        = 0x1,
+        .wdatcrctactr_sdr50     = 0x1,
+        .intdatlatcksel_sdr50   = 0x0,
+        .cmdrtactr_sdr200       = 0x3,
+        .wdatcrctactr_sdr200    = 0x3,
+        .intdatlatcksel_sdr200  = 0x0,
+        .ett_count              = 0, //should be same with ett_settings array size
+        .host_function	= MSDC_SDIO,
+        .boot      	    = 0,
+        .request_sdio_eirq = mtk_wcn_cmb_sdio_request_eirq,
+        .enable_sdio_eirq  = mtk_wcn_cmb_sdio_enable_eirq,
+        .disable_sdio_eirq = mtk_wcn_cmb_sdio_disable_eirq,
+        .register_pm       = mtk_wcn_cmb_sdio_register_pm,
+	};
+#endif
+#endif
+
+/* MT6575 NAND Driver */
+#if defined(CONFIG_MTK_MTD_NAND)
+struct mt6575_nand_host_hw mt6575_nand_hw = {
+    .nfi_bus_width          = 8,
+	.nfi_access_timing		= NFI_DEFAULT_ACCESS_TIMING,
+	.nfi_cs_num				= NFI_CS_NUM,
+	.nand_sec_size			= 512,
+	.nand_sec_shift			= 9,
+	.nand_ecc_size			= 2048,
+	.nand_ecc_bytes			= 32,
+	.nand_ecc_mode			= NAND_ECC_HW,
+};
+#endif
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/logger_custom.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/logger_custom.h
new file mode 100755
index 0000000..062f44a
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/core/logger_custom.h
@@ -0,0 +1,13 @@
+#ifndef __LOGGER_CUSTOM_H
+#define __LOGGER_CUSTOM_H
+
+#include <generated/autoconf.h>
+
+#define __MAIN_BUF_SIZE 32*1024 
+#define __EVENTS_BUF_SIZE 64*1024 
+#define __RADIO_BUF_SIZE 32*1024 
+#define __SYSTEM_BUF_SIZE 32*1024
+
+#endif /* __LOGGER_CUSTOM_H */
+
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/Makefile
new file mode 100755
index 0000000..c403b1d
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/Makefile
@@ -0,0 +1,5 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y := pmic_drv.o
+
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/codegen.dws b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/codegen.dws
new file mode 100755
index 0000000000000000000000000000000000000000..16fd6e4f463ec8365094cb96c68c4a8578747f46
GIT binary patch
literal 29635
zcmeHQ*_NX?67}r+zCPB&ypNrk-Cg}i0?zcLu{j32x}Nxr`ojK$`JNix5LX03EOu^P
zljs~2p-|{vDG<UewzK4L`q5&s__Nu5X|}BV`kU*ovc>mChn<^Ig9-IW+K)C{vsnDo
zD0lg0U+v4gYLg_JyDHu6$|~RNq@BtL#io6d6qLT7*u4xspGOk$v>V#N4jXmVWj3)U
zI1D5@Q~IuA_cHkO`Rn%dp=2G)|1bvG4e57fRpbv*mRIRc_QGFTRpe>(kRE84rfh#v
z@X#0=f(Q8*$CTX1gVO*lh7!A_eSEgRku8ejBrON|*mg)7I2jGODQW*Z`Qj)`4^b6o
zd150ho=x^M1q5r~Mqo%JL9nW8V~q{=PiwzEOxi<uHFPgF>UF?FI{T>W$O#*CEH^S2
z<I+sRk;Q<G`y@KWI_i)}u)B%x_R66sS3}DW(fTBjQBS>Adl=0;2r_C01}79a?MEgp
zr6+-m?PhG*F>an9E{q9vU1r=MLrLs`jO~a8$;3J>r(*xyIO=v&^ryxK9(k#24%9VK
zw%XLih`55GL2EsPt=llhQzc;OJ7e2O%rW7NXyhD|CKlAri3yKUwjGl*b~i%j#-xkT
zZ<(>XvH5?E3C6|aQO<d$jL~Zwb^1d3>9@vUKfGs2R4)BfKHLeTWynq&q@UU}tLB<v
zy^V_dYMUnJGF6eIz2+Oz>FaZ%ta$Ty`>^O<)S1hNz|{l!x)Z7$;)&cDxPhs%pRiO*
zQih~!3B^kutSb^HGz8cPLqC?abeDFUt9V%zNfZcGYd<|9S^Q#TtCt*^A$z%zUA^SU
z4B51iVa8#iaOOehtfP%(E%j`?o;tE8A{!qWdmfS)1?_r7)KRCF23KSoL@1P4@0t_F
zmkzOEVcQ`|TxqT_VMlWJ8jsPTtd588lB>`PG4&2vAB`pJ(3L%OLnG34fMuCFsUW+f
zyAF+x5L0A`hLj$i8C{T$5SP-S9Wk2OU^Ut=#kR<c#h;AgZV86Zu;My}r`2B)C@J+`
zhNmB)<7J8s(C~xwVA+*XY&vQ_;t|`eX3@47yltvMLi!XkH@EJJv|2qooqIBH_wleF
zWJBktY>XbHpIju1d{brnVl#G>`T!_%x9HAjKSo((Ak*#obl|a0V^enn`A-?$Rb^I;
z4TNAJc_vx>a1I%wrAf~uOGbB*2KUKON5Wcd2``Mv{+y9%VojuV&E}3QcM4oyLZ`<#
zG&YaUoFsyDytwd3<CjS_eRRPmA7gZvk1j}uUITI{aYWjOqlJySzsA$<M{1~yHhyxa
zz`MMtw!7fP4B8CghU$DCl-*VBHcqPBO=Qj|yL@aGA_$s*WdOpCL}^P+?$-B*JgFWI
z`wziMsGk=QT{CL^EVkgJ_;KA|qJj|#WlGjjHX~{@)cKQw{(X}8Y$_Opfw4~QxW)Tz
zFm8P;z8#>nQLl+abl8G%d(O{F>>VZIgoHAs?m6s!V%xEOBEZjtt^51b{hqO#S<HR?
zocr>vVY~Nc@Wz&TL+o^Wob<W!t;Gp*?={z$FD2d#6W1;Fn^NLfFXB9&>!K6RF3#<Y
zb;N^&jgs{Mla>y(QN$j|*!DHC*@vdLjTY##JHw;yHT#WTO8=VfIxW<1`s+S(A5x;7
z-W;G(LfE<u@nO@t_7Mz)NmcBDjBPcZ)>%(UJT2W-=wZDv4^M8*ZHc(^5QqSfnn3HQ
zL!z%OwetX3a%FdyG<O+6G=bK|@dC2dC1e}}JH@h=p^^1IrbI)I#+L-`BZI$;-pkNV
zOkWr_#|i1jf@O>iiN3bf&SmU@jBSXerMN3xmfOg6TxaZ7SOVd2`v-M8&eR!SNNz3A
zx*&dmjBSVqNt?JUT$X)&u?I4kuzktc9D|k^zh8z;C)A6Rm+5xUFNwEX7|pZ!n<-C2
zN%{n2;isV-EJwsWPGU$V+E~_7`~n%<5Z9N$ppP`yptT-=ZME?+S)Q>OiAH|OG0}am
zr$$SR%@a5`k!Uo6^vyriKL(q)l;oofVUv@+gbz30MqlD-`OXyNsqVH+t5b1^vI<{6
z%J&~a-!gJN@u^5j2?}vm5;mP2m>0YsI<~trA03m*yaYDs@gxF+fiXao3<w9!vX(7E
z^G08lZHm$7UqgfvdBZ@d$)I-$Cp>`Vh<ph^5>djY)9*~d&cZmW%)15NjF2MQV)OA?
zCLaA**7A?0AUuh=ax)V?@C`>cAEQD&5~VFQx!404OxW0MUjjjzDG8fS0a$4>hV65)
z3~cH%wvEIb6V8Z6&M|3XLG7HF@c4vedq`j)$+2hERu20g%qB}$vB~gOX7}Y|jjr`a
zGL0<9eN5U8-A}On-fU`2o4t*IxVsFBzddG1cv<&lf@hdsD0qfxdhq;UV$aY<9g@k-
zysSv#mHEzeGIci*RZF0v97;aZ^xZ@TObnva1}56b>OKhAF@?S+!RCGPa;m}msv)||
zsYdS?gAVXI!G^@HP#0sJbpv=kG%GZ`)~8UlX2o)B{%LfrhnVz$pnFV7vAuLmn$2ek
zFpVrodK_BUELzu$tsS+j#%8*P*Sdz+`Y_etOxN&Q*YH{&rW&2;nu5B9*ZMHkv(5DG
zzPh<|0%8Oh(ezP$^>S2SzZ}&!mr^l!3?Qcj%ig{+C;HnVDh<ck2T3^AlSWJN31n=e
z<x^u5j~pzsf3&l#CF;gv0zCK;7t%Fja~Qnz7;Hd2rr+!<F<2(9me6$?>o>8cN?_A>
z#<r1|W5OBH$k&Vsej7z@C@*fHo;Lf{`$b2)(l&JWzh=Wr=(`xDR(ekJuMLyED%k7_
zw@%>L!rREdFq{3cDp^Cg1fc3kI)yJcm-}OUU**v*-I|hJtN14LlaS0Hu>@9Ub4=!#
z==tz8hx0tECeJE-v&4LDQuYCtRY;sD<QtBi8hiyAUq<Xyyp5>iRDox;w@33mzrBq!
zPZJ2-+lazEO1tOfAgHrBCUZ>me3+Mli>@J>tEbPOU-yvu;q*jLtJjUm+>?2=pFiZh
z^xcuSam?eILw*Qf4l%v@;_eW>ZF!2eo1{~VkK}o_sed?qIa0ss)c?j<;;RSy>nh#m
zt?H51SHs}f!__yPYTS*(RmGgmF_`DUd>9Na1-~-2Sz>>aYH`zZ&cH0fa+*ixheFL?
z47>+q-=&K0{Oyo4f23rxkL~Z3bYro^>M!@<(=0dt5>Xxx=>l&kmrZ%K_?Iz6NnEXy
zq&lq4-Foxtd{HGIcM;bA_*j(ttcveBo;n7#0K<fX$aqO=T=Bym=q$F=etXQ)W4^#?
z!4{JJhus3V#diB$dZ7a7M?!R)&!BHPrkL*b0pJ3MrcO8@aBOv_%nMlF9x+3Yuw#kC
zZ#^a3>LLBOYOg8n$}4}3X;)v%O?tbBfsCU)OUnqj&7MWH4{5wVrH7AF(^|xUxQ^m-
zUsrmI8hr8W)gV@8$!j&mNd$JRfnF8-P$dha2PtE)%|g{|x=q(*GYDV+Fiv-6dT8wI
z!(nrGuiVKI?|19XA#41JejAw|5O7l+BV<i`Ehmr}W4l5H#lf&MHXzP?X5ZP7b^v7B
zn13O=zIvZ$$1InBB{SW&5A@AH_(UkktCXUc42M5{<1ULfyQ=<=ANvKfNREB{rd4sg
z^{enBH&`xq|F)1*bWokl8}jzz2=8+;p=Jug6d$tKYpmyD!MXlq!c|3U8HCS+_yj__
zme=YL?`}-j^3|>>L)1Q)K&QJr98<i*A4hp*Us^aNi5#Z7`MJ8#ZEg<+xI2%|1?%&d
zU1)-v1X;qfHIZ2zoUMuciB%t2pWW?Y^YVUZu;D#yobmEua1Wb0{F`4NVV@m`y8Q%c
z7SMO5faRt>QZdD3N}2DZn-8?n&b*dVEoIGGe)?uDF;T9Vt(X%bZ}Zv@)}Y$kOwV4=
z>sT%g+{EfQuIdh4zn9l?-qktg&hpc8d4>@?!8~8y75hVn<*H^`rm~2c$J2Sy>vZ#N
zfYrR!glDpy{$UT=|M|0j=x6@yuLFF|G2XT?aE4uenoaNI+UofufrAFq_Wna<PUGca
Kzm;M!wfH|~YAy8u

literal 0
HcmV?d00001

diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/cust_eint.dtsi b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/cust_eint.dtsi
new file mode 100644
index 0000000..859879d
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/cust_eint.dtsi
@@ -0,0 +1,68 @@
+/*
+ * Generated by MTK SP Drv_CodeGen Version 03.13.6  for MT6735M. Copyright MediaTek Inc. (C) 2013.
+ * Mon Apr 25 22:47:33 2016
+ * Do Not Modify the File.
+ */
+
+/*************************
+ * EINT DTSI File
+*************************/
+
+&eintc {
+	IRQ_NFC@2 {
+		compatible = "mediatek, IRQ_NFC-eint";
+		interrupt-parent = <&eintc>;
+		interrupts = <2 4>;
+		debounce = <2 0>;
+	};
+
+	MSDC1_INS@5 {
+		compatible = "mediatek, MSDC1_INS-eint";
+		interrupt-parent = <&eintc>;
+		interrupts = <5 8>;
+		debounce = <5 1000>;
+	};
+
+	ACCDET@6 {
+		compatible = "mediatek, ACCDET-eint";
+		interrupt-parent = <&eintc>;
+		interrupts = <6 8>;
+		debounce = <6 256000>;
+	};
+
+	TOUCH_PANEL@10 {
+		compatible = "mediatek, TOUCH_PANEL-eint";
+		interrupt-parent = <&eintc>;
+		interrupts = <10 2>;
+		debounce = <10 0>;
+	};
+
+	ALS@65 {
+		compatible = "mediatek, ALS-eint";
+		interrupt-parent = <&eintc>;
+		interrupts = <65 8>;
+		debounce = <65 0>;
+	};
+
+	GSE_1@66 {
+		compatible = "mediatek, GSE_1-eint";
+		interrupt-parent = <&eintc>;
+		interrupts = <66 8>;
+		debounce = <66 0>;
+	};
+
+	GYRO@67 {
+		compatible = "mediatek, GYRO-eint";
+		interrupt-parent = <&eintc>;
+		interrupts = <67 8>;
+		debounce = <67 0>;
+	};
+
+	EXT_BUCK_OC@78 {
+		compatible = "mediatek, EXT_BUCK_OC-eint";
+		interrupt-parent = <&eintc>;
+		interrupts = <78 4>;
+		debounce = <78 0>;
+	};
+
+};
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/cust_i2c.dtsi b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/cust_i2c.dtsi
new file mode 100644
index 0000000..5c45dcf
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/cust_i2c.dtsi
@@ -0,0 +1,82 @@
+/*
+ * Generated by MTK SP Drv_CodeGen Version 03.13.6  for MT6735M. Copyright MediaTek Inc. (C) 2013.
+ * Mon Apr 25 22:47:34 2016
+ * Do Not Modify the File.
+ */
+
+/*************************
+ * I2C DTSI File
+*************************/
+
+&i2c0 {
+	CAMERA_MAIN@10 {
+		compatible = "mediatek,CAMERA_MAIN";
+		reg = <0x10>;
+	};
+
+	CAMERA_MAIN_AF@0C {
+		compatible = "mediatek,CAMERA_MAIN_AF";
+		reg = <0x0C>;
+	};
+
+	CAMERA_SUB@3C {
+		compatible = "mediatek,CAMERA_SUB";
+		reg = <0x3C>;
+	};
+
+};
+
+&i2c1 {
+	CAP_TOUCH@5D {
+		compatible = "mediatek,CAP_TOUCH";
+		reg = <0x5D>;
+	};
+
+	I2C_LCD_BIAS@3E {
+		compatible = "mediatek,I2C_LCD_BIAS";
+		reg = <0x3E>;
+	};
+
+};
+
+&i2c2 {
+	MSENSOR@0D {
+		compatible = "mediatek,MSENSOR";
+		reg = <0x0D>;
+	};
+
+	GYRO@68 {
+		compatible = "mediatek,GYRO";
+		reg = <0x68>;
+	};
+
+	GSENSOR@4C {
+		compatible = "mediatek,GSENSOR";
+		reg = <0x4C>;
+	};
+
+	ALSPS@60 {
+		compatible = "mediatek,ALSPS";
+		reg = <0x60>;
+	};
+
+	NFC@28 {
+		compatible = "mediatek,NFC";
+		reg = <0x28>;
+	};
+
+	STROBE_MAIN@63 {
+		compatible = "mediatek,STROBE_MAIN";
+		reg = <0x63>;
+	};
+
+};
+
+&i2c3 {
+	EXT_BUCK@6B {
+		compatible = "mediatek,EXT_BUCK";
+		reg = <0x6B>;
+	};
+
+};
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/pmic_drv.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/pmic_drv.c
new file mode 100644
index 0000000..baddb12
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/dct/dct/pmic_drv.c
@@ -0,0 +1,22 @@
+/*
+ * Generated by MTK SP Drv_CodeGen Version 03.13.6  for MT6735M. Copyright MediaTek Inc. (C) 2013.
+ * Mon Apr 25 22:47:32 2016
+ * Do Not Modify the File.
+ */
+
+
+
+#include <linux/types.h>
+#include <mach/mt_typedefs.h>
+#include <mach/upmu_common.h>
+#include <mach/upmu_hw.h>
+#include <mach/mt_pm_ldo.h>
+
+
+void pmu_drv_tool_customization_init(void)
+{
+}
+
+
+
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/gyroscope/ITG1010-new/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/gyroscope/ITG1010-new/Makefile
new file mode 100755
index 0000000..26ccc82
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/gyroscope/ITG1010-new/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y	:=  cust_gyro.o
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/gyroscope/ITG1010-new/cust_gyro.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/gyroscope/ITG1010-new/cust_gyro.c
new file mode 100755
index 0000000..30123d3
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/gyroscope/ITG1010-new/cust_gyro.c
@@ -0,0 +1,19 @@
+#include <linux/types.h>
+#include <mach/mt_pm_ldo.h>
+#include <cust_gyro.h>
+
+/*---------------------------------------------------------------------------*/
+static struct gyro_hw cust_gyro_hw = {
+    .i2c_num = 2,
+	.i2c_addr = {0x68,0,0,0},
+    .direction = 3,
+    .power_id = MT65XX_POWER_NONE,  /*!< LDO is not used */
+    .power_vol= VOL_DEFAULT,        /*!< LDO is not used */
+    .firlen = 0,                   /*!< don't enable low pass fileter */
+    .is_batch_supported = false,
+};
+/*---------------------------------------------------------------------------*/
+struct gyro_hw* get_cust_gyro_hw(void) 
+{
+    return &cust_gyro_hw;
+}
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/Makefile
new file mode 100755
index 0000000..1808e1d
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y := mtk_kpd_bkl.o
+
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/mtk_kpd.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/mtk_kpd.h
new file mode 100755
index 0000000..60ca1f7
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/mtk_kpd.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2010 MediaTek, Inc.
+ *
+ * Author: Terry Chang <terry.chang@mediatek.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _MTK_KPD_H_
+#define _MTK_KPD_H_
+
+#include <linux/kernel.h>
+#include <cust_kpd.h>
+#include <mach/mt_pm_ldo.h>
+#include <linux/delay.h>
+/* include PMIC header file */
+#include <mach/mt_typedefs.h>
+#include <mach/upmu_common_sw.h>
+#include <mach/upmu_hw.h>
+
+#define KPD_PWRKEY_USE_EINT KPD_NO
+#define KPD_PWRKEY_USE_PMIC KPD_YES
+#define KPD_DRV_CTRL_BACKLIGHT	KPD_NO	/* retired, move to Lights framework */
+#define KPD_BACKLIGHT_TIME	8	/* sec */
+/* the keys can wake up the system and we should enable backlight */
+#define KPD_BACKLIGHT_WAKE_KEY	\
+{				\
+	KEY_ENDCALL, KEY_POWER,	\
+}
+
+#define KPD_HAS_SLIDE_QWERTY	KPD_NO
+#if KPD_HAS_SLIDE_QWERTY
+static inline bool powerOn_slidePin_interface() {
+	return hwPowerOn(MT65XX_POWER_LDO_VCAM_IO, VOL_2800, "Qwerty slide");
+}
+static inline bool powerOff_slidePin_interface(){
+	return hwPowerDown(MT65XX_POWER_LDO_VCAM_IO, "Qwerty slide");
+}
+#endif
+#define KPD_SLIDE_EINT		CUST_EINT_KPD_SLIDE_NUM
+#define KPD_SLIDE_DEBOUNCE	CUST_EINT_KPD_SLIDE_DEBOUNCE_CN		/* ms */
+#define KPD_SLIDE_POLARITY	CUST_EINT_KPD_SLIDE_POLARITY
+#define KPD_SLIDE_SENSITIVE	CUST_EINT_KPD_SLIDE_SENSITIVE
+
+#if KPD_DRV_CTRL_BACKLIGHT
+extern void kpd_enable_backlight(void);
+extern void kpd_disable_backlight(void);
+extern void kpd_backlight_handler(bool pressed, u16 linux_keycode);
+#else
+#define kpd_enable_backlight()		do {} while (0)
+#define kpd_disable_backlight()		do {} while (0)
+#define kpd_backlight_handler(pressed, linux_keycode)	do {} while (0)
+#endif
+
+/* for META tool */
+extern void kpd_set_backlight(bool onoff, void *val1, void *val2);
+
+#if KPD_PWRKEY_USE_PMIC
+void kpd_pwrkey_pmic_handler(unsigned long pressed);
+#else
+static inline void kpd_pwrkey_pmic_handler(unsigned long data){}
+#endif
+
+void kpd_pmic_rstkey_handler(unsigned long pressed);
+
+//#define ONEKEY_REBOOT_NORMAL_MODE
+#define TWOKEY_REBOOT_NORMAL_MODE
+//#define ONEKEY_REBOOT_OTHER_MODE
+#define TWOKEY_REBOOT_OTHER_MODE
+/* KPD_PMIC_RSTKEY_MAP is defined in cust_kpd.h */
+#define KPD_PMIC_LPRST_TD 1 /* timeout period. 0: 8sec; 1: 11sec; 2: 14sec; 3: 5sec */
+
+#endif
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/mtk_kpd_bkl.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/mtk_kpd_bkl.c
new file mode 100755
index 0000000..3b81032
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/keypad/mtk_kpd_bkl.c
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2010 MediaTek, Inc.
+ *
+ * Author: Terry Chang <terry.chang@mediatek.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <mach/mt_typedefs.h>
+#include <mtk_kpd.h>		/* custom file */
+
+#if KPD_DRV_CTRL_BACKLIGHT
+void kpd_enable_backlight(void)
+{
+	/*mt6326_kpled_dim_duty_Full();
+	mt6326_kpled_Enable();*/
+}
+
+void kpd_disable_backlight(void)
+{
+	/*mt6326_kpled_dim_duty_0();
+	mt6326_kpled_Disable();*/
+}
+#endif
+
+/* for META tool */
+void kpd_set_backlight(bool onoff, void *val1, void *val2)
+{
+	/*u8 div = *(u8 *)val1;
+	u8 duty = *(u8 *)val2;
+
+	if (div > 15)
+		div = 15;
+	pmic_kp_dim_div(div);
+
+	if (duty > 31)
+		duty = 31;
+	pmic_kp_dim_duty(duty);
+
+	if (onoff)
+		mt6326_kpled_Enable();
+	else
+		mt6326_kpled_Disable();*/
+}
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/Makefile
new file mode 100644
index 0000000..a9f5d68
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/Makefile
@@ -0,0 +1,21 @@
+
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+# Vanzo:wangfei on: Wed, 12 Nov 2014 21:06:42 +0800
+project_name:=$(shell echo $(VANZO_INNER_PROJECT_NAME))
+ifneq ($(project_name),)
+custom_kernel_leds:= $(addsuffix /, $(shell echo $(CUSTOM_KERNEL_LEDS)))
+$(info "the custom_kernel_leds:$(custom_kernel_leds)")
+ifneq ($(custom_kernel_leds),)
+obj-y += $(custom_kernel_leds)
+else
+$(info "Warning!Why custom_kernel_leds is empty?")
+endif
+else
+# End of Vanzo:wangfei
+obj-$(CONFIG_MTK_LEDS) += mt65xx/
+
+# Vanzo:wangfei on: Wed, 14 Jan 2015 17:37:53 +0800
+# for add leds custom
+endif
+# End of Vanzo:wangfei
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/Makefile
new file mode 100755
index 0000000..4f5a339
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/Makefile
@@ -0,0 +1,2 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-y := cust_leds.o
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds.c
new file mode 100644
index 0000000..e5d55be
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds.c
@@ -0,0 +1,120 @@
+#include <cust_leds.h>
+#include <cust_leds_def.h>
+#include <mach/mt_pwm.h>
+
+#include <linux/kernel.h>
+#include <mach/upmu_common_sw.h>
+#include <mach/upmu_hw.h>
+
+//extern int mtkfb_set_backlight_level(unsigned int level);
+//extern int mtkfb_set_backlight_pwm(int div);
+extern int disp_bls_set_backlight(unsigned int level);
+
+// Only support 64 levels of backlight (when lcd-backlight = MT65XX_LED_MODE_PWM)
+#define BACKLIGHT_LEVEL_PWM_64_FIFO_MODE_SUPPORT 64 
+// Support 256 levels of backlight (when lcd-backlight = MT65XX_LED_MODE_PWM)
+#define BACKLIGHT_LEVEL_PWM_256_SUPPORT 256 
+
+// Configure the support type "BACKLIGHT_LEVEL_PWM_256_SUPPORT" or "BACKLIGHT_LEVEL_PWM_64_FIFO_MODE_SUPPORT" !!
+#define BACKLIGHT_LEVEL_PWM_MODE_CONFIG BACKLIGHT_LEVEL_PWM_256_SUPPORT
+
+unsigned int Cust_GetBacklightLevelSupport_byPWM(void)
+{
+	return BACKLIGHT_LEVEL_PWM_MODE_CONFIG;
+}
+
+unsigned int brightness_mapping(unsigned int level)
+{
+    unsigned int mapped_level;
+    
+    mapped_level = level;
+       
+	return mapped_level;
+}
+/*
+
+ * To explain How to set these para for cust_led_list[] of led/backlight
+ * "name" para: led or backlight
+ * "mode" para:which mode for led/backlight
+ *	such as:
+ *			MT65XX_LED_MODE_NONE,	
+ *			MT65XX_LED_MODE_PWM,	
+ *			MT65XX_LED_MODE_GPIO,	
+ *			MT65XX_LED_MODE_PMIC,	
+ *			MT65XX_LED_MODE_CUST_LCM,	
+ *			MT65XX_LED_MODE_CUST_BLS_PWM
+ *
+ *"data" para: control methord for led/backlight
+ *   such as:
+ *			MT65XX_LED_PMIC_LCD_ISINK=0,	
+ *			MT65XX_LED_PMIC_NLED_ISINK0,
+ *			MT65XX_LED_PMIC_NLED_ISINK1,
+ *			MT65XX_LED_PMIC_NLED_ISINK2,
+ *			MT65XX_LED_PMIC_NLED_ISINK3
+ * 
+ *"PWM_config" para:PWM(AP side Or BLS module), by default setting{0,0,0,0,0} Or {0}
+ *struct PWM_config {	 
+ *  int clock_source;
+ *  int div; 
+ *  int low_duration;
+ *  int High_duration;
+ *  BOOL pmic_pad;//AP side PWM pin in PMIC chip (only 89 needs confirm); 1:yes 0:no(default)
+ *};
+ *-------------------------------------------------------------------------------------------
+ *   for AP PWM setting as follow:
+ *1.	 PWM config data
+ *  clock_source: clock source frequency, can be 0/1
+ *  div: clock division, can be any value within 0~7 (i.e. 1/2^(div) = /1, /2, /4, /8, /16, /32, /64, /128)
+ *  low_duration: only for BACKLIGHT_LEVEL_PWM_64_FIFO_MODE_SUPPORT
+ *  High_duration: only for BACKLIGHT_LEVEL_PWM_64_FIFO_MODE_SUPPORT
+ *
+ *2.	 PWM freq.
+ * If BACKLIGHT_LEVEL_PWM_MODE_CONFIG = BACKLIGHT_LEVEL_PWM_256_SUPPORT,
+ *	 PWM freq. = clock source / 2^(div) / 256  
+ *
+ * If BACKLIGHT_LEVEL_PWM_MODE_CONFIG = BACKLIGHT_LEVEL_PWM_64_FIFO_MODE_SUPPORT,
+ *	 PWM freq. = clock source / 2^(div) / [(High_duration+1)(Level')+(low_duration+1)(64 - Level')]
+ *	           = clock source / 2^(div) / [(High_duration+1)*64]     (when low_duration = High_duration)
+ *Clock source: 
+ *	 0: block clock/1625 = 26M/1625 = 16K (MT6571)
+ *	 1: block clock = 26M (MT6571)
+ *Div: 0~7
+ *
+ *For example, in MT6571, PWM_config = {1,1,0,0,0} 
+ *	 ==> PWM freq. = 26M/2^1/256 	 =	50.78 KHz ( when BACKLIGHT_LEVEL_PWM_256_SUPPORT )
+ *	 ==> PWM freq. = 26M/2^1/(0+1)*64 = 203.13 KHz ( when BACKLIGHT_LEVEL_PWM_64_FIFO_MODE_SUPPORT )
+ *-------------------------------------------------------------------------------------------
+ *   for BLS PWM setting as follow:
+ *1.	 PWM config data
+ *	 clock_source: clock source frequency, can be 0/1/2/3
+ *	 div: clock division, can be any value within 0~1023
+ *	 low_duration: non-use
+ *	 High_duration: non-use
+ *	 pmic_pad: non-use
+ *
+ *2.	 PWM freq.= clock source / (div + 1) /1024
+ *Clock source: 
+ *	 0: 26 MHz
+ *	 1: 104 MHz
+ *	 2: 124.8 MHz
+ *	 3: 156 MHz
+ *Div: 0~1023
+ *
+ *By default, clock_source = 0 and div = 0 => PWM freq. = 26 KHz 
+ *-------------------------------------------------------------------------------------------
+ */
+static struct cust_mt65xx_led cust_led_list[MT65XX_LED_TYPE_TOTAL] = {
+	{"red",               MT65XX_LED_MODE_NONE, -1,{0}},
+	{"green",             MT65XX_LED_MODE_NONE, -1,{0}},
+	{"blue",              MT65XX_LED_MODE_NONE, -1,{0}},
+	{"jogball-backlight", MT65XX_LED_MODE_NONE, -1,{0}},
+	{"keyboard-backlight",MT65XX_LED_MODE_NONE, -1,{0}},
+	{"button-backlight",  MT65XX_LED_MODE_NONE, -1,{0}},
+	{"lcd-backlight",     MT65XX_LED_MODE_CUST_BLS_PWM, (long)disp_bls_set_backlight,{0}},
+};
+
+struct cust_mt65xx_led *get_cust_led_list(void)
+{
+	return cust_led_list;
+}
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds.h
new file mode 100644
index 0000000..2fd2873
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds.h
@@ -0,0 +1,20 @@
+#ifndef _CUST_LEDS_H
+#define _CUST_LEDS_H
+
+#include <mach/mt_typedefs.h>
+enum mt65xx_led_type
+{
+	MT65XX_LED_TYPE_RED = 0,
+	MT65XX_LED_TYPE_GREEN,
+	MT65XX_LED_TYPE_BLUE,
+	MT65XX_LED_TYPE_JOGBALL,
+	MT65XX_LED_TYPE_KEYBOARD,
+	MT65XX_LED_TYPE_BUTTON,	
+	MT65XX_LED_TYPE_LCD,
+	MT65XX_LED_TYPE_TOTAL,
+};
+
+
+
+#endif
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds_def.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds_def.h
new file mode 100644
index 0000000..de34956
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/leds/mt65xx/cust_leds_def.h
@@ -0,0 +1,53 @@
+#ifndef _CUST_LEDS_DEF_H
+#define _CUST_LEDS_DEF_H
+
+//#define CUST_LEDS_BACKLIGHT_PMIC_PARA /* parallel */
+//#define CUST_LEDS_BACKLIGHT_PMIC_SERI /* series */
+enum mt65xx_led_mode
+{
+	MT65XX_LED_MODE_NONE,
+	MT65XX_LED_MODE_PWM,
+	MT65XX_LED_MODE_GPIO,
+	MT65XX_LED_MODE_PMIC,
+	//MT65XX_LED_MODE_CUST,
+	MT65XX_LED_MODE_CUST_LCM,	
+	MT65XX_LED_MODE_CUST_BLS_PWM
+};
+
+enum mt65xx_led_pmic
+{
+	MT65XX_LED_PMIC_LCD_ISINK=0,
+	MT65XX_LED_PMIC_NLED_ISINK0,
+	MT65XX_LED_PMIC_NLED_ISINK1,
+	MT65XX_LED_PMIC_NLED_ISINK2,
+	MT65XX_LED_PMIC_NLED_ISINK3
+};
+struct PWM_config
+{
+	int clock_source;
+	int div;
+	int low_duration;
+	int High_duration;
+	BOOL pmic_pad;
+};
+typedef int (*cust_brightness_set)(int level, int div);
+typedef int (*cust_set_brightness)(int level);
+
+/*
+ * name : must the same as lights HAL
+ * mode : control mode
+ * data :
+ *    PWM:  pwm number
+ *    GPIO: gpio id
+ *    PMIC: enum mt65xx_led_pmic
+ *    CUST: custom set brightness function pointer
+*/
+struct cust_mt65xx_led {
+	char                 *name;
+	enum mt65xx_led_mode  mode;
+	long                   data;
+ struct PWM_config config_data;
+};
+
+extern struct cust_mt65xx_led *get_cust_led_list(void);
+#endif /* _CUST_LEDS_DEF_H */
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/akm09911-new/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/akm09911-new/Makefile
new file mode 100755
index 0000000..b27cc86
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/akm09911-new/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y	:=  cust_mag.o
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/akm09911-new/cust_mag.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/akm09911-new/cust_mag.c
new file mode 100755
index 0000000..06e1393
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/akm09911-new/cust_mag.c
@@ -0,0 +1,17 @@
+#include <linux/types.h>
+#include <mach/mt_pm_ldo.h>
+#include <cust_mag.h>
+
+
+static struct mag_hw cust_mag_hw = {
+    .i2c_num = 2,
+	.i2c_addr = {0x0D,0,0,0},
+    .direction = 1,
+    .power_id = MT65XX_POWER_NONE,  /*!< LDO is not used */
+    .power_vol= VOL_DEFAULT,        /*!< LDO is not used */
+    .is_batch_supported = false,
+};
+struct mag_hw* get_cust_mag_hw(void) 
+{
+    return &cust_mag_hw;
+}
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/mmc3416x/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/mmc3416x/Makefile
new file mode 100755
index 0000000..b27cc86
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/mmc3416x/Makefile
@@ -0,0 +1,4 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y	:=  cust_mag.o
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/mmc3416x/cust_mag.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/mmc3416x/cust_mag.c
new file mode 100644
index 0000000..283dfc6
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/magnetometer/mmc3416x/cust_mag.c
@@ -0,0 +1,17 @@
+#include <linux/types.h>
+#include <mach/mt_pm_ldo.h>
+#include <cust_mag.h>
+
+
+static struct mag_hw cust_mag_hw = {
+    .i2c_num = 2,
+	.i2c_addr = {0x30,0,0,0},
+    .direction = 1,
+    .power_id = MT65XX_POWER_NONE,  /*!< LDO is not used */
+    .power_vol= VOL_DEFAULT,        /*!< LDO is not used */
+    .is_batch_supported = false,
+};
+struct mag_hw* get_cust_mag_hw(void) 
+{
+    return &cust_mag_hw;
+}
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_battery_meter.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_battery_meter.h
new file mode 100644
index 0000000..580ee9d
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_battery_meter.h
@@ -0,0 +1,127 @@
+#ifndef _CUST_BATTERY_METER_H
+#define _CUST_BATTERY_METER_H
+
+#include <mach/mt_typedefs.h>
+
+// ============================================================
+// define
+// ============================================================
+//#define SOC_BY_AUXADC
+//#define SOC_BY_HW_FG //100%
+#define SOC_BY_SW_FG
+
+//#define CONFIG_DIS_CHECK_BATTERY
+//#define FIXED_TBAT_25
+
+/* ADC resistor  */
+#define R_BAT_SENSE 4					
+#define R_I_SENSE 4						
+#define R_CHARGER_1 330
+#define R_CHARGER_2 39
+
+#define TEMPERATURE_T0             110
+#define TEMPERATURE_T1             0
+#define TEMPERATURE_T2             25
+#define TEMPERATURE_T3             50
+#define TEMPERATURE_T              255 // This should be fixed, never change the value
+
+#define FG_METER_RESISTANCE 	0
+
+/* Qmax for battery  */
+#define Q_MAX_POS_50	1952
+#define Q_MAX_POS_25	1906
+#define Q_MAX_POS_0	1952
+#define Q_MAX_NEG_10	1975
+
+#define Q_MAX_POS_50_H_CURRENT	1837
+#define Q_MAX_POS_25_H_CURRENT	1889
+#define Q_MAX_POS_0_H_CURRENT	1837
+#define Q_MAX_NEG_10_H_CURRENT	1603
+
+
+/* Discharge Percentage */
+#define OAM_D5		 1		//  1 : D5,   0: D2
+
+
+/* battery meter parameter */
+#define CHANGE_TRACKING_POINT
+#ifdef CONFIG_MTK_HAFG_20
+#define CUST_TRACKING_POINT  0
+#else
+#define CUST_TRACKING_POINT  1
+#endif
+#define CUST_R_SENSE         10//20//20mO for k05ss
+#define CUST_HW_CC 		    0
+#define AGING_TUNING_VALUE   103
+#define CUST_R_FG_OFFSET    0
+
+#define OCV_BOARD_COMPESATE	0 //mV 
+#define R_FG_BOARD_BASE		1000
+#define R_FG_BOARD_SLOPE	1000 //slope
+#define CAR_TUNE_VALUE		100 //1.00
+
+
+/* HW Fuel gague  */
+#define CURRENT_DETECT_R_FG	10  //1mA
+#define MinErrorOffset       1000
+#define FG_VBAT_AVERAGE_SIZE 18
+#define R_FG_VALUE 			10 // mOhm, base is 20
+
+/* fg 2.0 */
+#define DIFFERENCE_HWOCV_RTC		30
+#define DIFFERENCE_HWOCV_SWOCV		10
+#define DIFFERENCE_SWOCV_RTC		10
+#define MAX_SWOCV			3
+
+#define DIFFERENCE_VOLTAGE_UPDATE	20
+#define AGING1_LOAD_SOC			70
+#define AGING1_UPDATE_SOC		30
+#define BATTERYPSEUDO100		95
+#define BATTERYPSEUDO1			4
+
+#define Q_MAX_BY_SYS			//8. Qmax varient by system drop voltage.
+#define SHUTDOWN_GAUGE0
+#define SHUTDOWN_GAUGE1_XMINS
+#define SHUTDOWN_GAUGE1_MINS		60
+
+#define SHUTDOWN_SYSTEM_VOLTAGE		3400
+#define CHARGE_TRACKING_TIME		60
+#define DISCHARGE_TRACKING_TIME		10
+
+#define RECHARGE_TOLERANCE		10
+/* SW Fuel Gauge */
+#define MAX_HWOCV			5
+#define MAX_VBAT			90
+#define DIFFERENCE_HWOCV_VBAT		30
+
+/* fg 1.0 */
+#define CUST_POWERON_DELTA_CAPACITY_TOLRANCE	5//30
+#define CUST_POWERON_LOW_CAPACITY_TOLRANCE		5
+#define CUST_POWERON_MAX_VBAT_TOLRANCE			90
+#define CUST_POWERON_DELTA_VBAT_TOLRANCE		30
+#define CUST_POWERON_DELTA_HW_SW_OCV_CAPACITY_TOLRANCE	10
+
+
+/* Disable Battery check for HQA */
+#ifdef CONFIG_MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION
+#define FIXED_TBAT_25
+#endif
+
+/* Dynamic change wake up period of battery thread when suspend*/
+#define VBAT_NORMAL_WAKEUP		3600		//3.6V
+#define VBAT_LOW_POWER_WAKEUP		3500		//3.5v
+#define NORMAL_WAKEUP_PERIOD		5400 		//90 * 60 = 90 min
+#define LOW_POWER_WAKEUP_PERIOD		300		//5 * 60 = 5 min
+#define CLOSE_POWEROFF_WAKEUP_PERIOD	30	//30 s
+
+#define INIT_SOC_BY_SW_SOC
+//#define SYNC_UI_SOC_IMM			//3. UI SOC sync to FG SOC immediately
+#define MTK_ENABLE_AGING_ALGORITHM	//6. Q_MAX aging algorithm
+#define MD_SLEEP_CURRENT_CHECK	//5. Gauge Adjust by OCV 9. MD sleep current check
+//#define Q_MAX_BY_CURRENT		//7. Qmax varient by current loading.
+
+#define FG_BAT_INT
+#define IS_BATTERY_REMOVE_BY_PMIC
+
+
+#endif	//#ifndef _CUST_BATTERY_METER_H
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_battery_meter_table.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_battery_meter_table.h
new file mode 100644
index 0000000..b54d7db
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_battery_meter_table.h
@@ -0,0 +1,1108 @@
+#ifndef _CUST_BATTERY_METER_TABLE_H
+#define _CUST_BATTERY_METER_TABLE_H
+
+#include <mach/mt_typedefs.h>
+
+// ============================================================
+// define
+// ============================================================
+#define BAT_NTC_10 1
+#define BAT_NTC_47 0
+
+#if (BAT_NTC_10 == 1)
+#define RBAT_PULL_UP_R             24000	
+#endif
+
+#if (BAT_NTC_47 == 1)
+#define RBAT_PULL_UP_R             61900	
+#endif
+
+#define RBAT_PULL_UP_VOLT          2800
+
+
+
+// ============================================================
+// ENUM
+// ============================================================
+
+// ============================================================
+// structure
+// ============================================================
+
+// ============================================================
+// typedef
+// ============================================================
+typedef struct _BATTERY_PROFILE_STRUC
+{
+    kal_int32 percentage;
+    kal_int32 voltage;
+} BATTERY_PROFILE_STRUC, *BATTERY_PROFILE_STRUC_P;
+
+typedef struct _R_PROFILE_STRUC
+{
+    kal_int32 resistance; // Ohm
+    kal_int32 voltage;
+} R_PROFILE_STRUC, *R_PROFILE_STRUC_P;
+
+typedef enum
+{
+    T1_0C,
+    T2_25C,
+    T3_50C
+} PROFILE_TEMPERATURE;
+
+// ============================================================
+// External Variables
+// ============================================================
+
+// ============================================================
+// External function
+// ============================================================
+
+// ============================================================
+// <DOD, Battery_Voltage> Table
+// ============================================================
+#if (BAT_NTC_10 == 1)
+    BATT_TEMPERATURE Batt_Temperature_Table[] = {
+        {-20,68237},
+        {-15,53650},
+        {-10,42506},
+        { -5,33892},
+        {  0,27219},
+        {  5,22021},
+        { 10,17926},
+        { 15,14674},
+        { 20,12081},
+        { 25,10000},
+        { 30,8315},
+        { 35,6948},
+        { 40,5834},
+        { 45,4917},
+        { 50,4161},
+        { 55,3535},
+        { 60,3014}
+    };
+#endif
+
+#if (BAT_NTC_47 == 1)
+    BATT_TEMPERATURE Batt_Temperature_Table[] = {
+        {-20,483954},
+        {-15,360850},
+        {-10,271697},
+        { -5,206463},
+        {  0,158214},
+        {  5,122259},
+        { 10,95227},
+        { 15,74730},
+        { 20,59065},
+        { 25,47000},
+        { 30,37643},
+        { 35,30334},
+        { 40,24591},
+        { 45,20048},
+        { 50,16433},
+        { 55,13539},
+        { 60,11210}        
+    };
+#endif
+// T0 -10C
+BATTERY_PROFILE_STRUC battery_profile_t0[] =
+{
+	{0 , 4098},
+	{2 , 4069},
+	{3 , 4053},
+	{5 , 4040},
+	{7 , 4023},
+	{8 , 3997},
+	{10 , 3961},
+	{12 , 3946},
+	{13 , 3938},
+	{15 , 3932},
+	{17 , 3926},
+	{19 , 3918},
+	{20 , 3910},
+	{22 , 3901},
+	{23 , 3894},
+	{25 , 3885},
+	{27 , 3874},
+	{29 , 3866},
+	{30 , 3856},
+	{32 , 3846},
+	{34 , 3838},
+	{35 , 3830},
+	{37 , 3823},
+	{39 , 3817},
+	{40 , 3814},
+	{42 , 3808},
+	{44 , 3806},
+	{45 , 3803},
+	{47 , 3801},
+	{49 , 3798},
+	{50 , 3795},
+	{52 , 3796},
+	{54 , 3795},
+	{55 , 3792},
+	{57 , 3792},
+	{59 , 3790},
+	{60 , 3789},
+	{62 , 3787},
+	{64 , 3785},
+	{65 , 3783},
+	{67 , 3781},
+	{69 , 3776},
+	{70 , 3772},
+	{72 , 3767},
+	{74 , 3763},
+	{76 , 3758},
+	{77 , 3751},
+	{79 , 3742},
+	{81 , 3734},
+	{82 , 3725},
+	{84 , 3719},
+	{86 , 3715},
+	{87 , 3712},
+	{89 , 3707},
+	{91 , 3702},
+	{92 , 3696},
+	{94 , 3678},
+	{96 , 3647},
+	{97 , 3612},
+	{98 , 3575},
+	{98 , 3537},
+	{99 , 3502},
+	{99 , 3472},
+	{100 , 3443},
+	{100 , 3419},
+	{100 , 3395},
+	{100 , 3373},
+	{100 , 3357},
+	{100 , 3341},
+	{100 , 3328},
+	{100 , 3317},
+	{100 , 3307},
+	{100 , 3300},
+	{100 , 3293},
+	{100 , 3288},
+	{100 , 3283},
+	{100 , 3275},
+	{100 , 3271},
+	{100 , 3267},
+	{100 , 3260},
+	{100 , 3256},
+	{100 , 3251},
+	{100 , 3243},
+	{100 , 3239},
+	{100 , 3233},
+	{100 , 3225},
+	{100 , 3218},
+	{100 , 3214},
+	{100 , 3209},
+	{100 , 3202},
+	{100 , 3196},
+	{100 , 3185},
+	{100 , 3171},
+	{100 , 3157},
+	{100 , 3142},
+	{100 , 3125},
+	{100 , 3114},
+	{100 , 3095},
+	{100 , 3095},
+	{100 , 3270}
+};
+
+
+// T1 0C
+BATTERY_PROFILE_STRUC battery_profile_t1[] =
+{
+	{0 , 4048},
+	{2 , 4008},
+	{3 , 3989},
+	{5 , 3977},
+	{6 , 3966},
+	{8 , 3960},
+	{9 , 3956},
+	{11 , 3951},
+	{13 , 3948},
+	{14 , 3941},
+	{16 , 3935},
+	{17 , 3928},
+	{19 , 3922},
+	{20 , 3914},
+	{22 , 3906},
+	{24 , 3898},
+	{25 , 3892},
+	{27 , 3882},
+	{28 , 3872},
+	{30 , 3860},
+	{31 , 3849},
+	{33 , 3839},
+	{35 , 3831},
+	{36 , 3824},
+	{38 , 3818},
+	{39 , 3815},
+	{41 , 3808},
+	{42 , 3805},
+	{44 , 3803},
+	{46 , 3798},
+	{47 , 3796},
+	{49 , 3793},
+	{50 , 3792},
+	{52 , 3790},
+	{53 , 3790},
+	{55 , 3788},
+	{57 , 3788},
+	{58 , 3787},
+	{60 , 3787},
+	{61 , 3785},
+	{63 , 3785},
+	{64 , 3784},
+	{66 , 3782},
+	{67 , 3779},
+	{69 , 3777},
+	{71 , 3774},
+	{72 , 3769},
+	{74 , 3766},
+	{75 , 3762},
+	{77 , 3756},
+	{78 , 3748},
+	{80 , 3742},
+	{82 , 3734},
+	{83 , 3724},
+	{85 , 3714},
+	{86 , 3708},
+	{88 , 3703},
+	{89 , 3701},
+	{91 , 3699},
+	{93 , 3696},
+	{94 , 3689},
+	{96 , 3662},
+	{97 , 3601},
+	{99 , 3533},
+	{99 , 3475},
+	{100 , 3418},
+	{100 , 3363},
+	{100 , 3315},
+	{100 , 3270},
+	{100 , 3238},
+	{100 , 3208},
+	{100 , 3191},
+	{100 , 3172},
+	{100 , 3159},
+	{100 , 3150},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137},
+	{100 , 3137}
+};
+
+
+// T2 25C
+BATTERY_PROFILE_STRUC battery_profile_t2[] =
+{
+	{0 , 4186},
+	{0 , 4167},
+	{1 , 4152},
+	{2 , 4139},
+	{4 , 4126},
+	{5 , 4114},
+	{6 , 4102},
+	{7 , 4091},
+	{9 , 4079},
+	{10 , 4069},
+	{11 , 4058},
+	{12 , 4047},
+	{13 , 4037},
+	{15 , 4026},
+	{16 , 4015},
+	{17 , 4006},
+	{18 , 3997},
+	{20 , 3988},
+	{21 , 3979},
+	{22 , 3971},
+	{23 , 3963},
+	{24 , 3955},
+	{26 , 3947},
+	{27 , 3940},
+	{28 , 3932},
+	{29 , 3925},
+	{30 , 3918},
+	{32 , 3911},
+	{33 , 3904},
+	{34 , 3897},
+	{35 , 3890},
+	{37 , 3882},
+	{38 , 3874},
+	{39 , 3864},
+	{40 , 3854},
+	{41 , 3844},
+	{43 , 3835},
+	{44 , 3828},
+	{45 , 3822},
+	{46 , 3816},
+	{48 , 3812},
+	{49 , 3807},
+	{50 , 3803},
+	{51 , 3799},
+	{52 , 3795},
+	{54 , 3792},
+	{55 , 3789},
+	{56 , 3786},
+	{57 , 3783},
+	{59 , 3781},
+	{60 , 3778},
+	{61 , 3776},
+	{62 , 3774},
+	{63 , 3773},
+	{65 , 3771},
+	{66 , 3770},
+	{67 , 3768},
+	{68 , 3766},
+	{69 , 3764},
+	{71 , 3760},
+	{72 , 3757},
+	{73 , 3753},
+	{74 , 3748},
+	{76 , 3740},
+	{77 , 3730},
+	{78 , 3720},
+	{79 , 3710},
+	{80 , 3700},
+	{82 , 3690},
+	{83 , 3680},
+	{84 , 3680},
+	{85 , 3670},
+	{87 , 3660},
+	{88 , 3650},
+	{89 , 3640},
+	{90 , 3630},
+	{91 , 3620},
+	{93 , 3610},
+	{94 , 3600},
+	{95 , 3580},
+	{96 , 3560},
+	{98 , 3540},
+	{99 , 3461},
+	{100 , 3340},
+	{100 , 3274},
+	{101 , 3259},
+	{101 , 3253},
+	{101 , 3250},
+	{101 , 3247},
+	{101 , 3247},
+	{101 , 3247},
+	{101 , 3247},
+	{101 , 3247},
+	{101 , 3247},
+	{101 , 3247},
+	{101 , 3247},
+	{101 , 3247}
+};
+
+
+// T3 50C
+BATTERY_PROFILE_STRUC battery_profile_t3[] =
+{
+	{0 , 4181},
+	{1 , 4167},
+	{3 , 4152},
+	{4 , 4139},
+	{5 , 4127},
+	{7 , 4114},
+	{8 , 4103},
+	{9 , 4090},
+	{11 , 4078},
+	{12 , 4067},
+	{13 , 4056},
+	{14 , 4049},
+	{16 , 4036},
+	{17 , 4022},
+	{18 , 4010},
+	{20 , 4001},
+	{21 , 3995},
+	{22 , 3986},
+	{24 , 3977},
+	{25 , 3969},
+	{26 , 3959},
+	{28 , 3952},
+	{29 , 3943},
+	{30 , 3935},
+	{31 , 3929},
+	{33 , 3920},
+	{34 , 3913},
+	{35 , 3906},
+	{37 , 3899},
+	{38 , 3893},
+	{39 , 3887},
+	{41 , 3879},
+	{42 , 3867},
+	{43 , 3851},
+	{45 , 3840},
+	{46 , 3833},
+	{47 , 3827},
+	{48 , 3820},
+	{50 , 3816},
+	{51 , 3812},
+	{52 , 3808},
+	{54 , 3803},
+	{55 , 3800},
+	{56 , 3797},
+	{58 , 3794},
+	{59 , 3791},
+	{60 , 3787},
+	{62 , 3785},
+	{63 , 3782},
+	{64 , 3779},
+	{66 , 3778},
+	{67 , 3776},
+	{68 , 3775},
+	{69 , 3772},
+	{71 , 3767},
+	{72 , 3759},
+	{73 , 3753},
+	{75 , 3751},
+	{76 , 3746},
+	{77 , 3742},
+	{79 , 3737},
+	{80 , 3732},
+	{81 , 3729},
+	{83 , 3724},
+	{84 , 3715},
+	{85 , 3708},
+	{86 , 3699},
+	{88 , 3689},
+	{89 , 3681},
+	{90 , 3680},
+	{92 , 3680},
+	{93 , 3678},
+	{94 , 3676},
+	{96 , 3664},
+	{97 , 3619},
+	{98 , 3553},
+	{100 , 3454},
+	{100 , 3279},
+	{100 , 3141},
+	{100 , 3081},
+	{100 , 3038},
+	{100 , 3012},
+	{100 , 2982},
+	{100 , 2976},
+	{100 , 2956},
+	{100 , 2947},
+	{100 , 2942},
+	{100 , 2936},
+	{100 , 2939},
+	{100 , 2926},
+	{100 , 2925},
+	{100 , 2922},
+	{100 , 2918},
+	{100 , 2910},
+	{100 , 2904},
+	{100 , 2897},
+	{100 , 2891},
+	{100 , 2881},
+	{100 , 2873},
+	{100 , 2876}
+};
+
+
+// R0 -10C
+R_PROFILE_STRUC r_profile_t0[] =
+{
+	{865 , 4098},
+	{865 , 4069},
+	{893 , 4053},
+	{915 , 4040},
+	{955 , 4023},
+	{1023 , 3997},
+	{1200 , 3961},
+	{1338 , 3946},
+	{1375 , 3938},
+	{1388 , 3932},
+	{1408 , 3926},
+	{1420 , 3918},
+	{1428 , 3910},
+	{1418 , 3901},
+	{1428 , 3894},
+	{1423 , 3885},
+	{1418 , 3874},
+	{1425 , 3866},
+	{1428 , 3856},
+	{1428 , 3846},
+	{1425 , 3838},
+	{1423 , 3830},
+	{1420 , 3823},
+	{1415 , 3817},
+	{1425 , 3814},
+	{1425 , 3808},
+	{1450 , 3806},
+	{1468 , 3803},
+	{1465 , 3801},
+	{1483 , 3798},
+	{1488 , 3795},
+	{1510 , 3796},
+	{1515 , 3795},
+	{1533 , 3792},
+	{1535 , 3792},
+	{1548 , 3790},
+	{1543 , 3789},
+	{1563 , 3787},
+	{1588 , 3785},
+	{1610 , 3783},
+	{1625 , 3781},
+	{1640 , 3776},
+	{1653 , 3772},
+	{1660 , 3767},
+	{1680 , 3763},
+	{1690 , 3758},
+	{1710 , 3751},
+	{1733 , 3742},
+	{1745 , 3734},
+	{1765 , 3725},
+	{1788 , 3719},
+	{1813 , 3715},
+	{1853 , 3712},
+	{1905 , 3707},
+	{1965 , 3702},
+	{2010 , 3696},
+	{2080 , 3678},
+	{2123 , 3647},
+	{2035 , 3612},
+	{1943 , 3575},
+	{1853 , 3537},
+	{1770 , 3502},
+	{1685 , 3472},
+	{1623 , 3443},
+	{1550 , 3419},
+	{1493 , 3395},
+	{1448 , 3373},
+	{1395 , 3357},
+	{1368 , 3341},
+	{1338 , 3328},
+	{1303 , 3317},
+	{1298 , 3307},
+	{1263 , 3300},
+	{1253 , 3293},
+	{1260 , 3288},
+	{1225 , 3283},
+	{1240 , 3275},
+	{1198 , 3271},
+	{1215 , 3267},
+	{1198 , 3260},
+	{1200 , 3256},
+	{1218 , 3251},
+	{1228 , 3243},
+	{1138 , 3239},
+	{1230 , 3233},
+	{1243 , 3225},
+	{1155 , 3218},
+	{1165 , 3214},
+	{1045 , 3209},
+	{1170 , 3202},
+	{1183 , 3196},
+	{1340 , 3185},
+	{1368 , 3171},
+	{1423 , 3157},
+	{1455 , 3142},
+	{1533 , 3125},
+	{1365 , 3114},
+	{1653 , 3095},
+	{1653 , 3095},
+	{1653 , 3095}
+};
+
+
+// R1 0C
+R_PROFILE_STRUC r_profile_t1[] =
+{
+	{633 , 4048},
+	{633 , 4008},
+	{678 , 3989},
+	{685 , 3977},
+	{700 , 3966},
+	{713 , 3960},
+	{728 , 3956},
+	{748 , 3951},
+	{753 , 3948},
+	{763 , 3941},
+	{763 , 3935},
+	{768 , 3928},
+	{783 , 3922},
+	{775 , 3914},
+	{780 , 3906},
+	{790 , 3898},
+	{790 , 3892},
+	{793 , 3882},
+	{798 , 3872},
+	{778 , 3860},
+	{778 , 3849},
+	{770 , 3839},
+	{778 , 3831},
+	{770 , 3824},
+	{785 , 3818},
+	{795 , 3815},
+	{785 , 3808},
+	{805 , 3805},
+	{810 , 3803},
+	{815 , 3798},
+	{818 , 3796},
+	{835 , 3793},
+	{838 , 3792},
+	{840 , 3790},
+	{865 , 3790},
+	{863 , 3788},
+	{880 , 3788},
+	{893 , 3787},
+	{908 , 3787},
+	{928 , 3785},
+	{933 , 3785},
+	{960 , 3784},
+	{965 , 3782},
+	{990 , 3779},
+	{1003 , 3777},
+	{1033 , 3774},
+	{1045 , 3769},
+	{1070 , 3766},
+	{1098 , 3762},
+	{1113 , 3756},
+	{1145 , 3748},
+	{1185 , 3742},
+	{1208 , 3734},
+	{1248 , 3724},
+	{1295 , 3714},
+	{1333 , 3708},
+	{1405 , 3703},
+	{1465 , 3701},
+	{1560 , 3699},
+	{1643 , 3696},
+	{1745 , 3689},
+	{1815 , 3662},
+	{1863 , 3601},
+	{1840 , 3533},
+	{1688 , 3475},
+	{1560 , 3418},
+	{1418 , 3363},
+	{1313 , 3315},
+	{1200 , 3270},
+	{1100 , 3238},
+	{1060 , 3208},
+	{980 , 3191},
+	{1000 , 3172},
+	{955 , 3159},
+	{878 , 3150},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137},
+	{960 , 3137}
+};
+
+
+// R2 25C
+R_PROFILE_STRUC r_profile_t2[] =
+{
+	{72 , 4186},
+	{72 , 4167},
+	{72 , 4152},
+	{73 , 4139},
+	{74 , 4126},
+	{74 , 4114},
+	{75 , 4102},
+	{75 , 4091},
+	{76 , 4079},
+	{77 , 4069},
+	{78 , 4058},
+	{79 , 4047},
+	{78 , 4037},
+	{80 , 4026},
+	{81 , 4015},
+	{82 , 4006},
+	{82 , 3997},
+	{84 , 3988},
+	{84 , 3979},
+	{85 , 3971},
+	{86 , 3963},
+	{88 , 3955},
+	{89 , 3947},
+	{91 , 3940},
+	{92 , 3932},
+	{94 , 3925},
+	{94 , 3918},
+	{98 , 3911},
+	{98 , 3904},
+	{99 , 3897},
+	{98 , 3890},
+	{97 , 3882},
+	{94 , 3874},
+	{90 , 3864},
+	{85 , 3854},
+	{81 , 3844},
+	{78 , 3835},
+	{76 , 3828},
+	{74 , 3822},
+	{73 , 3816},
+	{73 , 3812},
+	{73 , 3807},
+	{73 , 3803},
+	{72 , 3799},
+	{72 , 3795},
+	{73 , 3792},
+	{74 , 3789},
+	{73 , 3786},
+	{74 , 3783},
+	{75 , 3781},
+	{75 , 3778},
+	{76 , 3776},
+	{76 , 3774},
+	{77 , 3773},
+	{76 , 3771},
+	{76 , 3770},
+	{77 , 3768},
+	{76 , 3766},
+	{76 , 3764},
+	{73 , 3760},
+	{72 , 3757},
+	{72 , 3753},
+	{71 , 3748},
+	{70 , 3740},
+	{70 , 3730},
+	{70 , 3720},
+	{72 , 3710},
+	{72 , 3700},
+	{72 , 3690},
+	{72 , 3680},
+	{72 , 3680},
+	{73 , 3670},
+	{75 , 3660},
+	{73 , 3650},
+	{71 , 3640},
+	{74 , 3630},
+	{79 , 3620},
+	{84 , 3610},
+	{92 , 3600},
+	{91 , 3580},
+	{89 , 3560},
+	{95 , 3540},
+	{10 , 3461},
+	{12 , 3340},
+	{12 , 3274},
+	{10 , 3259},
+	{89 , 3253},
+	{85 , 3250},
+	{81 , 3247},
+	{81 , 3247},
+	{81 , 3247},
+	{81 , 3247},
+	{81 , 3247},
+	{81 , 3247},
+	{81 , 3247},
+	{81 , 3247},
+	{81 , 3247}
+};
+
+
+// R3 50C
+R_PROFILE_STRUC r_profile_t3[] =
+{
+	{138 , 4181},
+	{138 , 4167},
+	{138 , 4152},
+	{140 , 4139},
+	{140 , 4127},
+	{143 , 4114},
+	{143 , 4103},
+	{143 , 4090},
+	{140 , 4078},
+	{143 , 4067},
+	{145 , 4056},
+	{155 , 4049},
+	{153 , 4036},
+	{155 , 4022},
+	{155 , 4010},
+	{155 , 4001},
+	{160 , 3995},
+	{163 , 3986},
+	{163 , 3977},
+	{170 , 3969},
+	{163 , 3959},
+	{173 , 3952},
+	{173 , 3943},
+	{175 , 3935},
+	{180 , 3929},
+	{178 , 3920},
+	{178 , 3913},
+	{180 , 3906},
+	{180 , 3899},
+	{190 , 3893},
+	{190 , 3887},
+	{190 , 3879},
+	{180 , 3867},
+	{158 , 3851},
+	{145 , 3840},
+	{143 , 3833},
+	{140 , 3827},
+	{138 , 3820},
+	{138 , 3816},
+	{143 , 3812},
+	{145 , 3808},
+	{145 , 3803},
+	{145 , 3800},
+	{150 , 3797},
+	{153 , 3794},
+	{153 , 3791},
+	{158 , 3787},
+	{155 , 3785},
+	{160 , 3782},
+	{160 , 3779},
+	{160 , 3778},
+	{163 , 3776},
+	{168 , 3775},
+	{163 , 3772},
+	{158 , 3767},
+	{148 , 3759},
+	{145 , 3753},
+	{150 , 3751},
+	{148 , 3746},
+	{150 , 3742},
+	{150 , 3737},
+	{148 , 3732},
+	{155 , 3729},
+	{158 , 3724},
+	{150 , 3715},
+	{155 , 3708},
+	{153 , 3699},
+	{150 , 3689},
+	{143 , 3681},
+	{150 , 3680},
+	{160 , 3680},
+	{168 , 3678},
+	{180 , 3676},
+	{180 , 3664},
+	{170 , 3619},
+	{188 , 3553},
+	{205 , 3454},
+	{300 , 3279},
+	{858 , 3141},
+	{783 , 3081},
+	{653 , 3038},
+	{530 , 3012},
+	{515 , 2982},
+	{458 , 2976},
+	{498 , 2956},
+	{475 , 2947},
+	{440 , 2942},
+	{425 , 2936},
+	{383 , 2939},
+	{415 , 2926},
+	{330 , 2925},
+	{320 , 2922},
+	{325 , 2918},
+	{385 , 2910},
+	{340 , 2904},
+	{353 , 2897},
+	{358 , 2891},
+	{365 , 2881},
+	{385 , 2873},
+	{320 , 2876}
+};
+
+
+// battery profile for actual temperature. The size should be the same as T1, T2 and T3
+BATTERY_PROFILE_STRUC battery_profile_temperature[] =
+{
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0}
+};    
+
+// ============================================================
+// <Rbat, Battery_Voltage> Table
+// ============================================================
+
+// r-table profile for actual temperature. The size should be the same as T1, T2 and T3
+R_PROFILE_STRUC r_profile_temperature[] =
+{
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0},
+	{0   , 0}
+};    
+
+// ============================================================
+// function prototype
+// ============================================================
+int fgauge_get_saddles(void);
+BATTERY_PROFILE_STRUC_P fgauge_get_profile(kal_uint32 temperature);
+
+int fgauge_get_saddles_r_table(void);
+R_PROFILE_STRUC_P fgauge_get_profile_r_table(kal_uint32 temperature);
+
+#endif	//#ifndef _CUST_BATTERY_METER_TABLE_H
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_charging.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_charging.h
new file mode 100644
index 0000000..b2ef921
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_charging.h
@@ -0,0 +1,113 @@
+#ifndef _CUST_BAT_H_
+#define _CUST_BAT_H_
+
+/* stop charging while in talking mode */
+#define STOP_CHARGING_IN_TAKLING
+#define TALKING_RECHARGE_VOLTAGE 3800
+#define TALKING_SYNC_TIME		   60
+
+/* Battery Temperature Protection */
+#define MTK_TEMPERATURE_RECHARGE_SUPPORT
+#define MAX_CHARGE_TEMPERATURE  55
+#define MAX_CHARGE_TEMPERATURE_MINUS_X_DEGREE	47
+#define MIN_CHARGE_TEMPERATURE  0
+#define MIN_CHARGE_TEMPERATURE_PLUS_X_DEGREE	6
+#define ERR_CHARGE_TEMPERATURE  0xFF
+
+/* Linear Charging Threshold */
+#define V_PRE2CC_THRES	 		3400	//mV
+#define V_CC2TOPOFF_THRES		4050
+#define RECHARGING_VOLTAGE      4110
+#define CHARGING_FULL_CURRENT    100	//mA
+
+/* Charging Current Setting */
+//#define CONFIG_USB_IF 						   
+#define USB_CHARGER_CURRENT_SUSPEND			0		// def CONFIG_USB_IF
+#define USB_CHARGER_CURRENT_UNCONFIGURED	CHARGE_CURRENT_70_00_MA	// 70mA
+#define USB_CHARGER_CURRENT_CONFIGURED		CHARGE_CURRENT_500_00_MA	// 500mA
+
+#define USB_CHARGER_CURRENT					CHARGE_CURRENT_500_00_MA	//500mA
+#define AC_CHARGER_CURRENT					CHARGE_CURRENT_800_00_MA
+//#define AC_CHARGER_CURRENT					CHARGE_CURRENT_1000_00_MA
+#define NON_STD_AC_CHARGER_CURRENT			CHARGE_CURRENT_500_00_MA
+#define CHARGING_HOST_CHARGER_CURRENT       CHARGE_CURRENT_650_00_MA
+#define APPLE_0_5A_CHARGER_CURRENT          CHARGE_CURRENT_500_00_MA
+#define APPLE_1_0A_CHARGER_CURRENT          CHARGE_CURRENT_650_00_MA
+#define APPLE_2_1A_CHARGER_CURRENT          CHARGE_CURRENT_800_00_MA
+
+
+/* Precise Tunning */
+#define BATTERY_AVERAGE_DATA_NUMBER	3	
+#define BATTERY_AVERAGE_SIZE 	30
+
+/* charger error check */
+//#define BAT_LOW_TEMP_PROTECT_ENABLE         // stop charging if temp < MIN_CHARGE_TEMPERATURE
+#define V_CHARGER_ENABLE 0				// 1:ON , 0:OFF	
+#define V_CHARGER_MAX 6500				// 6.5 V
+#define V_CHARGER_MIN 4400				// 4.4 V
+
+/* Tracking TIME */
+#define ONEHUNDRED_PERCENT_TRACKING_TIME	10	// 10 second
+#define NPERCENT_TRACKING_TIME	   			20	// 20 second
+#define SYNC_TO_REAL_TRACKING_TIME  		60	// 60 second
+#define V_0PERCENT_TRACKING							3300 //3450mV
+
+#define CUST_SYSTEM_OFF_VOLTAGE 3300
+#define SYSTEM_OFF_VOLTAGE CUST_SYSTEM_OFF_VOLTAGE
+
+/* Battery Notify */
+#define BATTERY_NOTIFY_CASE_0001_VCHARGER
+#define BATTERY_NOTIFY_CASE_0002_VBATTEMP
+//#define BATTERY_NOTIFY_CASE_0003_ICHARGING
+//#define BATTERY_NOTIFY_CASE_0004_VBAT
+//#define BATTERY_NOTIFY_CASE_0005_TOTAL_CHARGINGTIME
+
+/* High battery support */
+//#define HIGH_BATTERY_VOLTAGE_SUPPORT
+
+/* JEITA parameter */
+//#define MTK_JEITA_STANDARD_SUPPORT
+#define CUST_SOC_JEITA_SYNC_TIME 30
+#define JEITA_RECHARGE_VOLTAGE  4110	// for linear charging
+#ifdef HIGH_BATTERY_VOLTAGE_SUPPORT
+#define JEITA_TEMP_ABOVE_POS_60_CV_VOLTAGE		BATTERY_VOLT_04_240000_V
+#define JEITA_TEMP_POS_45_TO_POS_60_CV_VOLTAGE		BATTERY_VOLT_04_240000_V
+#define JEITA_TEMP_POS_10_TO_POS_45_CV_VOLTAGE		BATTERY_VOLT_04_340000_V
+#define JEITA_TEMP_POS_0_TO_POS_10_CV_VOLTAGE		BATTERY_VOLT_04_240000_V
+#define JEITA_TEMP_NEG_10_TO_POS_0_CV_VOLTAGE		BATTERY_VOLT_04_040000_V
+#define JEITA_TEMP_BELOW_NEG_10_CV_VOLTAGE		BATTERY_VOLT_04_040000_V
+#else
+#define JEITA_TEMP_ABOVE_POS_60_CV_VOLTAGE		BATTERY_VOLT_04_100000_V
+#define JEITA_TEMP_POS_45_TO_POS_60_CV_VOLTAGE	BATTERY_VOLT_04_100000_V
+#define JEITA_TEMP_POS_10_TO_POS_45_CV_VOLTAGE	BATTERY_VOLT_04_200000_V
+#define JEITA_TEMP_POS_0_TO_POS_10_CV_VOLTAGE	BATTERY_VOLT_04_100000_V
+#define JEITA_TEMP_NEG_10_TO_POS_0_CV_VOLTAGE	BATTERY_VOLT_03_900000_V
+#define JEITA_TEMP_BELOW_NEG_10_CV_VOLTAGE		BATTERY_VOLT_03_900000_V
+#endif
+/* For JEITA Linear Charging only */
+#define JEITA_NEG_10_TO_POS_0_FULL_CURRENT  120	//mA 
+#define JEITA_TEMP_POS_45_TO_POS_60_RECHARGE_VOLTAGE  4000
+#define JEITA_TEMP_POS_10_TO_POS_45_RECHARGE_VOLTAGE  4100
+#define JEITA_TEMP_POS_0_TO_POS_10_RECHARGE_VOLTAGE   4000
+#define JEITA_TEMP_NEG_10_TO_POS_0_RECHARGE_VOLTAGE   3800
+#define JEITA_TEMP_POS_45_TO_POS_60_CC2TOPOFF_THRESHOLD	4050
+#define JEITA_TEMP_POS_10_TO_POS_45_CC2TOPOFF_THRESHOLD	4050
+#define JEITA_TEMP_POS_0_TO_POS_10_CC2TOPOFF_THRESHOLD	4050
+#define JEITA_TEMP_NEG_10_TO_POS_0_CC2TOPOFF_THRESHOLD	3850
+
+
+/* For CV_E1_INTERNAL */
+#define CV_E1_INTERNAL
+
+/* Disable Battery check for HQA */
+#ifdef CONFIG_MTK_DISABLE_POWER_ON_OFF_VOLTAGE_LIMITATION
+#define CONFIG_DIS_CHECK_BATTERY
+#endif
+
+#ifdef CONFIG_MTK_FAN5405_SUPPORT
+#define FAN5405_BUSNUM 1
+#endif
+
+#define MTK_PLUG_OUT_DETECTION
+
+#endif /* _CUST_BAT_H_ */ 
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_pe.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_pe.h
new file mode 100644
index 0000000..911bc44
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_pe.h
@@ -0,0 +1,21 @@
+#ifndef _CUST_PE_H_
+#define _CUST_PE_H_
+
+/* Pump Express support (fast charging) */
+#ifdef MTK_PUMP_EXPRESS_PLUS_SUPPORT
+#define TA_START_BATTERY_SOC	1
+#define TA_STOP_BATTERY_SOC 	95
+#define TA_AC_9V_INPUT_CURRENT	CHARGE_CURRENT_1500_00_MA
+#define TA_AC_7V_INPUT_CURRENT	CHARGE_CURRENT_1500_00_MA
+#define TA_AC_CHARGING_CURRENT	CHARGE_CURRENT_2200_00_MA
+#define TA_9V_SUPPORT
+
+#undef V_CHARGER_MAX
+#ifdef TA_9V_SUPPORT
+#define V_CHARGER_MAX 10500				// 10.5 V
+#else
+#define V_CHARGER_MAX 7500				// 7.5 V
+#endif
+#endif
+
+#endif /* _CUST_PE_H_ */ 
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_pmic.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_pmic.h
new file mode 100644
index 0000000..461ada8
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/power/cust_pmic.h
@@ -0,0 +1,92 @@
+#ifndef _CUST_PMIC_H_
+#define _CUST_PMIC_H_
+
+//#define PMIC_VDVFS_CUST_ENABLE
+
+#define LOW_POWER_LIMIT_LEVEL_1 15
+
+//Define for disable low battery protect feature, default no define for enable low battery protect.
+//#define DISABLE_LOW_BATTERY_PROTECT    
+                                         
+//Define for disable battery OC protect
+//#define DISABLE_BATTERY_OC_PROTECT     
+                                         
+//Define for disable battery 15% protect 
+//#define DISABLE_BATTERY_PERCENT_PROTECT
+
+//Define for DLPT
+//#define DISABLE_DLPT_FEATURE
+#define POWER_UVLO_VOLT_LEVEL 2600
+#define IMAX_MAX_VALUE 5500//mA
+
+#define POWER_INT0_VOLT 3400
+#define POWER_INT1_VOLT 3250
+#define POWER_INT2_VOLT 3100
+
+#if defined(CONFIG_ARCH_MT6753)
+#define POWER_BAT_OC_CURRENT_H    4670
+#define POWER_BAT_OC_CURRENT_L    5500
+#define POWER_BAT_OC_CURRENT_H_RE 4670 //3400
+#define POWER_BAT_OC_CURRENT_L_RE 5500 //4000
+#else
+#define POWER_BAT_OC_CURRENT_H    3400
+#define POWER_BAT_OC_CURRENT_L    4000
+#define POWER_BAT_OC_CURRENT_H_RE 3400 //3400
+#define POWER_BAT_OC_CURRENT_L_RE 4000 //4000
+#endif
+
+#define DLPT_POWER_OFF_EN
+#define POWEROFF_BAT_CURRENT 3000//mA
+#define DLPT_POWER_OFF_THD 100
+
+//#define BATTERY_MODULE_INIT
+
+#if defined(MTK_BQ24196_SUPPORT)\
+	||defined(MTK_BQ24296_SUPPORT)\
+	||defined(MTK_BQ24160_SUPPORT)\
+	||defined(MTK_BQ24261_SUPPORT)
+#define SWCHR_POWER_PATH
+#endif
+
+#if defined(MTK_FAN5402_SUPPORT) \
+	 || defined(MTK_FAN5405_SUPPORT) \
+	  || defined(MTK_BQ24158_SUPPORT) \
+	   || defined(MTK_BQ24196_SUPPORT) \
+	    || defined(MTK_BQ24296_SUPPORT) \
+	     || defined(MTK_NCP1851_SUPPORT) \
+	      || defined(MTK_NCP1854_SUPPORT) \
+	       || defined(MTK_BQ24160_SUPPORT) \
+	        || defined(MTK_BQ24157_SUPPORT) \
+	         || defined(MTK_BQ24250_SUPPORT) \
+	          || defined(MTK_BQ24261_SUPPORT) 
+#define EXTERNAL_SWCHR_SUPPORT
+#endif
+
+/* ADC Channel Number */
+typedef enum {
+	//MT6325
+	AUX_BATSNS_AP =		0x000,
+	AUX_ISENSE_AP,
+	AUX_VCDT_AP,
+	AUX_BATON_AP,
+	AUX_TSENSE_AP,
+	AUX_TSENSE_MD =		0x005,
+	AUX_VACCDET_AP =	0x007,
+	AUX_VISMPS_AP =		0x00B,
+	AUX_ICLASSAB_AP =	0x016,
+	AUX_HP_AP =		0x017,
+	AUX_CH10_AP =		0x018,
+	AUX_VBIF_AP =		0x019,
+	
+	AUX_CH0_6311 =		0x020,
+	AUX_CH1_6311 =		0x021,
+
+	AUX_ADCVIN0_MD =	0x10F,
+	AUX_ADCVIN0_GPS = 	0x20C,
+	AUX_CH12 = 		0x1011,
+	AUX_CH13 = 		0x2011,
+	AUX_CH14 = 		0x3011,
+	AUX_CH15 = 		0x4011,
+} upmu_adc_chl_list_enum;
+
+#endif /* _CUST_PMIC_H_ */ 
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/rtc/rtc-mt.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/rtc/rtc-mt.h
new file mode 100755
index 0000000..fc16aca
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/rtc/rtc-mt.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2010 MediaTek, Inc.
+ *
+ * Author: Terry Chang <terry.chang@mediatek.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _RTC_MT_H_
+#define _RTC_MT_H_
+
+#define RTC_YES		1
+#define RTC_NO		0
+
+/*
+ * Reset to default date if RTC time is over 2038/1/19 3:14:7
+ * Year (YEA)        : 1970 ~ 2037
+ * Month (MTH)       : 1 ~ 12
+ * Day of Month (DOM): 1 ~ 31
+ */
+#define RTC_OVER_TIME_RESET	RTC_YES
+#define RTC_DEFAULT_YEA		2010
+#define RTC_DEFAULT_MTH		1
+#define RTC_DEFAULT_DOM		1
+
+/*
+Cap selection
+0 : 0.1uF only
+1 : 0.1uF + 1uF + 1.5Kohm
+2 : 0.1uF + 2.2uF + 1.5Kohm
+3 : 0.1uF + 4.7uF + 1.5Kohm
+4 : 0.1uF + 10uF + 1.5Kohm
+5 : 0.1uF + 22uF + 1.5Kohm
+6 : 0.1uF + super cap(>>22uF) + 1.5Kohm
+7 : 0.1uF + little Li battery + 1.5Kohm
+*/
+#define RTC_CAP_SEL		0
+
+#endif
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/Makefile
new file mode 100755
index 0000000..3cc859a
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/Makefile
@@ -0,0 +1,5 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+
+obj-y	:=  yusu_android_speaker.o
+
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/inc/external_codec_driver.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/inc/external_codec_driver.h
new file mode 100755
index 0000000..90793b5
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/inc/external_codec_driver.h
@@ -0,0 +1,104 @@
+/*******************************************************************************
+ *
+ * Filename:
+ * ---------
+ * external_codec_driver.h
+ *
+ * Project:
+ * --------
+ *   MT6592_phone_v1
+ *
+ * Description:
+ * ------------
+ *   external codec control
+ *
+ * Author:
+ * -------
+ *   Stephen Chen
+ *
+ *
+ *------------------------------------------------------------------------------
+ * $Revision$
+ * $Modtime:$
+ * $Log:$
+ * *
+ *
+ *******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/vmalloc.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/semaphore.h>
+#include <mach/mt_typedefs.h>
+
+#ifndef _EXTERNAL_CODEC_DRIVER_H_
+#define _EXTERNAL_CODEC_DRIVER_H_
+
+/* CS4398 registers addresses */
+#define CS4398_CHIPID   0x01    /* Chip ID */
+#define CS4398_MODE 0x02    /* Mode Control */
+#define CS4398_MIXING   0x03
+#define CS4398_MUTE 0x04    /* Mute Control */
+#define CS4398_VOLA 0x05    /* DAC Channel A Volume Control */
+#define CS4398_VOLB 0x06    /* DAC Channel B Volume Control */
+#define CS4398_RAMP 0x07
+#define CS4398_MISC1    0x08
+#define CS4398_MISC2    0x09
+
+#define CS4398_FIRSTREG 0x01
+#define CS4398_LASTREG  0x09
+#define CS4398_NUMREGS  (CS4398_LASTREG - CS4398_FIRSTREG + 1)
+
+typedef enum
+{
+    DIF_LEFT_JUSTIFIED,
+    DIF_I2S,
+    DIF_RIGHT_JUSTIFIED_16BIT,
+    DIF_RIGHT_JUSTIFIED_24BIT,
+    DIF_RIGHT_JUSTIFIED_20BIT,
+    DIF_RIGHT_JUSTIFIED_18BIT,
+    NUM_OF_DIF
+} DIGITAL_INTERFACE_FORMAT;
+
+
+enum ECODEC_CONTROL_SUBCOMMAND
+{
+    ECODEC_GETREGISTER_VALUE,
+    ECODEC_SETREGISTER_VALUE,
+};
+
+enum AUDIO_ECODEC_CONTROL_COMMAND
+{
+    NUM_AUD_ECODEC_COMMAND,
+};
+
+typedef struct
+{
+    unsigned long int   command;
+    unsigned long int   param1;
+    unsigned long int   param2;
+} ECODEC_Control;
+
+void ExtCodec_Init(void);
+void ExtCodec_PowerOn(void);
+void ExtCodec_PowerOff(void);
+bool ExtCodec_Register(void);
+void ExtCodec_Mute(void);
+void ExtCodec_SetGain(u8 leftright, u8 gain);
+u8 ExtCodec_ReadReg(u8 addr);
+void ExtCodec_DumpReg(void);
+void ExtCodecDevice_Suspend(void);
+void ExtCodecDevice_Resume(void);
+void cust_extcodec_gpio_on(void);
+void cust_extcodec_gpio_off(void);
+void cust_extHPAmp_gpio_on(void);
+void cust_extHPAmp_gpio_off(void);
+void cust_extPLL_gpio_config(void);
+#endif
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/inc/yusu_android_speaker.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/inc/yusu_android_speaker.h
new file mode 100755
index 0000000..2bb04c6
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/inc/yusu_android_speaker.h
@@ -0,0 +1,146 @@
+/*******************************************************************************
+ *
+ * Filename:
+ * ---------
+ * Yusu_android_speaker.h
+ *
+ * Project:
+ * --------
+ *   Yusu
+ *
+ * Description:
+ * ------------
+ *   speaker select
+ *
+ * Author:
+ * -------
+ *   ChiPeng Chang (mtk02308)
+ *
+ *
+ *------------------------------------------------------------------------------
+ * $Revision$
+ * $Modtime:$
+ * $Log:$
+ *
+ * 06 17 2012 weiguo.li
+ * [ALPS00302429] [Need Patch] [Volunteer Patch]modify speaker driver
+ * .
+ *
+ * 12 14 2011 weiguo.li
+ * [ALPS00102848] [Need Patch] [Volunteer Patch] build waring in yusu_android_speaker.h
+ * .
+ *
+ * 11 10 2011 weiguo.li
+ * [ALPS00091610] [Need Patch] [Volunteer Patch]chang yusu_android_speaker.c function name and modules use it
+ * .
+ *
+ * 09 28 2011 weiguo.li
+ * [ALPS00076254] [Need Patch] [Volunteer Patch]LGE audio driver using Voicebuffer for incall
+ * .
+ *
+ * 07 08 2011 weiguo.li
+ * [ALPS00059378] poring lge code to alps(audio)
+ * .
+ *
+ * 07 23 2010 chipeng.chang
+ * [ALPS00122386][Music]The playing music is no sound after below steps. 
+ * when mode change , record deivce for volume setting.
+ *
+ * 07 03 2010 chipeng.chang
+ * [ALPS00002838][Need Patch] [Volunteer Patch] for speech volume step 
+ * modify for headset customization.
+ *
+ *******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/vmalloc.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/semaphore.h>
+#include <mach/mt_typedefs.h>
+
+#ifndef _YUSU_ANDROID_SPEAKER_H_
+#define _YUSU_ANDROID_SPEAKER_H_
+
+  enum EAMP_CONTROL_SUBCOMMAND
+ {
+	 EAMP_SPEAKER_CLOSE =0,
+	 EAMP_SPEAKER_OPEN,
+	 EAMP_HEADPHONE_OPEN,
+	 EAMP_HEADPHONE_CLOSE,
+	 EAMP_EARPIECE_OPEN,
+	 EAMP_EARPIECE_CLOSE,
+	 EAMP_GETREGISTER_VALUE,
+	 EAMP_SETREGISTER_VALUE,
+	 EAMP_SETAMP_GAIN,
+	 EAMP_GETAMP_GAIN,
+	 EAMP_GET_CTRP_NUM ,
+	 EAMP_GET_CTRP_BITS,
+	 EAMP_GET_CTRP_TABLE,
+	 EAMP_SETMODE,
+ };
+
+enum AUDIO_AMP_CONTROL_COMMAND{
+    AUD_AMP_GET_CTRP_NUM ,
+    AUD_AMP_GET_CTRP_BITS,
+    AUD_AMP_GET_CTRP_TABLE,
+    AUD_AMP_GET_REGISTER,
+    AUD_AMP_SET_REGISTER,
+    AUD_AMP_SET_AMPGAIN,  // gain is use for low 24bits as external amp , device should base on control point set to AMPLL_CON0_REG
+    AUD_AMP_GET_AMPGAIN,
+    AUD_AMP_SET_MODE,
+    NUM_AUD_AMP_COMMAND
+};
+
+typedef struct {
+	unsigned long int	command;
+	unsigned long int 	param1;
+	unsigned long int 	param2;
+}AMP_Control;
+
+enum SPEAKER_CHANNEL
+{
+      Channel_None = 0 ,
+      Channel_Right,
+      Channel_Left,
+      Channel_Stereo
+};
+
+bool Speaker_Init(void);
+bool Speaker_DeInit(void);
+bool Speaker_Register(void);
+int  ExternalAmp(void);
+
+void Sound_Speaker_Turnon(int channel);
+void Sound_Speaker_Turnoff(int channel);
+void Sound_Speaker_SetVolLevel(int level);
+
+void Sound_Headset_Turnon(void);
+void Sound_Headset_Turnoff(void);
+
+//now for  kernal use
+void AudioAMPDevice_Suspend(void);
+void AudioAMPDevice_Resume(void);
+// used for AEE beep sound
+void AudioAMPDevice_SpeakerLouderOpen(void); //some times kernal need to force  speaker for notification
+void AudioAMPDevice_SpeakerLouderClose(void);
+void AudioAMPDevice_mute(void);
+
+
+int Audio_eamp_command(unsigned int type, unsigned long args, unsigned int count);
+
+
+
+
+kal_int32 Sound_ExtFunction(const char* name, void* param, int param_size);
+
+
+#endif
+
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/yusu_android_speaker.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/yusu_android_speaker.c
new file mode 100755
index 0000000..3f6e8b9
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/sound/yusu_android_speaker.c
@@ -0,0 +1,272 @@
+/*****************************************************************************
+*                E X T E R N A L      R E F E R E N C E S
+******************************************************************************
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/vmalloc.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/semaphore.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include "yusu_android_speaker.h"
+
+/*****************************************************************************
+*                C O M P I L E R      F L A G S
+******************************************************************************
+*/
+#define CONFIG_DEBUG_MSG
+#ifdef CONFIG_DEBUG_MSG
+#define PRINTK(format, args...) printk( KERN_EMERG format,##args )
+#else
+#define PRINTK(format, args...)
+#endif
+
+#define AMP_CLASS_AB
+//#define AMP_CLASS_D
+//#define ENABLE_2_IN_1_SPK
+
+#if !defined(AMP_CLASS_AB) && !defined(AMP_CLASS_D)
+#error "MT6323 SPK AMP TYPE does not be defined!!!"
+#endif
+/*****************************************************************************
+*                          C O N S T A N T S
+******************************************************************************
+*/
+
+#define SPK_WARM_UP_TIME        (55) //unit is ms
+#define SPK_AMP_GAIN            (4)  //4:15dB
+#define RCV_AMP_GAIN            (1)  //1:-3dB
+#define SPK_R_ENABLE            (1)
+#define SPK_L_ENABLE            (1)
+/*****************************************************************************
+*                         D A T A      T Y P E S
+******************************************************************************
+*/
+static int Speaker_Volume=0;
+static bool gsk_on=false; // speaker is open?
+static bool gsk_resume=false;
+static bool gsk_forceon=false;
+/*****************************************************************************
+*                  F U N C T I O N        D E F I N I T I O N
+******************************************************************************
+*/
+extern void Yusu_Sound_AMP_Switch(BOOL enable);
+
+bool Speaker_Init(void)
+{
+   PRINTK("+Speaker_Init Success");
+#if defined(AMP_CLASS_AB)
+
+#elif defined(AMP_CLASS_D)
+
+#endif
+   //by zhu
+   mt_set_gpio_mode(GPIO_EXT_SPKAMP_EN_PIN,GPIO_MODE_00);  // gpio mode
+   mt_set_gpio_pull_enable(GPIO_EXT_SPKAMP_EN_PIN,GPIO_PULL_ENABLE);
+   mt_set_gpio_dir(GPIO_EXT_SPKAMP_EN_PIN,GPIO_DIR_OUT); // output
+   mt_set_gpio_out(GPIO_EXT_SPKAMP_EN_PIN,GPIO_OUT_ZERO); // high
+//by zhu end
+   PRINTK("-Speaker_Init Success");
+   return true;
+}
+
+bool Speaker_Register(void)
+{
+    return false;
+}
+
+int ExternalAmp(void)
+{
+	return 0;
+}
+
+bool Speaker_DeInit(void)
+{
+	return false;
+}
+
+void Sound_SpeakerL_SetVolLevel(int level)
+{
+   PRINTK(" Sound_SpeakerL_SetVolLevel level=%d\n",level);
+}
+
+void Sound_SpeakerR_SetVolLevel(int level)
+{
+   PRINTK(" Sound_SpeakerR_SetVolLevel level=%d\n",level);
+}
+
+void Sound_Speaker_Turnon(int channel)
+{
+    PRINTK("Sound_Speaker_Turnon channel = %d\n",channel);
+//by zhu
+    if(gsk_on)
+		return;
+    mt_set_gpio_dir(GPIO_EXT_SPKAMP_EN_PIN,GPIO_DIR_OUT); // output
+    mt_set_gpio_out(GPIO_EXT_SPKAMP_EN_PIN,GPIO_OUT_ONE); // high
+    msleep(SPK_WARM_UP_TIME);//by zhu
+#if defined(ENABLE_2_IN_1_SPK)
+#if defined(AMP_CLASS_D)
+
+#endif
+#endif
+#if defined(AMP_CLASS_AB)
+
+#elif defined(AMP_CLASS_D)
+
+#endif
+    //msleep(SPK_WARM_UP_TIME);
+    gsk_on = true;
+}
+
+void Sound_Speaker_Turnoff(int channel)
+{
+    PRINTK("Sound_Speaker_Turnoff channel = %d\n",channel);
+	if(!gsk_on)
+		return;
+#if defined(AMP_CLASS_AB)
+
+#elif defined(AMP_CLASS_D)
+
+#endif
+//by zhu
+    mt_set_gpio_dir(GPIO_EXT_SPKAMP_EN_PIN,GPIO_DIR_OUT); // output
+    mt_set_gpio_out(GPIO_EXT_SPKAMP_EN_PIN,GPIO_OUT_ZERO); // low
+    msleep(500);
+//by zhu
+	gsk_on = false;
+}
+
+void Sound_Speaker_SetVolLevel(int level)
+{
+    Speaker_Volume =level;
+}
+
+void Sound_Headset_Turnon(void)
+{
+}
+
+void Sound_Headset_Turnoff(void)
+{
+}
+
+void Sound_Earpiece_Turnon(void)
+{
+#if defined(ENABLE_2_IN_1_SPK)
+
+#if defined(AMP_CLASS_D)
+
+#endif
+
+#endif
+}
+
+void Sound_Earpiece_Turnoff(void)
+{
+#if defined(ENABLE_2_IN_1_SPK)
+
+#if defined(AMP_CLASS_D)
+
+#endif
+
+#endif
+}
+
+//kernal use
+void AudioAMPDevice_Suspend(void)
+{
+	PRINTK("AudioDevice_Suspend\n");
+	if(gsk_on)
+	{
+		Sound_Speaker_Turnoff(Channel_Stereo);
+		gsk_resume = true;
+	}
+
+}
+void AudioAMPDevice_Resume(void)
+{
+	PRINTK("AudioDevice_Resume\n");
+	if(gsk_resume)
+		Sound_Speaker_Turnon(Channel_Stereo);
+	gsk_resume = false;
+}
+void AudioAMPDevice_SpeakerLouderOpen(void)
+{
+	PRINTK("AudioDevice_SpeakerLouderOpen\n");
+	gsk_forceon = false;
+	if(gsk_on)
+		return;
+	Sound_Speaker_Turnon(Channel_Stereo);
+	gsk_forceon = true;
+	return ;
+
+}
+void AudioAMPDevice_SpeakerLouderClose(void)
+{
+	PRINTK("AudioDevice_SpeakerLouderClose\n");
+
+	if(gsk_forceon)
+		Sound_Speaker_Turnoff(Channel_Stereo);
+	gsk_forceon = false;
+
+}
+void AudioAMPDevice_mute(void)
+{
+	PRINTK("AudioDevice_mute\n");
+	if(gsk_on)
+		Sound_Speaker_Turnoff(Channel_Stereo);
+}
+
+int Audio_eamp_command(unsigned int type, unsigned long args, unsigned int count)
+{
+	return 0;
+}
+static char *ExtFunArray[] =
+{
+    "InfoMATVAudioStart",
+    "InfoMATVAudioStop",
+    "End",
+};
+
+kal_int32 Sound_ExtFunction(const char* name, void* param, int param_size)
+{
+	int i = 0;
+	int funNum = -1;
+
+	//Search the supported function defined in ExtFunArray
+	while(strcmp("End",ExtFunArray[i]) != 0 ) {		//while function not equal to "End"
+
+	    if (strcmp(name,ExtFunArray[i]) == 0 ) {		//When function name equal to table, break
+	    	funNum = i;
+	    	break;
+	    }
+	    i++;
+	}
+
+	switch (funNum) {
+	    case 0:			//InfoMATVAudioStart
+	        printk("RunExtFunction InfoMATVAudioStart \n");
+	        break;
+
+	    case 1:			//InfoMATVAudioStop
+	        printk("RunExtFunction InfoMATVAudioStop \n");
+	        break;
+
+	    default:
+	    	 break;
+	}
+
+	return 1;
+}
+
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/Makefile b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/Makefile
new file mode 100755
index 0000000..923e582
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/Makefile
@@ -0,0 +1,3 @@
+include $(srctree)/drivers/misc/mediatek/Makefile.custom
+obj-$(CONFIG_MTK_VIBRATOR) := cust_vibrator.o
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/cust_vibrator.c b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/cust_vibrator.c
new file mode 100755
index 0000000..20663f5
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/cust_vibrator.c
@@ -0,0 +1,18 @@
+#include <cust_vibrator.h>
+#include <linux/types.h>
+
+static struct vibrator_hw cust_vibrator_hw = {
+	.vib_timer = 25,
+  #ifdef CUST_VIBR_LIMIT
+	.vib_limit = 9,
+  #endif
+  #ifdef CUST_VIBR_VOL
+	.vib_vol = 0x5,//2.8V for vibr
+  #endif
+};
+
+struct vibrator_hw *get_cust_vibrator_hw(void)
+{
+    return &cust_vibrator_hw;
+}
+
diff --git a/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/cust_vibrator.h b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/cust_vibrator.h
new file mode 100755
index 0000000..f6965a2
--- /dev/null
+++ b/drivers/misc/mediatek/mach/mt6735/X5PRO_6735m/vibrator/cust_vibrator.h
@@ -0,0 +1,24 @@
+#ifndef __CUST_VIBRATOR_H__
+#define __CUST_VIBRATOR_H__
+
+#include <mach/mt_reg_base.h>
+#include <mach/mt_typedefs.h>
+#include <mach/mt_gpio.h>
+#include <mach/mt_pm_ldo.h>
+
+#define CUST_VIBR_LIMIT
+#define CUST_VIBR_VOL
+/*----------------------------------------------------------------------------*/
+struct vibrator_hw {
+	int	vib_timer;
+#ifdef CUST_VIBR_LIMIT
+	int	vib_limit;
+#endif
+#ifdef CUST_VIBR_VOL
+	int	vib_vol;
+#endif
+};
+/*----------------------------------------------------------------------------*/
+extern struct vibrator_hw *get_cust_vibrator_hw(void);
+/*----------------------------------------------------------------------------*/
+#endif
diff --git a/tools/dct/DCT.log b/tools/dct/DCT.log
deleted file mode 100644
index e64b9e9..0000000
--- a/tools/dct/DCT.log
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Log generated by MTK SP DrvGen Version 03.13.6;
- Log Time is Mon May 09 15:11:53 2016
- */
-open operater parse MT6735M.fig OK!
-Edit operater parse .cmp file OK!
-Gencode operater parse .cmp file OK!
-Gencode cust_eint_md1.h OK!
-Gencode cust_power.h OK!
-- 
2.7.4

