From 9cd77df7082b0bf43a5c6d85f3992d409fffa10c Mon Sep 17 00:00:00 2001
From: olegsvs <oleg.texet@gmail.com>
Date: Sun, 8 May 2016 15:40:42 +0300
Subject: [PATCH 011/117] stk3x1x 2/2

---
 arch/arm64/configs/benefit_m7_defconfig            |    4 +-
 drivers/misc/Kconfig                               |    7 -
 drivers/misc/Makefile                              |    1 -
 drivers/misc/mediatek/alsps/Makefile               |    3 +
 drivers/misc/mediatek/alsps/cm3232-new/cm3232.c    | 1627 +----------
 drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x.c  | 3068 +++++++++++++++-----
 drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x.h  |   15 +-
 .../alsps/stk3x1x-new/stk3x1x_cust_alsps.c         |   91 +
 .../alsps/stk3x1x-new/stk3x1x_cust_alsps.h         |   65 +
 .../misc/mediatek/alsps/stk3x1x_driver/stk3x1x.h   |    4 +-
 .../jd9367_6735_dsi_video/jd9367_6735_dsi_video.c  |   11 +-
 .../misc/mediatek/mach/mt6735/benefit_m7/Makefile  |    9 +
 .../benefit_m7/alsps/stk3x1x-new/cust_alsps.c      |   33 +-
 .../benefit_m7/alsps/stk3x1x_driver/cust_alsps.c   |    1 -
 include/config/auto.conf                           |    2 +-
 include/config/mtk/stk3x1x/driver.h                |    0
 include/generated/autoconf.h                       |    2 +-
 include/generated/compile.h                        |    4 +-
 tools/dct/DCT.log                                  |    5 -
 19 files changed, 2637 insertions(+), 2315 deletions(-)
 create mode 100644 drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x_cust_alsps.c
 create mode 100644 drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x_cust_alsps.h
 create mode 100644 include/config/mtk/stk3x1x/driver.h

diff --git a/arch/arm64/configs/benefit_m7_defconfig b/arch/arm64/configs/benefit_m7_defconfig
index d3d279a..9d85653 100644
--- a/arch/arm64/configs/benefit_m7_defconfig
+++ b/arch/arm64/configs/benefit_m7_defconfig
@@ -1287,8 +1287,8 @@ CONFIG_MTK_SIM2=y
 # CONFIG_MTK_APM_16D is not set
 # CONFIG_MTK_EPL2182 is not set
 # CONFIG_MTK_EPL2182_NEW is not set
-CONFIG_MTK_STK3X1X_NEW=y
-CONFIG_MTK_STK3X1X_DRIVER=n
+CONFIG_MTK_STK3X1X_NEW=n
+CONFIG_MTK_STK3X1X_DRIVER=y
 # CONFIG_MTK_CM36652_NEW is not set
 # CONFIG_MTK_APDS9930 is not set
 # CONFIG_MTK_CM3232_NEW is not set
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 1eebc7f..9a31536 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -81,13 +81,6 @@ config ATMEL_TCLIB
 	  blocks found on many Atmel processors.  This facilitates using
 	  these blocks by different drivers despite processor differences.
 
-config POCKETMOD
-	bool "PocketMod for device wake modifications"
-	default y
-	help
-		Say Y here to enable PocketMod. Users can always
-		toggle this on/off from sysfs later (should they
-		want it)  
 
 
 config ATMEL_TCB_CLKSRC
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index ba75cf3..11bae8e 100755
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -17,7 +17,6 @@ obj-$(CONFIG_BMP085_SPI)	+= bmp085-spi.o
 obj-$(CONFIG_DUMMY_IRQ)		+= dummy-irq.o
 obj-$(CONFIG_ICS932S401)	+= ics932s401.o
 obj-$(CONFIG_LKDTM)		+= lkdtm.o
-obj-$(CONFIG_POCKETMOD)		+= pocket_mod.o
 obj-$(CONFIG_TIFM_CORE)       	+= tifm_core.o
 obj-$(CONFIG_TIFM_7XX1)       	+= tifm_7xx1.o
 obj-$(CONFIG_PHANTOM)		+= phantom.o
diff --git a/drivers/misc/mediatek/alsps/Makefile b/drivers/misc/mediatek/alsps/Makefile
index 8198412..86719b1 100644
--- a/drivers/misc/mediatek/alsps/Makefile
+++ b/drivers/misc/mediatek/alsps/Makefile
@@ -27,6 +27,9 @@ endif
 ifeq ($(CONFIG_MTK_STK3X1X),y)
 obj-y	+=  stk3x1x/
 endif
+ifeq ($(CONFIG_MTK_STK3X1X_DRIVER),y)
+obj-y	+=  stk3x1x_driver/
+endif
 ifeq ($(CONFIG_MTK_CM36652_NEW),y)
 obj-y	+=  cm36652-new/
 endif
diff --git a/drivers/misc/mediatek/alsps/cm3232-new/cm3232.c b/drivers/misc/mediatek/alsps/cm3232-new/cm3232.c
index 787db70..759cc27 100644
--- a/drivers/misc/mediatek/alsps/cm3232-new/cm3232.c
+++ b/drivers/misc/mediatek/alsps/cm3232-new/cm3232.c
@@ -1,6 +1,4 @@
 /* 
- * Author: yucong xiong <yucong.xion@mediatek.com>
- *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
  * may be copied, distributed, and modified under those terms.
@@ -11,1572 +9,113 @@
  * GNU General Public License for more details.
  *
  */
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/slab.h>
-#include <linux/irq.h>
-#include <linux/miscdevice.h>
-#include <asm/uaccess.h>
-#include <linux/delay.h>
-#include <linux/input.h>
-#include <linux/workqueue.h>
-#include <linux/kobject.h>
-#include <linux/earlysuspend.h>
-#include <linux/platform_device.h>
-#include <asm/atomic.h>
-
-//#include <mach/mt_devs.h>
-#include <mach/mt_typedefs.h>
-#include <mach/mt_gpio.h>
-#include <mach/mt_pm_ldo.h>
-
-#define POWER_NONE_MACRO MT65XX_POWER_NONE
-
-#include <linux/hwmsensor.h>
-#include <linux/hwmsen_dev.h>
-#include <linux/sensors_io.h>
-#include <asm/io.h>
-#include <cust_eint.h>
-#include <cust_alsps.h>
-#include "cm3232.h"
-//#include <linux/hw_module_info.h>
-#include <linux/sched.h>
-#include <alsps.h>
-#include <linux/batch.h>
-
-#ifdef CUSTOM_KERNEL_SENSORHUB
-#include <SCP_sensorHub.h>
-#endif
-
-/******************************************************************************
- * configuration
-*******************************************************************************/
-/*----------------------------------------------------------------------------*/
-
-#define CM3232_DEV_NAME     "cm3232"
-/*----------------------------------------------------------------------------*/
-#define APS_TAG                  "[ALS/PS] "
-#define APS_FUN(f)               printk(KERN_INFO APS_TAG"%s\n", __FUNCTION__)
-#define APS_ERR(fmt, args...)    printk(KERN_ERR  APS_TAG"%s %d : "fmt, __FUNCTION__, __LINE__, ##args)
-#define APS_LOG(fmt, args...)    printk(KERN_INFO APS_TAG fmt, ##args)
-#define APS_DBG(fmt, args...)    printk(KERN_INFO APS_TAG fmt, ##args)                 
-/******************************************************************************
- * extern functions
-*******************************************************************************/
-		extern void mt65xx_eint_unmask(unsigned int line);
-		extern void mt65xx_eint_mask(unsigned int line);
-		extern void mt65xx_eint_set_polarity(unsigned int eint_num, unsigned int pol);
-		extern void mt65xx_eint_set_hw_debounce(unsigned int eint_num, unsigned int ms);
-		extern unsigned int mt65xx_eint_set_sens(unsigned int eint_num, unsigned int sens);
-		extern void mt65xx_eint_registration(unsigned int eint_num, unsigned int is_deb_en, unsigned int pol, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
-
-/*----------------------------------------------------------------------------*/
-static int cm3232_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id); 
-static int cm3232_i2c_remove(struct i2c_client *client);
-static int cm3232_i2c_detect(struct i2c_client *client, struct i2c_board_info *info);
-static int cm3232_i2c_suspend(struct i2c_client *client, pm_message_t msg);
-static int cm3232_i2c_resume(struct i2c_client *client);
-
-static int cm3232_remove(void);
-static int cm3232_local_init(void);
-
-static int cm3232_init_flag =-1; // 0<==>OK -1 <==> fail
-static struct alsps_init_info cm3232_init_info = {
-		.name = "cm3232",
-		.init = cm3232_local_init,
-		.uninit = cm3232_remove,
-};
-
-
-/*----------------------------------------------------------------------------*/
-static const struct i2c_device_id cm3232_i2c_id[] = {{CM3232_DEV_NAME,0},{}};
-static struct i2c_board_info __initdata i2c_cm3232={ I2C_BOARD_INFO(CM3232_DEV_NAME, (0x20>>1))};
-/*----------------------------------------------------------------------------*/
+/*
+ * Definitions for CM3232 als/ps sensor chip.
+ */
+#ifndef __CM3232_H__
+#define __CM3232_H__
+
+#include <linux/ioctl.h>
 
-/*static hw_module_info hw_info = {
-	.type = HW_MODULE_TYPE_ALSPS,
-	.id = 0x10,
-	.priority = HW_MODULE_PRIORITY_ALSPS,
-	.name = "CM3232",
-	.vendor = "CAPELLA",
-	.more = ""
-};*/
+/*cm3232 als/ps sensor register related macro*/
+#define CM3232_REG_ALS_CONF 		0X00
+#define CM3232_REG_ALS_THDH 		0X01
+#define CM3232_REG_ALS_THDL 		0X02
+#define CM3232_REG_PS_CONF1_2		0X03
+#define CM3232_REG_PS_CONF3_MS		0X04
+#define CM3232_REG_PS_CANC			0X05
+#define CM3232_REG_PS_THD			0X06
+#define CM3232_REG_PS_DATA			0X08
+#define CM3232_REG_ALS_DATA		0X50
+#define CM3232_REG_INT_FLAG		0X0B
+#define CM3232_REG_ID_MODE			0X0C
 
-struct cm3232_priv {
-	struct alsps_hw  *hw;
-	struct i2c_client *client;
-	struct work_struct	eint_work;
-#ifdef CUSTOM_KERNEL_SENSORHUB
-	struct work_struct init_done_work;
-#endif
+/*CM3232 related driver tag macro*/
+#define CM3232_SUCCESS				 		 0
+#define CM3232_ERR_I2C						-1
+#define CM3232_ERR_STATUS					-3
+#define CM3232_ERR_SETUP_FAILURE			-4
+#define CM3232_ERR_GETGSENSORDATA			-5
+#define CM3232_ERR_IDENTIFICATION			-6
 
-	/*misc*/
-	u16 		als_modulus;
-	atomic_t	i2c_retry;
-	atomic_t	als_suspend;
-	atomic_t	als_debounce;	/*debounce time after enabling als*/
-	atomic_t	als_deb_on; 	/*indicates if the debounce is on*/
-	atomic_t	als_deb_end;	/*the jiffies representing the end of debounce*/
-	atomic_t 	trace;
-	
-	
-	/*data*/
-	u16			als;
-	u8			_align;
-	u16			als_level_num;
-	u16			als_value_num;
-	u32			als_level[C_CUST_ALS_LEVEL-1];
-	u32			als_value[C_CUST_ALS_LEVEL];
-	
-	atomic_t	als_cmd_val;	/*the cmd value can't be read, stored in ram*/
-	atomic_t	als_thd_val_high;	 /*the cmd value can't be read, stored in ram*/
-	atomic_t	als_thd_val_low; 	/*the cmd value can't be read, stored in ram*/
-	ulong		enable; 		/*enable mask*/
-	ulong		pending_intr;	/*pending interrupt*/
-	
-	/*early suspend*/
-	#if defined(CONFIG_HAS_EARLYSUSPEND)
-	struct early_suspend	early_drv;
-	#endif     
-};
-/*----------------------------------------------------------------------------*/
+#define ALS_K_VALUE 	20
 
-static struct i2c_driver cm3232_i2c_driver = {	
-	.probe      = cm3232_i2c_probe,
-	.remove     = cm3232_i2c_remove,
-	.detect     = cm3232_i2c_detect,
-	.suspend    = cm3232_i2c_suspend,
-	.resume     = cm3232_i2c_resume,
-	.id_table   = cm3232_i2c_id,
-	.driver = {
-		.name = CM3232_DEV_NAME,
-	},
-};
-/*----------------------------------------------------------------------------*/
-static struct i2c_client *cm3232_i2c_client = NULL;
-//static struct cm3232_priv *g_cm3232_ptr = NULL;
-static struct cm3232_priv *cm3232_obj = NULL;
-//static struct platform_driver cm3232_alsps_driver;
 /*----------------------------------------------------------------------------*/
-
-
+typedef enum{
+    CM3232_NOTIFY_PROXIMITY_CHANGE = 1,
+}CM3232_NOTIFY_TYPE;
 /*----------------------------------------------------------------------------*/
-typedef enum {
-	CMC_BIT_ALS    = 1,
-}CMC_BIT;
-/*-----------------------------CMC for debugging-------------------------------*/
-typedef enum {
-    CMC_TRC_ALS_DATA= 0x0001,
-    CMC_TRC_EINT    = 0x0004,
-    CMC_TRC_IOCTL   = 0x0008,
-    CMC_TRC_I2C     = 0x0010,
-    CMC_TRC_CVT_ALS = 0x0020,
-    CMC_TRC_DEBUG   = 0x8000,
-} CMC_TRC;
+typedef enum{
+    CM3232_CUST_ACTION_SET_CUST = 1,
+    CM3232_CUST_ACTION_CLR_CALI,
+    CM3232_CUST_ACTION_SET_CALI,
+    CM3232_CUST_ACTION_SET_PS_THRESHODL,
+    CM3232_CUST_ACTION_SET_EINT_INFO,
+    CM3232_CUST_ACTION_GET_ALS_RAW_DATA,
+    CM3232_CUST_ACTION_GET_PS_RAW_DATA,
+}CM3232_CUST_ACTION;
 /*----------------------------------------------------------------------------*/
-static void cm3232_power(struct alsps_hw *hw, unsigned int on) 
-{
-	static unsigned int power_on = 0;
-
-	APS_LOG("power %s\n", on ? "on" : "off");
-
-	if(hw->power_id != POWER_NONE_MACRO)
-	{
-		if(power_on == on)
-		{
-			APS_LOG("ignore power control: %d\n", on);
-		}
-		else if(on)
-		{
-			if(!hwPowerOn(hw->power_id, hw->power_vol, "CM3232")) 
-			{
-				APS_ERR("power on fails!!\n");
-			}
-		}
-		else
-		{
-			if(!hwPowerDown(hw->power_id, "CM3232")) 
-			{
-				APS_ERR("power off fail!!\n");   
-			}
-		}
-	}
-	power_on = on;
-}
-/********************************************************************/
-int cm3232_enable_als(struct i2c_client *client, int enable)
-{
-	struct cm3232_priv *obj = i2c_get_clientdata(client);
-	int res;
-	u8 databuf[3];
-	client->addr &=I2C_MASK_FLAG;
-	client->addr |=I2C_WR_FLAG;
-	client->addr |=I2C_RS_FLAG;
-	if(enable == 1)
-		{
-			APS_LOG("cm3232_enable_als enable_als\n");
-#if 0//modify for cm3232 speed up report rate.131012 xgt
-			databuf[0] = CM3232_REG_ALS_CONF;
-			res = i2c_master_send(client, databuf, 0x201);
-			if(res < 0)
-			{
-				APS_ERR("i2c_master_send function err\n");
-				goto ENABLE_ALS_EXIT_ERR;
-			}
-			
-			APS_LOG("CM3232_REG_ALS_CONF evalue value_low = %x, value_high = %x\n",databuf[0],databuf[1]);
-#endif
-			databuf[1] = 0x00;//databuf[0]&0xFE;		
-			databuf[0] = CM3232_REG_ALS_CONF;
-			client->addr &=I2C_MASK_FLAG;
-			
-			res = i2c_master_send(client, databuf, 0x2);
-			if(res < 0)
-			{
-				APS_ERR("i2c_master_send function err\n");
-				goto ENABLE_ALS_EXIT_ERR;
-			}
-			atomic_set(&obj->als_deb_on, 1);
-			atomic_set(&obj->als_deb_end, jiffies+atomic_read(&obj->als_debounce)/(1000/HZ));
-		}
-	else{
-			APS_LOG("cm3232_enable_als disable_als\n");
-#if 0//modify for cm3232 speed up report rate.131012 xgt
-			databuf[0] = CM3232_REG_ALS_CONF;
-			res = i2c_master_send(client, databuf, 0x201);
-			if(res < 0)
-			{
-				APS_ERR("i2c_master_send function err\n");
-				goto ENABLE_ALS_EXIT_ERR;
-			}
-			
-			APS_LOG("CM3232_REG_ALS_CONF dvalue value_low = %x, value_high = %x\n",databuf[0],databuf[1]);
-#endif
-			databuf[1] = 0x01;//databuf[0]|0x01;
-			databuf[0] = CM3232_REG_ALS_CONF;
-			client->addr &=I2C_MASK_FLAG;
-
-			res = i2c_master_send(client, databuf, 0x2);
-			if(res < 0)
-			{
-				APS_ERR("i2c_master_send function err\n");
-				goto ENABLE_ALS_EXIT_ERR;
-			}
-			atomic_set(&obj->als_deb_on, 0);
-		}
-	return 0;
-	ENABLE_ALS_EXIT_ERR:
-	return res;
-}
-/********************************************************************/
-long cm3232_read_als(struct i2c_client *client, u16 *data)
+typedef struct
 {
-	long res;
-	u8 databuf[2];
-	client->addr &=I2C_MASK_FLAG;
-	client->addr |=I2C_WR_FLAG;
-	client->addr |=I2C_RS_FLAG;
-	APS_FUN(f);
-	
-	databuf[0] = CM3232_REG_ALS_DATA;
-	res = i2c_master_send(client, databuf, 0x201);
-	if(res < 0)
-	{
-		APS_ERR("i2c_master_send function err\n");
-		goto READ_ALS_EXIT_ERR;
-	}
-	
-	APS_LOG("CM3232_REG_ALS_DATA value value_low = %x, value_high = %x\n",databuf[0],databuf[1]);
-
-	*data = ((databuf[1]<<8)|databuf[0]);
-	return 0;
-	READ_ALS_EXIT_ERR:
-	return res;
-}
-/********************************************************************/
-static int cm3232_get_als_value(struct cm3232_priv *obj, u16 als)
-{
-		int idx;
-		int invalid = 0;
-		for(idx = 0; idx < obj->als_level_num; idx++)
-		{
-			if((als/ALS_K_VALUE) < obj->hw->als_level[idx])
-			{
-				break;
-			}
-		}
-		if(idx >= obj->als_value_num)
-		{
-			APS_ERR("exceed range\n"); 
-			idx = obj->als_value_num - 1;
-		}
-		
-		if(1 == atomic_read(&obj->als_deb_on))
-		{
-			unsigned long endt = atomic_read(&obj->als_deb_end);
-			if(time_after(jiffies, endt))
-			{
-				atomic_set(&obj->als_deb_on, 0);
-			}
-			
-			if(1 == atomic_read(&obj->als_deb_on))
-			{
-				invalid = 1;
-			}
-		}
-	
-		if(!invalid)
-		{
-			if (atomic_read(&obj->trace) & CMC_TRC_CVT_ALS)
-			{
-				APS_DBG("ALS: %05d => %05d\n", als, obj->hw->als_value[idx]);
-			}
-			
-			return obj->hw->als_value[idx];
-		}
-		else
-		{
-			if(atomic_read(&obj->trace) & CMC_TRC_CVT_ALS)
-			{
-				APS_DBG("ALS: %05d => %05d (-1)\n", als, obj->hw->als_value[idx]);	  
-			}
-			return -1;
-		}
-
-}
-
-
-/*-------------------------------attribute file for debugging----------------------------------*/
-
-/******************************************************************************
- * Sysfs attributes
-*******************************************************************************/
-static ssize_t cm3232_show_config(struct device_driver *ddri, char *buf)
-{
-	ssize_t res;
-	
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	
-	res = snprintf(buf, PAGE_SIZE, "(%d %d)\n", 
-		atomic_read(&cm3232_obj->i2c_retry), atomic_read(&cm3232_obj->als_debounce));     
-	return res;    
-}
+    uint16_t    action;
+}CM3232_CUST;
 /*----------------------------------------------------------------------------*/
-static ssize_t cm3232_store_config(struct device_driver *ddri, const char *buf, size_t count)
+typedef struct
 {
-	int retry, als_deb,mask, thres;
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	
-	if(5 == sscanf(buf, "%d %d %d %d", &retry, &als_deb, &mask, &thres))
-	{ 
-		atomic_set(&cm3232_obj->i2c_retry, retry);
-		atomic_set(&cm3232_obj->als_debounce, als_deb);
-	}
-	else
-	{
-		APS_ERR("invalid content: '%s', length = %zu\n", buf, count);
-	}
-	return count;    
-}
+    uint16_t    action;
+    uint16_t    part;
+    int32_t    data[0];
+}CM3232_SET_CUST;
 /*----------------------------------------------------------------------------*/
-static ssize_t cm3232_show_trace(struct device_driver *ddri, char *buf)
-{
-	ssize_t res;
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-
-	res = snprintf(buf, PAGE_SIZE, "0x%04X\n", atomic_read(&cm3232_obj->trace));     
-	return res;    
-}
+typedef CM3232_CUST CM3232_CLR_CALI;
 /*----------------------------------------------------------------------------*/
-static ssize_t cm3232_store_trace(struct device_driver *ddri, const char *buf, size_t count)
+typedef struct
 {
-    int trace;
-    if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	
-	if(1 == sscanf(buf, "0x%x", &trace))
-	{
-		atomic_set(&cm3232_obj->trace, trace);
-	}
-	else 
-	{
-		APS_ERR("invalid content: '%s', length = %zu\n", buf, count);
-	}
-	return count;    
-}
+    uint16_t    action;
+    int32_t     cali;
+}CM3232_SET_CALI;
 /*----------------------------------------------------------------------------*/
-static ssize_t cm3232_show_als(struct device_driver *ddri, char *buf)
+typedef struct
 {
-	int res;
-	
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	if((res = cm3232_read_als(cm3232_obj->client, &cm3232_obj->als)))
-	{
-		return snprintf(buf, PAGE_SIZE, "ERROR: %d\n", res);
-	}
-	else
-	{
-		return snprintf(buf, PAGE_SIZE, "0x%04X\n", cm3232_obj->als);     
-	}
-}
+    uint16_t    action;
+    int32_t     threshold[2];
+}CM3232_SET_PS_THRESHOLD;
 /*----------------------------------------------------------------------------*/
-static ssize_t cm3232_show_reg(struct device_driver *ddri, char *buf)
+typedef struct
 {
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	
-	
-	return 0;
-}
-#if 0
+    uint16_t    action;
+    uint32_t    gpio_pin;
+    uint32_t    gpio_mode;
+    uint32_t    eint_num;
+    uint32_t    eint_is_deb_en;
+    uint32_t    eint_type;
+}CM3232_SET_EINT_INFO;
 /*----------------------------------------------------------------------------*/
-static ssize_t cm3232_show_send(struct device_driver *ddri, char *buf)
+typedef struct
 {
-    return 0;
-}
+    uint16_t    action;
+    uint16_t    als;
+}CM3232_GET_ALS_RAW_DATA;
 /*----------------------------------------------------------------------------*/
-static ssize_t cm3232_store_send(struct device_driver *ddri, const char *buf, size_t count)
+typedef struct
 {
-	int addr, cmd;
-	u8 dat;
-
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	else if(2 != sscanf(buf, "%x %x", &addr, &cmd))
-	{
-		APS_ERR("invalid format: '%s'\n", buf);
-		return 0;
-	}
-
-	dat = (u8)cmd;
-	//****************************
-	return count;
-}
+    uint16_t    action;
+    uint16_t    ps;
+} CM3232_GET_PS_RAW_DATA;
 /*----------------------------------------------------------------------------*/
-static ssize_t cm3232_show_recv(struct device_driver *ddri, char *buf)
+typedef union
 {
-    return 0;
-}
+    uint32_t                    data[10];
+    CM3232_CUST                cust;
+    CM3232_SET_CUST            setCust;
+    CM3232_CLR_CALI            clearCali;
+    CM3232_SET_CALI            setCali;
+    CM3232_SET_PS_THRESHOLD    setPSThreshold;
+    CM3232_SET_EINT_INFO       setEintInfo;
+    CM3232_GET_ALS_RAW_DATA    getALSRawData;
+    CM3232_GET_PS_RAW_DATA     getPSRawData;
+}CM3232_CUST_DATA;
 /*----------------------------------------------------------------------------*/
-static ssize_t cm3232_store_recv(struct device_driver *ddri, const char *buf, size_t count)
-{
-	int addr;
-	//u8 dat;
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	else if(1 != sscanf(buf, "%x", &addr))
-	{
-		APS_ERR("invalid format: '%s'\n", buf);
-		return 0;
-	}
 
-	//****************************
-	return count;
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t cm3232_show_status(struct device_driver *ddri, char *buf)
-{
-	ssize_t len = 0;
-	
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	
-	if(cm3232_obj->hw)
-	{
-		len += snprintf(buf+len, PAGE_SIZE-len, "CUST: %d, (%d %d)\n", 
-			cm3232_obj->hw->i2c_num, cm3232_obj->hw->power_id, cm3232_obj->hw->power_vol);
-	}
-	else
-	{
-		len += snprintf(buf+len, PAGE_SIZE-len, "CUST: NULL\n");
-	}
-	
-	len += snprintf(buf+len, PAGE_SIZE-len, "REGS: %02X %02lX %02lX\n", 
-				atomic_read(&cm3232_obj->als_cmd_val),cm3232_obj->enable, cm3232_obj->pending_intr);
-	
-	len += snprintf(buf+len, PAGE_SIZE-len, "MISC: %d \n", atomic_read(&cm3232_obj->als_suspend));
-
-	return len;
-}
-/*----------------------------------------------------------------------------*/
-/*----------------------------------------------------------------------------*/
-#define IS_SPACE(CH) (((CH) == ' ') || ((CH) == '\n'))
-/*----------------------------------------------------------------------------*/
-static int read_int_from_buf(struct cm3232_priv *obj, const char* buf, size_t count, u32 data[], int len)
-{
-	int idx = 0;
-	char *cur = (char*)buf, *end = (char*)(buf+count);
-
-	while(idx < len)
-	{
-		while((cur < end) && IS_SPACE(*cur))
-		{
-			cur++;        
-		}
-
-		if(1 != sscanf(cur, "%d", &data[idx]))
-		{
-			break;
-		}
-
-		idx++; 
-		while((cur < end) && !IS_SPACE(*cur))
-		{
-			cur++;
-		}
-	}
-	return idx;
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t cm3232_show_alslv(struct device_driver *ddri, char *buf)
-{
-	ssize_t len = 0;
-	int idx;
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	
-	for(idx = 0; idx < cm3232_obj->als_level_num; idx++)
-	{
-		len += snprintf(buf+len, PAGE_SIZE-len, "%d ", cm3232_obj->hw->als_level[idx]);
-	}
-	len += snprintf(buf+len, PAGE_SIZE-len, "\n");
-	return len;    
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t cm3232_store_alslv(struct device_driver *ddri, const char *buf, size_t count)
-{
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	else if(!strcmp(buf, "def"))
-	{
-		memcpy(cm3232_obj->als_level, cm3232_obj->hw->als_level, sizeof(cm3232_obj->als_level));
-	}
-	else if(cm3232_obj->als_level_num != read_int_from_buf(cm3232_obj, buf, count, 
-			cm3232_obj->hw->als_level, cm3232_obj->als_level_num))
-	{
-		APS_ERR("invalid format: '%s'\n", buf);
-	}    
-	return count;
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t cm3232_show_alsval(struct device_driver *ddri, char *buf)
-{
-	ssize_t len = 0;
-	int idx;
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	
-	for(idx = 0; idx < cm3232_obj->als_value_num; idx++)
-	{
-		len += snprintf(buf+len, PAGE_SIZE-len, "%d ", cm3232_obj->hw->als_value[idx]);
-	}
-	len += snprintf(buf+len, PAGE_SIZE-len, "\n");
-	return len;    
-}
-/*----------------------------------------------------------------------------*/
-static ssize_t cm3232_store_alsval(struct device_driver *ddri, const char *buf, size_t count)
-{
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return 0;
-	}
-	else if(!strcmp(buf, "def"))
-	{
-		memcpy(cm3232_obj->als_value, cm3232_obj->hw->als_value, sizeof(cm3232_obj->als_value));
-	}
-	else if(cm3232_obj->als_value_num != read_int_from_buf(cm3232_obj, buf, count, 
-			cm3232_obj->hw->als_value, cm3232_obj->als_value_num))
-	{
-		APS_ERR("invalid format: '%s'\n", buf);
-	}    
-	return count;
-}
-/*---------------------------------------------------------------------------------------*/
 #endif
-static DRIVER_ATTR(als,     S_IWUSR | S_IRUGO, cm3232_show_als, NULL);
-static DRIVER_ATTR(config,  S_IWUSR | S_IRUGO, cm3232_show_config,	cm3232_store_config);
-static DRIVER_ATTR(alslv,   S_IWUSR | S_IRUGO, NULL, NULL);
-static DRIVER_ATTR(alsval,  S_IWUSR | S_IRUGO, NULL, NULL);
-static DRIVER_ATTR(trace,   S_IWUSR | S_IRUGO, cm3232_show_trace,		cm3232_store_trace);
-static DRIVER_ATTR(status,  S_IWUSR | S_IRUGO, NULL, NULL);
-static DRIVER_ATTR(send,    S_IWUSR | S_IRUGO, NULL, NULL);
-static DRIVER_ATTR(recv,    S_IWUSR | S_IRUGO, NULL, NULL);
-static DRIVER_ATTR(reg,     S_IWUSR | S_IRUGO, cm3232_show_reg, NULL);
-/*----------------------------------------------------------------------------*/
-static struct driver_attribute *cm3232_attr_list[] = {
-    &driver_attr_als,   
-    &driver_attr_trace,        /*trace log*/
-    &driver_attr_config,
-    &driver_attr_alslv,
-    &driver_attr_alsval,
-    &driver_attr_status,
-    &driver_attr_send,
-    &driver_attr_recv,
-    &driver_attr_reg,
-};
-
-/*----------------------------------------------------------------------------*/
-static int cm3232_create_attr(struct device_driver *driver) 
-{
-	int idx, err = 0;
-	int num = (int)(sizeof(cm3232_attr_list)/sizeof(cm3232_attr_list[0]));
-	if (driver == NULL)
-	{
-		return -EINVAL;
-	}
-
-	for(idx = 0; idx < num; idx++)
-	{
-		if((err = driver_create_file(driver, cm3232_attr_list[idx])))
-		{            
-			APS_ERR("driver_create_file (%s) = %d\n", cm3232_attr_list[idx]->attr.name, err);
-			break;
-		}
-	}    
-	return err;
-}
-/*----------------------------------------------------------------------------*/
-	static int cm3232_delete_attr(struct device_driver *driver)
-	{
-	int idx ,err = 0;
-	int num = (int)(sizeof(cm3232_attr_list)/sizeof(cm3232_attr_list[0]));
-
-	if (!driver)
-	return -EINVAL;
-
-	for (idx = 0; idx < num; idx++) 
-	{
-		driver_remove_file(driver, cm3232_attr_list[idx]);
-	}
-	
-	return err;
-}
-/*----------------------------------------------------------------------------*/
-
-#if 0//modify for CM3232 polling mode.131012 xgt
-/*----------------------------------interrupt functions--------------------------------*/
-static int intr_flag = 0;
-/*----------------------------------------------------------------------------*/
-static int cm3232_check_intr(struct i2c_client *client) 
-{
-	int res;
-	u8 databuf[2];
-	u8 intr;
-	
-	client->addr &=I2C_MASK_FLAG;
-	client->addr |=I2C_WR_FLAG;
-	client->addr |=I2C_RS_FLAG;
-	
-	databuf[0] = CM3232_REG_PS_DATA;
-	res = i2c_master_send(client, databuf, 0x201);
-	if(res<0)
-	{
-		APS_ERR("i2c_master_send function err res = %d\n",res);
-		goto EXIT_ERR;
-	}
-
-	APS_LOG("CM3232_REG_PS_DATA value value_low = %x, value_reserve = %x\n",databuf[0],databuf[1]);
-
-	client->addr &=I2C_MASK_FLAG;
-	client->addr |=I2C_WR_FLAG;
-	client->addr |=I2C_RS_FLAG;
-	
-	databuf[0] = CM3232_REG_INT_FLAG;
-	res = i2c_master_send(client, databuf, 0x201);
-	if(res<0)
-	{
-		APS_ERR("i2c_master_send function err res = %d\n",res);
-		goto EXIT_ERR;
-	}
-	
-	APS_LOG("CM3232_REG_INT_FLAG value value_low = %x, value_high = %x\n",databuf[0],databuf[1]);
-	
-	if(databuf[1]&0x02)
-	{
-		intr_flag = 0;//for close
-	}else if(databuf[1]&0x01)
-	{
-		intr_flag = 1;//for away
-	}else{
-		res = -1;
-		APS_ERR("cm3232_check_intr fail databuf[1]&0x01: %d\n", res);
-		goto EXIT_ERR;
-	}
-	
-	return 0;
-	EXIT_ERR:
-	APS_ERR("cm3232_check_intr dev: %d\n", res);
-	return res;
-}
-/*----------------------------------------------------------------------------*/
-static void cm3232_eint_work(struct work_struct *work)
-{
-	struct cm3232_priv *obj = (struct cm3232_priv *)container_of(work, struct cm3232_priv, eint_work);
-	hwm_sensor_data sensor_data;
-	int res = 0;
-	//res = cm3232_check_intr(obj->client);
-
-#if 1
-	//res = cm3232_check_intr(obj->client);
-	if(res != 0){
-		goto EXIT_INTR_ERR;
-	}else{
-		sensor_data.values[0] = intr_flag;
-		sensor_data.value_divide = 1;
-		sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;	
-
-	}
-	if((res = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data)))
-		{
-		  APS_ERR("call hwmsen_get_interrupt_data fail = %d\n", res);
-		  goto EXIT_INTR_ERR;
-		}
-#endif
-	//mt65xx_eint_unmask(CUST_EINT_ALS_NUM);
-	return;
-	EXIT_INTR_ERR:
-	//mt65xx_eint_unmask(CUST_EINT_ALS_NUM);
-	APS_ERR("cm3232_eint_work err: %d\n", res);
-}
-/*----------------------------------------------------------------------------*/
-static void cm3232_eint_func(void)
-{
-	struct cm3232_priv *obj = g_cm3232_ptr;
-	if(!obj)
-	{
-		return;
-	}	
-	APS_ERR("debug cm3232_eint_func!");
-	schedule_work(&obj->eint_work);
-}
-
-int cm3232_setup_eint(struct i2c_client *client)
-{
-	struct cm3232_priv *obj = i2c_get_clientdata(client);        
-
-	g_cm3232_ptr = obj;
-	
-	mt_set_gpio_dir(GPIO_ALS_EINT_PIN, GPIO_DIR_IN);
-	mt_set_gpio_mode(GPIO_ALS_EINT_PIN, GPIO_ALS_EINT_PIN_M_EINT);
-	mt_set_gpio_pull_enable(GPIO_ALS_EINT_PIN, TRUE);
-	mt_set_gpio_pull_select(GPIO_ALS_EINT_PIN, GPIO_PULL_UP);
-
-#if 0
-	mt65xx_eint_set_sens(CUST_EINT_ALS_NUM, CUST_EINT_ALS_SENSITIVE);
-	mt65xx_eint_set_polarity(CUST_EINT_ALS_NUM, CUST_EINT_ALS_POLARITY);
-	mt65xx_eint_set_hw_debounce(CUST_EINT_ALS_NUM, CUST_EINT_ALS_DEBOUNCE_CN);
-	mt65xx_eint_registration(CUST_EINT_ALS_NUM, CUST_EINT_ALS_DEBOUNCE_EN, CUST_EINT_ALS_POLARITY, cm3232_eint_func, 0);
-
-	mt65xx_eint_unmask(CUST_EINT_ALS_NUM);  
-#endif
-    return 0;
-}
-/*-------------------------------MISC device related------------------------------------------*/
-#endif
-
-#ifdef CUSTOM_KERNEL_SENSORHUB
-static void cm3232_init_done_work(struct work_struct *work)
-{
-    struct cm3232_priv *obj = cm3232_obj;
-    CM3232_CUST_DATA *p_cust_data;
-    SCP_SENSOR_HUB_DATA data;
-    int max_cust_data_size_per_packet;
-    int i;
-    uint sizeOfCustData;
-    uint len;
-    char *p = (char *)obj->hw;
-
-    APS_FUN();
-
-    p_cust_data = (CM3232_CUST_DATA *)data.set_cust_req.custData;
-    sizeOfCustData = sizeof(*(obj->hw));
-    max_cust_data_size_per_packet = sizeof(data.set_cust_req.custData) - offsetof(CM3232_SET_CUST, data);
-    
-    for (i=0;sizeOfCustData>0;i++)
-    {
-        data.set_cust_req.sensorType = ID_LIGHT;
-        data.set_cust_req.action = SENSOR_HUB_SET_CUST;
-        p_cust_data->setCust.action = CM3232_CUST_ACTION_SET_CUST;
-        p_cust_data->setCust.part = i;
-        
-        if (sizeOfCustData > max_cust_data_size_per_packet)
-        {
-            len = max_cust_data_size_per_packet;
-        }
-        else
-        {
-            len = sizeOfCustData;
-        }
-
-        memcpy(p_cust_data->setCust.data, p, len);
-        sizeOfCustData -= len;
-        p += len;
-        
-        len += offsetof(SCP_SENSOR_HUB_SET_CUST_REQ, custData) + offsetof(CM3232_SET_CUST, data);
-        SCP_sensorHub_req_send(&data, &len, 1);
-    }
-
-	#if 0
-    data.set_cust_req.sensorType = ID_PROXIMITY;
-    data.set_cust_req.action = SENSOR_HUB_SET_CUST;
-    p_cust_data->setEintInfo.action = CM3232_CUST_ACTION_SET_EINT_INFO;
-    p_cust_data->setEintInfo.gpio_mode = GPIO_ALS_EINT_PIN_M_EINT;
-    p_cust_data->setEintInfo.gpio_pin = GPIO_ALS_EINT_PIN;
-    p_cust_data->setEintInfo.eint_num = CUST_EINT_ALS_NUM;
-    p_cust_data->setEintInfo.eint_is_deb_en = CUST_EINT_ALS_DEBOUNCE_EN;
-    p_cust_data->setEintInfo.eint_type = CUST_EINT_ALS_TYPE;
-    len = offsetof(SCP_SENSOR_HUB_SET_CUST_REQ, custData) + sizeof(p_cust_data->setEintInfo);
-    SCP_sensorHub_req_send(&data, &len, 1);
-	#endif
-}
-
-static int cm3232_irq_handler(void* data, uint len)
-{
-	struct cm3232_priv *obj = cm3232_obj;
-    SCP_SENSOR_HUB_DATA_P rsp = (SCP_SENSOR_HUB_DATA_P)data;
-    
-	if(!obj)
-	{
-		return -1;
-	}
-
-    APS_ERR("len = %d, type = %d, action = %d, errCode = %d\n", len, rsp->rsp.sensorType, rsp->rsp.action, rsp->rsp.errCode);
-
-    switch(rsp->rsp.action)
-    {
-        case SENSOR_HUB_NOTIFY:
-            switch(rsp->notify_rsp.event)
-            {
-                case SCP_INIT_DONE:
-                    schedule_work(&obj->init_done_work);
-                    //schedule_delayed_work(&obj->init_done_work, HZ);
-                    break;
-				#if 0
-                case SCP_NOTIFY:
-                    if (CM3232_NOTIFY_PROXIMITY_CHANGE == rsp->notify_rsp.data[0])
-                    {
-                        intr_flag = rsp->notify_rsp.data[1];
-                        cm3232_eint_func();
-                    }
-                    else
-                    {
-                        APS_ERR("Unknow notify");
-                    }
-                    break;
-				#endif
-                default:
-                    APS_ERR("Error sensor hub notify");
-                    break;
-            }
-            break;
-        default:
-            APS_ERR("Error sensor hub action");
-            break;
-    }
-
-    return 0;
-}
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-
-
-/************************************************************/
-static int cm3232_open(struct inode *inode, struct file *file)
-{
-	file->private_data = cm3232_i2c_client;
-
-	if (!file->private_data)
-	{
-		APS_ERR("null pointer!!\n");
-		return -EINVAL;
-	}
-	return nonseekable_open(inode, file);
-}
-/************************************************************/
-static int cm3232_release(struct inode *inode, struct file *file)
-{
-	file->private_data = NULL;
-	return 0;
-}
-/************************************************************/
-static long cm3232_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-		struct i2c_client *client = (struct i2c_client*)file->private_data;
-		struct cm3232_priv *obj = i2c_get_clientdata(client);  
-		long err = 0;
-		void __user *ptr = (void __user*) arg;
-		int dat;
-		uint32_t enable;
-		
-		switch (cmd)
-		{			  
-			case ALSPS_SET_PS_MODE:
-			case ALSPS_GET_PS_MODE:
-			case ALSPS_GET_PS_DATA:    
-			case ALSPS_GET_PS_RAW_DATA:    
-	           	APS_LOG("ps not supported"); 
-				goto err_out;
-				
-			case ALSPS_SET_ALS_MODE:
-	
-				if(copy_from_user(&enable, ptr, sizeof(enable)))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}
-				if(enable)
-				{
-					if((err = cm3232_enable_als(obj->client, 1)))
-					{
-						APS_ERR("enable als fail: %ld\n", err); 
-						goto err_out;
-					}
-					set_bit(CMC_BIT_ALS, &obj->enable);
-				}
-				else
-				{
-					if((err = cm3232_enable_als(obj->client, 0)))
-					{
-						APS_ERR("disable als fail: %ld\n", err); 
-						goto err_out;
-					}
-					clear_bit(CMC_BIT_ALS, &obj->enable);
-				}
-				break;
-	
-			case ALSPS_GET_ALS_MODE:
-				enable = test_bit(CMC_BIT_ALS, &obj->enable) ? (1) : (0);
-				if(copy_to_user(ptr, &enable, sizeof(enable)))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}
-				break;
-	
-			case ALSPS_GET_ALS_DATA: 
-				if((err = cm3232_read_als(obj->client, &obj->als)))
-				{
-					goto err_out;
-				}
-	
-				dat = cm3232_get_als_value(obj, obj->als);
-				if(copy_to_user(ptr, &dat, sizeof(dat)))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}			   
-				break;
-	
-			case ALSPS_GET_ALS_RAW_DATA:	
-				if((err = cm3232_read_als(obj->client, &obj->als)))
-				{
-					goto err_out;
-				}
-	
-				dat = obj->als;
-				if(copy_to_user(ptr, &dat, sizeof(dat)))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}			   
-				break;
-			/*------------------------------------------------------------------------------------------*/
-			
-			default:
-				APS_ERR("%s not supported = 0x%04x", __FUNCTION__, cmd);
-				err = -ENOIOCTLCMD;
-				break;
-		}
-	
-		err_out:
-		return err;    
-	}
-/********************************************************************/
-/*------------------------------misc device related operation functions------------------------------------*/
-static struct file_operations cm3232_fops = {
-	.owner = THIS_MODULE,
-	.open = cm3232_open,
-	.release = cm3232_release,
-	.unlocked_ioctl = cm3232_unlocked_ioctl,
-};
-
-static struct miscdevice cm3232_device = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "als_ps",
-	.fops = &cm3232_fops,
-};
-
-/*--------------------------------------------------------------------------------------*/
-static void cm3232_early_suspend(struct early_suspend *h)
-{
-		struct cm3232_priv *obj = container_of(h, struct cm3232_priv, early_drv);	
-		int err;
-		APS_FUN();	  
-	
-		if(!obj)
-		{
-			APS_ERR("null pointer!!\n");
-			return;
-		}
-		
-		atomic_set(&obj->als_suspend, 1);
-		if((err = cm3232_enable_als(obj->client, 0)))
-		{
-			APS_ERR("disable als fail: %d\n", err); 
-		}
-}
-
-static void cm3232_late_resume(struct early_suspend *h) 
-{
-		struct cm3232_priv *obj = container_of(h, struct cm3232_priv, early_drv);		  
-		int err;
-		hwm_sensor_data sensor_data;
-		memset(&sensor_data, 0, sizeof(sensor_data));
-		APS_FUN();
-		if(!obj)
-		{
-			APS_ERR("null pointer!!\n");
-			return;
-		}
-	
-		atomic_set(&obj->als_suspend, 0);
-		if(test_bit(CMC_BIT_ALS, &obj->enable))
-		{
-			if((err = cm3232_enable_als(obj->client, 1)))
-			{
-				APS_ERR("enable als fail: %d\n", err);		  
-	
-			}
-		}
-}
-/*--------------------------------------------------------------------------------*/
-static int cm3232_init_client(struct i2c_client *client)
-{
-	struct cm3232_priv *obj = i2c_get_clientdata(client);
-	u8 databuf[3];    
-	int res = 0;
-
-	client->addr &=I2C_MASK_FLAG;
-	
-	databuf[0] = CM3232_REG_ALS_CONF;
-	if(1 == obj->hw->polling_mode_als)
-	databuf[1] = 0x01;
-	else
-	databuf[1] = 0x03;	
-	res = i2c_master_send(client, databuf, 0x2);
-	if(res <= 0)
-	{
-		APS_ERR("i2c_master_send function err\n");
-		goto EXIT_ERR;
-	}
-#if 0//modify for CM3232 polling mode.131012 xgt
-	res = cm3232_setup_eint(client);
-	if(res!=0)
-	{
-		APS_ERR("setup eint: %d\n", res);
-		return res;
-	}
-#endif
-
-#ifdef CUSTOM_KERNEL_SENSORHUB
-	res = SCP_sensorHub_rsp_registration(ID_LIGHT, cm3232_irq_handler);
-	if(res != 0)
-	{
-		APS_ERR("i2c_master_send function err\n");
-		goto EXIT_ERR;
-	}
-#endif
-	return CM3232_SUCCESS;
-	
-	EXIT_ERR:
-	APS_ERR("init dev: %d\n", res);
-	return res;
-}
-#if 0
-/*--------------------------------------------------------------------------------*/
-int cm3232_als_operate(void* self, uint32_t command, void* buff_in, int size_in,
-		void* buff_out, int size_out, int* actualout)
-{
-		long err = 0;
-		int value;
-		hwm_sensor_data* sensor_data;
-		struct cm3232_priv *obj = (struct cm3232_priv *)self;
-		APS_FUN(f);
-		switch (command)
-		{
-			case SENSOR_DELAY:
-				APS_ERR("cm3232 als delay command!\n");
-				if((buff_in == NULL) || (size_in < sizeof(int)))
-				{
-					APS_ERR("Set delay parameter error!\n");
-					err = -EINVAL;
-				}
-				break;
-	
-			case SENSOR_ENABLE:
-				APS_ERR("cm3232 als enable command!\n");
-				if((buff_in == NULL) || (size_in < sizeof(int)))
-				{
-					APS_ERR("Enable sensor parameter error!\n");
-					err = -EINVAL;
-				}
-				else
-				{
-					value = *(int *)buff_in;				
-					if(value)
-					{
-						if((err = cm3232_enable_als(obj->client, 1)))
-						{
-							APS_ERR("enable als fail: %ld\n", err); 
-							return -1;
-						}
-						set_bit(CMC_BIT_ALS, &obj->enable);
-					}
-					else
-					{
-						if((err = cm3232_enable_als(obj->client, 0)))
-						{
-							APS_ERR("disable als fail: %ld\n", err); 
-							return -1;
-						}
-						clear_bit(CMC_BIT_ALS, &obj->enable);
-					}
-					
-				}
-				break;
-	
-			case SENSOR_GET_DATA:
-				APS_ERR("cm3232 als get data command!\n");
-				if((buff_out == NULL) || (size_out< sizeof(hwm_sensor_data)))
-				{
-					APS_ERR("get sensor data parameter error!\n");
-					err = -EINVAL;
-				}
-				else
-				{
-					sensor_data = (hwm_sensor_data *)buff_out;
-									
-					if((err = cm3232_read_als(obj->client, &obj->als)))
-					{
-						err = -1;;
-					}
-					else
-					{
-						sensor_data->values[0] = cm3232_get_als_value(obj, obj->als);
-						sensor_data->value_divide = 1;
-						sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
-					}				
-				}
-				break;
-			default:
-				APS_ERR("light sensor operate function no this parameter %d!\n", command);
-				err = -1;
-				break;
-		}
-		
-		return err;
-
-}
-/*--------------------------------------------------------------------------------*/
-#endif
-
-// if use  this typ of enable , Gsensor should report inputEvent(x, y, z ,stats, div) to HAL
-static int cm3232_als_open_report_data(int open)
-{
-	//should queuq work to report event if  is_report_input_direct=true
-	return 0;
-}
-
-// if use  this typ of enable , Gsensor only enabled but not report inputEvent to HAL
-
-static int cm3232_als_enable_nodata(int en)
-{
-	int res = 0;
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    SCP_SENSOR_HUB_DATA req;
-    int len;
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-
-    APS_LOG("cm3232_obj als enable value = %d\n", en);
-
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    req.activate_req.sensorType = ID_LIGHT;
-    req.activate_req.action = SENSOR_HUB_ACTIVATE;
-    req.activate_req.enable = en;
-    len = sizeof(req.activate_req);
-    res = SCP_sensorHub_req_send(&req, &len, 1);
-#else //#ifdef CUSTOM_KERNEL_SENSORHUB
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return -1;
-	}
-	res=cm3232_enable_als(cm3232_obj->client, en);
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-	if(res){
-		APS_ERR("als_enable_nodata is failed!!\n");
-		return -1;
-	}
-	return 0;
-}
-
-static int cm3232_als_set_delay(u64 ns)
-{
-	return 0;
-}
-
-static int cm3232_als_get_data(int* value, int* status)
-{
-	int err = 0;
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    SCP_SENSOR_HUB_DATA req;
-    int len;
-#else
-    struct cm3232_priv *obj = NULL;
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    req.get_data_req.sensorType = ID_LIGHT;
-    req.get_data_req.action = SENSOR_HUB_GET_DATA;
-    len = sizeof(req.get_data_req);
-    err = SCP_sensorHub_req_send(&req, &len, 1);
-    if (err)
-    {
-        APS_ERR("SCP_sensorHub_req_send fail!\n");
-    }
-    else
-    {
-        *value = req.get_data_rsp.int16_Data[0];
-        *status = SENSOR_STATUS_ACCURACY_MEDIUM;
-    }
-
-    if(atomic_read(&cm3232_obj->trace) & CMC_TRC_ALS_DATA)
-	{
-        APS_LOG("value = %d\n", *value);
-        //show data
-	}
-#else //#ifdef CUSTOM_KERNEL_SENSORHUB
-	if(!cm3232_obj)
-	{
-		APS_ERR("cm3232_obj is null!!\n");
-		return -1;
-	}
-	obj = cm3232_obj;
-	if((err = cm3232_read_als(obj->client, &obj->als)))
-	{
-		err = -1;
-	}
-	else
-	{
-		*value = cm3232_get_als_value(obj, obj->als);
-		*status = SENSOR_STATUS_ACCURACY_MEDIUM;
-	}
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-
-	return err;
-}
-
-
-/*-----------------------------------i2c operations----------------------------------*/
-static int cm3232_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
-{
-	struct cm3232_priv *obj;
-	//struct hwmsen_object obj_als;
-	int err = 0;
-	struct als_control_path als_ctl={0};
-	struct als_data_path als_data={0};
-	//struct ps_control_path ps_ctl={0};
-	//struct ps_data_path ps_data={0};
-
-	
-	APS_LOG("cm3232_i2c_probe\n");	
-
-	if(!(obj = kzalloc(sizeof(*obj), GFP_KERNEL)))
-	{
-		err = -ENOMEM;
-		goto exit;
-	}
-	
-	memset(obj, 0, sizeof(*obj));
-	cm3232_obj = obj;
-	
-	obj->hw = get_cust_alsps_hw();//get custom file data struct
-	
-	//INIT_WORK(&obj->eint_work, cm3232_eint_work);//modify for CM3232 polling mode.131012 xgt
-#ifdef CUSTOM_KERNEL_SENSORHUB
-	INIT_WORK(&obj->init_done_work, cm3232_init_done_work);
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-
-	obj->client = client;
-	i2c_set_clientdata(client, obj);
-
-	/*-----------------------------value need to be confirmed-----------------------------------------*/
-	atomic_set(&obj->als_debounce, 200);
-	atomic_set(&obj->als_deb_on, 0);
-	atomic_set(&obj->als_deb_end, 0);
-	atomic_set(&obj->als_suspend, 0);
-	atomic_set(&obj->als_cmd_val, 0xDF);
-	atomic_set(&obj->als_thd_val_high,  obj->hw->als_threshold_high);
-	atomic_set(&obj->als_thd_val_low,  obj->hw->als_threshold_low);
-	
-	obj->enable = 0;
-	obj->pending_intr = 0;
-	obj->als_level_num = sizeof(obj->hw->als_level)/sizeof(obj->hw->als_level[0]);
-	obj->als_value_num = sizeof(obj->hw->als_value)/sizeof(obj->hw->als_value[0]);
-	/*-----------------------------value need to be confirmed-----------------------------------------*/
-	
-	BUG_ON(sizeof(obj->als_level) != sizeof(obj->hw->als_level));
-	memcpy(obj->als_level, obj->hw->als_level, sizeof(obj->als_level));
-	BUG_ON(sizeof(obj->als_value) != sizeof(obj->hw->als_value));
-	memcpy(obj->als_value, obj->hw->als_value, sizeof(obj->als_value));
-	atomic_set(&obj->i2c_retry, 3);
-	set_bit(CMC_BIT_ALS, &obj->enable);
-
-	cm3232_i2c_client = client;
-
-	if((err = cm3232_init_client(client)))
-	{
-		goto exit_init_failed;
-	}
-	APS_LOG("cm3232_init_client() OK!\n");
-
-	if((err = misc_register(&cm3232_device)))
-	{
-		APS_ERR("cm3232_device register failed\n");
-		goto exit_misc_device_register_failed;
-	}
-	APS_LOG("cm3232_device misc_register OK!\n");
-
-	/*------------------------cm3232 attribute file for debug--------------------------------------*/
-	if((err = cm3232_create_attr(&cm3232_init_info.platform_diver_addr->driver)))
-	{
-		APS_ERR("create attribute err = %d\n", err);
-		goto exit_create_attr_failed;
-	}
-	/*------------------------cm3232 attribute file for debug--------------------------------------*/
-	als_ctl.open_report_data= cm3232_als_open_report_data;
-	als_ctl.enable_nodata = cm3232_als_enable_nodata;
-	als_ctl.set_delay  = cm3232_als_set_delay;
-	als_ctl.is_report_input_direct = false;
-#ifdef CUSTOM_KERNEL_SENSORHUB
-	als_ctl.is_support_batch = obj->hw->is_batch_supported_als;
-#else
-	als_ctl.is_support_batch = false;
-#endif
-	
-	err = als_register_control_path(&als_ctl);
-	if(err)
-	{
-		APS_ERR("register fail = %d\n", err);
-		goto exit_sensor_obj_attach_fail;
-	}
-
-	als_data.get_data = cm3232_als_get_data;
-	als_data.vender_div = 100;
-	err = als_register_data_path(&als_data);	
-	if(err)
-	{
-		APS_ERR("tregister fail = %d\n", err);
-		goto exit_sensor_obj_attach_fail;
-	}
-	
-	err = batch_register_support_info(ID_LIGHT,als_ctl.is_support_batch, 100, 0);
-	if(err)
-	{
-		APS_ERR("register light batch support err = %d\n", err);
-		goto exit_sensor_obj_attach_fail;
-	}
-
-	#if defined(CONFIG_HAS_EARLYSUSPEND)
-	obj->early_drv.level    = EARLY_SUSPEND_LEVEL_STOP_DRAWING - 2,
-	obj->early_drv.suspend  = cm3232_early_suspend,
-	obj->early_drv.resume   = cm3232_late_resume,    
-	register_early_suspend(&obj->early_drv);
-	#endif
-	cm3232_init_flag = 0;
-	APS_LOG("cm3232_i2c_probe OK\n");
-	APS_LOG("%s: OK\n", __func__);
-	//hw_module_info_add(&hw_info);    //add tyd hardware info
-	return 0;
-
-	exit_create_attr_failed:
-	exit_sensor_obj_attach_fail:
-	exit_misc_device_register_failed:
-		misc_deregister(&cm3232_device);
-	exit_init_failed:
-		kfree(obj);
-	exit:
-	cm3232_i2c_client = NULL;           
-    cm3232_init_flag = -1;
-	APS_ERR("%s: err = %d\n", __func__, err);
-	return err;
-}
-
-static int cm3232_i2c_remove(struct i2c_client *client)
-{
-	int err;	
-	/*------------------------cm3232 attribute file for debug--------------------------------------*/	
-	if((err = cm3232_delete_attr(&cm3232_init_info.platform_diver_addr->driver)))
-	{
-		APS_ERR("cm3232_delete_attr fail: %d\n", err);
-	} 
-	/*----------------------------------------------------------------------------------------*/
-	
-	if((err = misc_deregister(&cm3232_device)))
-	{
-		APS_ERR("misc_deregister fail: %d\n", err);    
-	}
-		
-	cm3232_i2c_client = NULL;
-	i2c_unregister_device(client);
-	kfree(i2c_get_clientdata(client));
-	return 0;
-
-}
-
-static int cm3232_i2c_detect(struct i2c_client *client, struct i2c_board_info *info)
-{
-	strcpy(info->type, CM3232_DEV_NAME);
-	return 0;
-
-}
-
-static int cm3232_i2c_suspend(struct i2c_client *client, pm_message_t msg)
-{
-	APS_FUN();
-	return 0;
-}
-
-static int cm3232_i2c_resume(struct i2c_client *client)
-{
-	APS_FUN();
-	return 0;
-}
-
-/*----------------------------------------------------------------------------*/
-#if 0
-static int cm3232_probe(struct platform_device *pdev) 
-{
-	struct alsps_hw *hw = get_cust_alsps_hw();
-    APS_FUN();  
-        
-	cm3232_power(hw, 1); //*****************   
-	
-	if(i2c_add_driver(&cm3232_i2c_driver))
-	{
-		APS_ERR("add driver error\n");
-		return -1;
-	} 
-	return 0;
-}
-#endif
-
-static int  cm3232_local_init(void)
-{
-    struct alsps_hw *hw = get_cust_alsps_hw();
-	//printk("fwq loccal init+++\n");
-
-	cm3232_power(hw, 1);
-	if(i2c_add_driver(&cm3232_i2c_driver))
-	{
-		APS_ERR("add driver error\n");
-		return -1;
-	}
-	if(-1 == cm3232_init_flag)
-	{
-	   return -1;
-	}
-	//printk("fwq loccal init---\n");
-	return 0;
-}
-
-
-/*----------------------------------------------------------------------------*/
-static int cm3232_remove(void)
-{	
-	struct alsps_hw *hw = get_cust_alsps_hw();
-	APS_FUN(); 
-	
-	cm3232_power(hw, 0);//*****************  
-	
-	i2c_del_driver(&cm3232_i2c_driver);
-	return 0;
-}
-
-
-
-/*----------------------------------------------------------------------------*/
-/*
-static struct platform_driver cm3232_alsps_driver = {
-	.probe      = cm3232_probe,
-	.remove     = cm3232_remove,    
-	.driver     = {
-		.name  = "als_ps",
-	}
-};
-*/
-
-/*----------------------------------------------------------------------------*/
-static int __init cm3232_init(void)
-{
-	struct alsps_hw *hw = get_cust_alsps_hw();
-	APS_LOG("%s: i2c_number=%d\n", __func__, hw->i2c_num);
-	i2c_register_board_info(hw->i2c_num, &i2c_cm3232, 1);
-	alsps_driver_add(&cm3232_init_info);
-	APS_ERR("cm3232_init ok!\n");
-	return 0;
-}
-/*----------------------------------------------------------------------------*/
-static void __exit cm3232_exit(void)
-{
-	APS_FUN();
-	//platform_driver_unregister(&cm3232_alsps_driver);
-}
-/*----------------------------------------------------------------------------*/
-module_init(cm3232_init);
-module_exit(cm3232_exit);
-/*----------------------------------------------------------------------------*/
-MODULE_AUTHOR("yucong xiong");
-MODULE_DESCRIPTION("cm3232 driver");
-MODULE_LICENSE("GPL");
 
diff --git a/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x.c b/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x.c
index 160a6e4..741f01b 100644
--- a/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x.c
+++ b/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x.c
@@ -1,10 +1,40 @@
-/*
-* Copyright(C)2014 MediaTek Inc.
-* Modification based on code covered by the below mentioned copyright
-* and/or permission notice(S).
-*/
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
 
-/*  
+/* drivers/hwmon/mt6516/amit/stk3x1x.c - stk3x1x ALS/PS driver
+ * 
  * Author: MingHsien Hsieh <minghsien.hsieh@mediatek.com>
  *
  * This software is licensed under the terms of the GNU General Public
@@ -36,63 +66,152 @@
 #include <linux/wakelock.h> 
 #include <asm/io.h>
 #include <linux/module.h>
-#include <linux/sched.h>
 
 #include <linux/hwmsen_helper.h>
 #include <cust_eint.h>
 #include <linux/hwmsensor.h>
 #include <linux/sensors_io.h>
 #include <linux/hwmsen_dev.h>
-#include <cust_alsps.h>
-#include <alsps.h>
+#include "stk3x1x_cust_alsps.h"
 #include "stk3x1x.h"
+#define DRIVER_VERSION          "3.2.2 20140305"
+#include <alsps.h>
 
-#define DRIVER_VERSION          "3.1.2.1nk"
 //#define STK_PS_POLLING_LOG
-//#define STK_FIR
+#define STK_TUNE0
+#define CALI_EVERY_TIME
+#define STK_ALS_FIR
 //#define STK_IRS
-//#include <mach/mt_devs.h>
+//#define STK_CHK_REG
+//#define STK_GES  //open stk gesture
+
+//#ifdef MT6516
+//#include <mach/mt6516_devs.h>
+//#include <mach/mt6516_typedefs.h>
+//#include <mach/mt6516_gpio.h>
+//#include <mach/mt6516_pll.h>
+//#endif
+
+//#ifdef MT6573
+//#include <mach/mt6573_devs.h>
+//#include <mach/mt6573_typedefs.h>
+//#include <mach/mt6573_gpio.h>
+//#include <mach/mt6573_pll.h>
+//#endif
+
+//#if 0
+//#include <mach/mt6575_devs.h>
+//#include <mach/mt6575_typedefs.h>
+//#include <mach/mt6575_gpio.h>
+//#include <mach/mt6575_pm_ldo.h>
+//#endif
+
+//#if MT6577
+//#include <mach/mt6577_devs.h>
+//#include <mach/mt6577_typedefs.h>
+//#include <mach/mt6577_gpio.h>
+//#include <mach/mt6577_pm_ldo.h>
+//#endif
+
+//#if (defined(MT6589) || defined(MT6572) || defined(MT6582) || defined(MT6575))
+////#include <mach/mt_devs.h>
+//#include <mach/mt_typedefs.h>
+//#include <mach/mt_gpio.h>
+//#include <mach/mt_pm_ldo.h>
+//#endif
+
 #include <mach/mt_typedefs.h>
 #include <mach/mt_gpio.h>
 #include <mach/mt_pm_ldo.h>
+#include <mach/eint.h>
+//#if ((defined MT6573) || (defined MT6575) || (defined MT6577) || (defined MT6589)  || (defined MT6572) || (defined MT6582))	
+/*
+extern void mt_eint_unmask(unsigned int line);
+extern void mt_eint_mask(unsigned int line);
+extern void mt_eint_set_polarity(kal_uint8 eintno, kal_bool ACT_Polarity);
+extern void mt_eint_set_hw_debounce(kal_uint8 eintno, kal_uint32 ms);
+extern kal_uint32 mt_eint_set_sens(kal_uint8 eintno, kal_bool sens);
+extern void mt_eint_registration(kal_uint8 eintno, kal_bool Dbounce_En,
+                                     kal_bool ACT_Polarity, void (EINT_FUNC_PTR)(void),
+                                     kal_bool auto_umask);
+*/
+extern void mt_eint_mask(unsigned int eint_num);
+extern void mt_eint_unmask(unsigned int eint_num);
+extern void mt_eint_set_hw_debounce(unsigned int eint_num, unsigned int ms);
+extern void mt_eint_set_polarity(unsigned int eint_num, unsigned int pol);
+extern unsigned int mt_eint_set_sens(unsigned int eint_num, unsigned int sens);
+extern void mt_eint_registration(unsigned int eint_num, unsigned int flow, void (EINT_FUNC_PTR)(void), unsigned int is_auto_umask);
+extern void mt_eint_print_status(void);
 
-/*------------------------- define-------------------------------*/
-#define CUST_EINT_ALS_SENSITIVE 	CUST_EINTF_TRIGGER_LOW 
-#define CUST_EINT_ALS_POLARITY 		CUST_EINT_ALS_TYPE
+#ifndef CUST_EINT_ALS_TYPE
+#define CUST_EINT_ALS_TYPE EINTF_TRIGGER_LOW
+#endif
+//#endif
+
+/*-------------------------MT6516&MT6573 define-------------------------------*/
+//#ifdef MT6516
+//#define POWER_NONE_MACRO MT6516_POWER_NONE
+//#endif
+
+//#if ((defined MT6573) || (defined MT6575) || (defined MT6577) || (defined MT6589) || (defined MT6572) || (defined MT6582) )	
 #define POWER_NONE_MACRO MT65XX_POWER_NONE
+//#endif 
 
 /******************************************************************************
  * configuration
 *******************************************************************************/
-#define PSCTRL_VAL	0x71	/* ps_persistance=4, ps_gain=64X, PS_IT=0.391ms */
-#define ALSCTRL_VAL	0x38	/* als_persistance=1, als_gain=64X, ALS_IT=50ms */
-#define LEDCTRL_VAL	0xFF	/* 100mA IRDR, 64/64 LED duty */
-#define WAIT_VAL		0x7		/* 50 ms */
 
 /*----------------------------------------------------------------------------*/
 #define stk3x1x_DEV_NAME     "stk3x1x"
 /*----------------------------------------------------------------------------*/
 #define APS_TAG                  "[ALS/PS] "
-#define APS_FUN(f)               printk(APS_TAG"%s\n", __FUNCTION__)
-#define APS_ERR(fmt, args...)    printk(APS_TAG"%s %d : "fmt, __FUNCTION__, __LINE__, ##args)
-#define APS_LOG(fmt, args...)    printk(APS_TAG fmt, ##args)
-#define APS_DBG(fmt, args...)    printk(fmt, ##args)                 
+#define APS_FUN(f)               printk(KERN_ERR APS_TAG"%s\n", __FUNCTION__)
+#define APS_ERR(fmt, args...)    printk(KERN_ERR  APS_TAG"%s %d : "fmt, __FUNCTION__, __LINE__, ##args)
+#define APS_LOG(fmt, args...)    printk(KERN_ERR APS_TAG fmt, ##args)
+#define APS_DBG(fmt, args...)    printk(KERN_ERR fmt, ##args)                 
 /******************************************************************************
  * extern functions
 *******************************************************************************/
+//#ifdef MT6516
+//extern void MT6516_EINTIRQUnmask(unsigned int line);
+//extern void MT6516_EINTIRQMask(unsigned int line);
+//extern void MT6516_EINT_Set_Polarity(kal_uint8 eintno, kal_bool ACT_Polarity);
+//extern void MT6516_EINT_Set_HW_Debounce(kal_uint8 eintno, kal_uint32 ms);
+//extern kal_uint32 MT6516_EINT_Set_Sensitivity(kal_uint8 eintno, kal_bool sens);
+//extern void MT6516_EINT_Registration(kal_uint8 eintno, kal_bool Dbounce_En,
+//                                     kal_bool ACT_Polarity, void (EINT_FUNC_PTR)(void),
+//                                     kal_bool auto_umask);
+//#endif
 /*----------------------------------------------------------------------------*/
-extern void mt_eint_unmask(unsigned int line);
-extern void mt_eint_mask(unsigned int line);
-extern void mt_eint_set_hw_debounce(unsigned int eint_num, unsigned int ms);
-extern unsigned int mt_eint_set_sens(unsigned int eint_num, unsigned int sens);
-extern void mt_eint_registration(unsigned int eint_num, unsigned int flag, void (EINT_FUNC_PTR) (void), unsigned int is_auto_umask);
-
+#define mt6516_I2C_DATA_PORT        ((base) + 0x0000)
+#define mt6516_I2C_SLAVE_ADDR       ((base) + 0x0004)
+#define mt6516_I2C_INTR_MASK        ((base) + 0x0008)
+#define mt6516_I2C_INTR_STAT        ((base) + 0x000c)
+#define mt6516_I2C_CONTROL          ((base) + 0x0010)
+#define mt6516_I2C_TRANSFER_LEN     ((base) + 0x0014)
+#define mt6516_I2C_TRANSAC_LEN      ((base) + 0x0018)
+#define mt6516_I2C_DELAY_LEN        ((base) + 0x001c)
+#define mt6516_I2C_TIMING           ((base) + 0x0020)
+#define mt6516_I2C_START            ((base) + 0x0024)
+#define mt6516_I2C_FIFO_STAT        ((base) + 0x0030)
+#define mt6516_I2C_FIFO_THRESH      ((base) + 0x0034)
+#define mt6516_I2C_FIFO_ADDR_CLR    ((base) + 0x0038)
+#define mt6516_I2C_IO_CONFIG        ((base) + 0x0040)
+#define mt6516_I2C_DEBUG            ((base) + 0x0044)
+#define mt6516_I2C_HS               ((base) + 0x0048)
+#define mt6516_I2C_DEBUGSTAT        ((base) + 0x0064)
+#define mt6516_I2C_DEBUGCTRL        ((base) + 0x0068)
 /*----------------------------------------------------------------------------*/
-#define STK2213_PID			0x23
-#define STK2213I_PID			0x22
-#define STK3010_PID			0x33
-#define STK3210_STK3310_PID	0x13
-#define STK3211_STK3311_PID	0x12
+
+#ifdef STK_TUNE0
+//	#define STK_MAX_MIN_DIFF	(400-15)
+//	#define STK_LT_N_CT	(271-50)
+//	#define STK_HT_N_CT	 (345-50)
+#define STK_MAX_MIN_DIFF	80 //160
+#define STK_LT_N_CT	35 //30
+#define STK_HT_N_CT	44
+
+#endif /* #ifdef STK_TUNE0 */
 
 #define STK_IRC_MAX_ALS_CODE		20000
 #define STK_IRC_MIN_ALS_CODE		25
@@ -123,20 +242,6 @@ static int stk3x1x_i2c_detect(struct i2c_client *client, int kind, struct i2c_bo
 static int stk3x1x_i2c_suspend(struct i2c_client *client, pm_message_t msg);
 static int stk3x1x_i2c_resume(struct i2c_client *client);
 static struct stk3x1x_priv *g_stk3x1x_ptr = NULL;
-static unsigned long long int_top_time = 0;
-#define C_I2C_FIFO_SIZE     8
-
-static DEFINE_MUTEX(STK3X1X_i2c_mutex);
-static int	stk3x1x_init_flag = -1;	// 0<==>OK -1 <==> fail
-static int  stk3x1x_local_init(void);
-static int  stk3x1x_local_uninit(void);
-static struct alsps_init_info stk3x1x_init_info = {
-		.name = "stk3x1x",
-		.init = stk3x1x_local_init,
-		.uninit = stk3x1x_local_uninit,
-	
-};
-
 
 /*----------------------------------------------------------------------------*/
 typedef enum {
@@ -183,15 +288,43 @@ struct stk3x1x_i2c_addr {
 	u8  soft_reset;		/* software reset */
 };
 /*----------------------------------------------------------------------------*/
-#ifdef STK_FIR
+#ifdef STK_ALS_FIR
+	#define STK_FIR_LEN	4 //8
+	#define MAX_FIR_LEN 32
 struct data_filter {
-    s16 raw[8];
+    u16 raw[MAX_FIR_LEN];
     int sum;
     int num;
     int idx;
 };
 #endif
 
+#ifdef STK_GES
+union stk_ges_operation{
+	uint8_t ops[4];
+	struct {
+		uint8_t rw_len_retry;
+		uint8_t reg;
+		uint8_t reg_value_retry_crit;
+		uint8_t sleep_10ns;
+	}action;
+};
+
+union stk_ges_operation stk_ges_op[10] =
+{
+	{.ops={0xc1, 0x24, 0, 0}},
+	{.ops={0, 0, 0, 0}},	
+	{.ops={0, 0, 0, 0}},	
+	{.ops={0, 0, 0, 0}},	
+	{.ops={0, 0, 0, 0}},	
+	{.ops={0, 0, 0, 0}},	
+	{.ops={0, 0, 0, 0}},	
+	{.ops={0, 0, 0, 0}},	
+	{.ops={0, 0, 0, 0}},	
+	{.ops={0, 0, 0, 0}}
+};
+#endif
+
 struct stk3x1x_priv {
     struct alsps_hw  *hw;
     struct i2c_client *client;
@@ -222,7 +355,6 @@ struct stk3x1x_priv {
     u16         als_value_num;
     u32         als_level[C_CUST_ALS_LEVEL-1];
     u32         als_value[C_CUST_ALS_LEVEL];
-	int			ps_cali;
 
 	atomic_t	state_val;
 	atomic_t 	psctrl_val;
@@ -241,11 +373,36 @@ struct stk3x1x_priv {
     struct early_suspend    early_drv;
 #endif     
 	bool first_boot;
-#ifdef STK_FIR
+#ifdef STK_TUNE0
+	uint16_t psa;
+	uint16_t psi;	
+	uint16_t psi_set;	
+	uint16_t ps_high_thd_boot;
+	uint16_t ps_low_thd_boot;
+	struct hrtimer ps_tune0_timer;	
+	struct workqueue_struct *stk_ps_tune0_wq;
+    struct work_struct stk_ps_tune0_work;
+	ktime_t ps_tune0_delay;	
+	bool tune_zero_init_proc;
+	uint32_t ps_stat_data[3];
+	int data_count;	
+#endif	
+#ifdef STK_ALS_FIR
 	struct data_filter      fir;
+	atomic_t                firlength;		
 #endif
 	uint16_t ir_code;
 	uint16_t als_correct_factor;	
+	u16 als_last;
+#ifdef STK_GES		
+	struct input_dev *ges_input_dev;
+	int ges_enabled;
+	bool re_enable_ges;	
+	int re_enable_ges2;	
+	atomic_t gesture2;	
+#endif	
+	bool re_enable_ps;
+	bool re_enable_als;
 };
 /*----------------------------------------------------------------------------*/
 static struct i2c_driver stk3x1x_i2c_driver = {	
@@ -269,7 +426,17 @@ static struct i2c_driver stk3x1x_i2c_driver = {
 };
 
 static struct stk3x1x_priv *stk3x1x_obj = NULL;
-static struct platform_driver stk3x1x_alsps_driver;
+//static struct platform_driver stk3x1x_alsps_driver;
+//add auto
+extern int hwmsen_alsps_sensor_add(struct sensor_init_info* obj) ;
+static int  stk3x1x_local_init(void);
+static int stk3x1x_remove(void);
+static int stk3310_init_flag =0;
+static struct alsps_init_info stk3x1x_init_info = {			
+	.name = "stk3x1x",			
+	.init = stk3x1x_local_init,			
+	.uninit =stk3x1x_remove,	
+};/* Add end */
 static int stk3x1x_get_ps_value(struct stk3x1x_priv *obj, u16 ps);
 static int stk3x1x_get_ps_value_only(struct stk3x1x_priv *obj, u16 ps);
 static int stk3x1x_get_als_value(struct stk3x1x_priv *obj, u16 als);
@@ -277,8 +444,18 @@ static int stk3x1x_read_als(struct i2c_client *client, u16 *data);
 static int stk3x1x_read_ps(struct i2c_client *client, u16 *data);
 static int stk3x1x_set_als_int_thd(struct i2c_client *client, u16 als_data_reg);
 static int32_t stk3x1x_get_ir_value(struct stk3x1x_priv *obj);
+#ifdef STK_TUNE0
+static int stk_ps_tune_zero_func_fae(struct stk3x1x_priv *obj);
+#endif
+#ifdef STK_CHK_REG	
+static int stk3x1x_validate_n_handle(struct i2c_client *client);
+#endif
+static int stk3x1x_init_client(struct i2c_client *client);
 struct wake_lock ps_lock;
-
+#ifdef STK_GES		
+static uint32_t stk3x1x_get_ges_value(struct stk3x1x_priv *obj, unsigned int *ges0, unsigned int *ges1, unsigned int *ges2);
+static int32_t stk3x1x_enable_ges(struct i2c_client *client, int enable, int mode);
+#endif
 /*----------------------------------------------------------------------------*/
 int stk3x1x_get_addr(struct alsps_hw *hw, struct stk3x1x_i2c_addr *addr)
 {
@@ -316,9 +493,7 @@ int stk3x1x_get_addr(struct alsps_hw *hw, struct stk3x1x_i2c_addr *addr)
 /*----------------------------------------------------------------------------*/
 int stk3x1x_hwmsen_read_block(struct i2c_client *client, u8 addr, u8 *data, u8 len)
 {
-    int err;
-	u8 beg = addr;
-	mutex_lock(&STK3X1X_i2c_mutex);
+	u8 beg = addr; 
 	struct i2c_msg msgs[2] = 
 	{
 		{
@@ -334,20 +509,17 @@ int stk3x1x_hwmsen_read_block(struct i2c_client *client, u8 addr, u8 *data, u8 l
 			.buf = data,
 		}
 	};
+	int err;
 
-	if (!client) {
-		mutex_unlock(&STK3X1X_i2c_mutex);
+	if (!client)
 		return -EINVAL;
-	}
 	else if (len > C_I2C_FIFO_SIZE) 
-	{   
-	    mutex_unlock(&STK3X1X_i2c_mutex);
+	{		 
 		APS_LOG(" length %d exceeds %d\n", len, C_I2C_FIFO_SIZE);
 		return -EINVAL;
 	}
 
 	err = i2c_transfer(client->adapter, msgs, sizeof(msgs)/sizeof(msgs[0]));
-	mutex_unlock(&STK3X1X_i2c_mutex);
 	if (err != 2) 
 	{
 		APS_LOG("i2c_transfer error: (%d %p %d) %d\n", addr, data, len, err);
@@ -359,43 +531,6 @@ int stk3x1x_hwmsen_read_block(struct i2c_client *client, u8 addr, u8 *data, u8 l
 	}
 	return err;
 }
-
-static int stk3x1x_i2c_write_block(struct i2c_client *client, u8 addr, u8 *data, u8 len)
-{   /*because address also occupies one byte, the maximum length for write is 7 bytes*/
-    int err, idx, num;
-    char buf[C_I2C_FIFO_SIZE];
-    err =0;
-    mutex_lock(&STK3X1X_i2c_mutex);
-    if (!client)
-    {
-        mutex_unlock(&STK3X1X_i2c_mutex);
-        return -EINVAL;
-    }
-    else if (len >= C_I2C_FIFO_SIZE)
-    {
-        APS_ERR(" length %d exceeds %d\n", len, C_I2C_FIFO_SIZE);
-        mutex_unlock(&STK3X1X_i2c_mutex);
-        return -EINVAL;
-    }
-
-    num = 0;
-    buf[num++] = addr;
-    for (idx = 0; idx < len; idx++)
-    {
-        buf[num++] = data[idx];
-    }
-
-    err = i2c_master_send(client, buf, num);
-    if (err < 0)
-    {
-        APS_ERR("send command error!!\n");
-        mutex_unlock(&STK3X1X_i2c_mutex);
-        return -EFAULT;
-    }
-    mutex_unlock(&STK3X1X_i2c_mutex);
-    return err;
-}
-
 /*----------------------------------------------------------------------------*/
 int stk3x1x_get_timing(void)
 {
@@ -486,8 +621,10 @@ int stk3x1x_read_als(struct i2c_client *client, u16 *data)
 	u8 buf[2];
 	int32_t als_comperator;	
 	u16 als_data;
-#ifdef STK_FIR
+	u32 als_data_u32;
+#ifdef STK_ALS_FIR
 	int idx;   
+	int firlen = atomic_read(&obj->firlength);   	
 #endif
 	if(NULL == client)
 	{
@@ -502,8 +639,8 @@ int stk3x1x_read_als(struct i2c_client *client, u16 *data)
 	else
 	{
 		als_data = (buf[0] << 8) | (buf[1]);
-#ifdef STK_FIR
-		if(obj->fir.num < 8)
+#ifdef STK_ALS_FIR
+		if(obj->fir.num < firlen)
 		{                
 			obj->fir.raw[obj->fir.num] = als_data;
 			obj->fir.sum += als_data;
@@ -512,12 +649,12 @@ int stk3x1x_read_als(struct i2c_client *client, u16 *data)
 		}
 		else
 		{
-			idx = obj->fir.idx % 8;
+			idx = obj->fir.idx % firlen;
 			obj->fir.sum -= obj->fir.raw[idx];
 			obj->fir.raw[idx] = als_data;
 			obj->fir.sum += als_data;
 			obj->fir.idx++;
-			als_data = obj->fir.sum/8;
+			als_data = (obj->fir.sum / firlen);
 		}	
 #endif
 	}
@@ -535,7 +672,9 @@ int stk3x1x_read_als(struct i2c_client *client, u16 *data)
 		APS_LOG("%s: als=%d, ir=%d, als_correct_factor=%d", __func__, als_data, obj->ir_code, obj->als_correct_factor);
 		obj->ir_code = 0;
 	}	
-	*data = als_data * obj->als_correct_factor / 1000;
+	als_data_u32 = als_data;
+	als_data_u32 = als_data_u32 * obj->als_correct_factor / 1000;
+	*data = (u16)als_data_u32;
 	
 	if(atomic_read(&obj->trace) & STK_TRC_ALS_DATA)
 	{
@@ -559,6 +698,56 @@ int stk3x1x_write_als(struct i2c_client *client, u8 data)
 	
 	return 0;    
 }
+#ifdef STK_GES		
+/*----------------------------------------------------------------------------*/
+int stk3x1x_read_gsctrl(struct i2c_client *client, u8 *data)
+{
+	//struct stk3x1x_priv *obj = i2c_get_clientdata(client);    
+	int ret = 0;
+	u8 buf;
+	
+	if(NULL == client)
+	{
+		return -EINVAL;
+	}	
+	ret = stk3x1x_master_recv(client, STK_GSCTRL_REG, &buf, 0x01);
+	if(ret < 0)
+	{
+		APS_DBG("error: %d\n", ret);
+		return -EFAULT;
+	}
+	else
+	{
+		*data = buf;
+	}
+	
+	return 0;    
+}
+#endif
+/*----------------------------------------------------------------------------*/
+int stk3x1x_read_state(struct i2c_client *client, u8 *data)
+{
+	//struct stk3x1x_priv *obj = i2c_get_clientdata(client);    
+	int ret = 0;
+	u8 buf;
+	
+	if(NULL == client)
+	{
+		return -EINVAL;
+	}	
+	ret = stk3x1x_master_recv(client, STK_STATE_REG, &buf, 0x01);
+	if(ret < 0)
+	{
+		APS_DBG("error: %d\n", ret);
+		return -EFAULT;
+	}
+	else
+	{
+		*data = buf;
+	}
+	
+	return 0;    
+}
 /*----------------------------------------------------------------------------*/
 int stk3x1x_read_flag(struct i2c_client *client, u8 *data)
 {
@@ -589,10 +778,38 @@ int stk3x1x_read_flag(struct i2c_client *client, u8 *data)
 	return 0;    
 }
 /*----------------------------------------------------------------------------*/
+#ifdef STK_GES		
+int stk3x1x_read_flag2(struct i2c_client *client, u8 *data)
+{
+	//struct stk3x1x_priv *obj = i2c_get_clientdata(client);    
+	int ret = 0;
+	u8 buf;
+	
+	if(NULL == client)
+	{
+		return -EINVAL;
+	}	
+	ret = stk3x1x_master_recv(client, STK_FLAG2_REG, &buf, 0x01);
+	if(ret < 0)
+	{
+		APS_DBG("error: %d\n", ret);
+		return -EFAULT;
+	}
+	else
+	{
+		*data = buf;
+	}
+	
+	return 0;    
+}
+#endif
+/*----------------------------------------------------------------------------*/
 int stk3x1x_read_id(struct i2c_client *client)
 {
+	//struct stk3x1x_priv *obj = i2c_get_clientdata(client);	
 	int ret = 0;
 	u8 buf[2];
+	u8 pid_msb;
 	
 	if(NULL == client)
 	{
@@ -604,25 +821,27 @@ int stk3x1x_read_id(struct i2c_client *client)
 		APS_DBG("error: %d\n", ret);
 		return -EFAULT;
 	}
-	APS_LOG("%s: PID=0x%d, VID=0x%x\n", __func__, buf[0], buf[1]);
+	APS_LOG("%s: PID=0x%x, VID=0x%x\n", __func__, buf[0], buf[1]);
 	
 	if(buf[1] == 0xC0)
 		APS_LOG( "%s: RID=0xC0!!!!!!!!!!!!!\n", __func__);		
+		
+	if(buf[0] == 0)
+	{
+		APS_ERR( "PID=0x0, please make sure the chip is stk3x1x!\n");
+		return -2;			
+	}		
 	
-	switch(buf[0])
+	pid_msb = buf[0] & 0xF0;
+	switch(pid_msb)
 	{
-		case STK2213_PID:
-		case STK2213I_PID:
-		case STK3010_PID:
-		case STK3210_STK3310_PID:
-		case STK3211_STK3311_PID:
-			return 0;
-		case 0x0:
-			APS_ERR("PID=0x0, please make sure the chip is stk3x1x!\n");
-			return -2;
-		default:
-			APS_ERR( "%s: invalid PID(%#x)\n", __func__, buf[0]);	
-			return -1;
+	case 0x10:
+	case 0x20:
+	case 0x30:
+		return 0;
+	default:
+		APS_ERR( "invalid PID(%#x)\n", buf[0]);	
+		return -1;
 	}	
 	return 0;    
 }
@@ -646,10 +865,7 @@ int stk3x1x_read_ps(struct i2c_client *client, u16 *data)
 	}
 	else
 	{
-		if(((buf[0] << 8) | (buf[1])) < obj->ps_cali)
-			*data = 0;
-		else
-			*data = ((buf[0] << 8) | (buf[1])) - obj->ps_cali;
+		*data = (buf[0] << 8) | (buf[1]);
 	}
 	
 	if(atomic_read(&obj->trace) & STK_TRC_ALS_DATA)
@@ -703,7 +919,22 @@ int stk3x1x_write_int(struct i2c_client *client, u8 data)
 	} 
 	return 0;    
 }
+/*----------------------------------------------------------------------------*/
+#ifdef STK_GES		
+int stk3x1x_write_gsctrl(struct i2c_client *client, u8 data)
+{
+	//struct stk3x1x_priv *obj = i2c_get_clientdata(client);        
+	int ret = 0;
 
+    ret = stk3x1x_master_send(client, STK_GSCTRL_REG, &data, 1);
+	if (ret < 0)
+	{
+		APS_ERR("write state = %d\n", ret);
+		return -EFAULT;
+	} 
+	return 0;    
+}
+#endif
 /*----------------------------------------------------------------------------*/
 int stk3x1x_write_state(struct i2c_client *client, u8 data)
 {
@@ -733,6 +964,22 @@ int stk3x1x_write_flag(struct i2c_client *client, u8 data)
 	return 0;    
 }
 /*----------------------------------------------------------------------------*/
+#ifdef STK_GES		
+int stk3x1x_write_flag2(struct i2c_client *client, u8 data)
+{
+	//struct stk3x1x_priv *obj = i2c_get_clientdata(client);        
+	int ret = 0;
+
+    ret = stk3x1x_master_send(client, STK_FLAG2_REG, &data, 1);
+	if (ret < 0)
+	{
+		APS_ERR("write ps = %d\n", ret);
+		return -EFAULT;
+	} 
+	return 0;    
+}
+#endif
+/*----------------------------------------------------------------------------*/
 int stk3x1x_write_sw_reset(struct i2c_client *client)
 {
 	struct stk3x1x_priv *obj = i2c_get_clientdata(client);        
@@ -967,17 +1214,17 @@ static void stk3x1x_power(struct alsps_hw *hw, unsigned int on)
 		}
 		else if(on)
 		{
-			if(!hwPowerOn(hw->power_id, hw->power_vol, "stk3x1x")) 
+/*			if(!hwPowerOn(hw->power_id, hw->power_vol, "stk3x1x")) 
 			{
 				APS_ERR("power on fails!!\n");
-			}
+			}*/
 		}
 		else
 		{
-			if(!hwPowerDown(hw->power_id, "stk3x1x")) 
+/*			if(!hwPowerDown(hw->power_id, "stk3x1x")) 
 			{
 				APS_ERR("power off fail!!\n");   
-			}
+			}*/
 		}
 	}
 	power_on = on;
@@ -991,6 +1238,15 @@ static int stk3x1x_enable_als(struct i2c_client *client, int enable)
 	int trc = atomic_read(&obj->trace);
 
 	APS_LOG("%s: enable=%d\n", __func__, enable);
+	
+#ifdef STK_GES		
+	if(obj->ges_enabled)
+	{
+		APS_LOG( "%s: since ges is enabled, ALS is disabled\n", __func__);
+		obj->re_enable_als = enable ? true : false;		
+		return 0;
+	}
+#endif		
 	cur = old & (~(STK_STATE_EN_ALS_MASK | STK_STATE_EN_WAIT_MASK)); 
 	if(enable)
 	{
@@ -1032,6 +1288,8 @@ static int stk3x1x_enable_als(struct i2c_client *client, int enable)
 	
 	if(enable)
 	{
+		
+		obj->als_last = 0;
 		if(obj->hw->polling_mode_als)
 		{
 			atomic_set(&obj->als_deb_on, 1);
@@ -1052,33 +1310,61 @@ static int stk3x1x_enable_als(struct i2c_client *client, int enable)
 	return err;
 }
 /*----------------------------------------------------------------------------*/
-static int stk3x1x_enable_ps(struct i2c_client *client, int enable)
+static int stk3x1x_enable_ps(struct i2c_client *client, int enable, int validate_reg)
 {
 	struct stk3x1x_priv *obj = i2c_get_clientdata(client);
 	int err, cur = 0, old = atomic_read(&obj->state_val);
 	int trc = atomic_read(&obj->trace);
 	hwm_sensor_data sensor_data;
-	
-	cur = old;	
 
-	//if(obj->first_boot == true)
-	{			
-		//obj->first_boot = false;
-
-		if((err = stk3x1x_write_ps_high_thd(client, atomic_read(&obj->ps_high_thd_val))))
+	APS_LOG("%s: enable=%d\n", __FUNCTION__, enable);		
+#ifdef STK_GES		
+	if(obj->ges_enabled)
+	{
+		if(enable)
 		{
-			APS_ERR("write high thd error: %d\n", err);
-			return err;        
+			APS_LOG( "%s: force disable Ges, mode = %d\n", __func__, obj->ges_enabled);
+			obj->re_enable_ges2 = obj->ges_enabled;
+			stk3x1x_enable_ges(obj->client, 0, obj->ges_enabled);
+			old = atomic_read(&obj->state_val);
 		}
-		
-		if((err = stk3x1x_write_ps_low_thd(client, atomic_read(&obj->ps_low_thd_val))))
+		else
 		{
-			APS_ERR("write low thd error: %d\n", err);
-			return err;        
-		}		
+			APS_LOG( "%s: ps is disabled\n", __func__);	
+		return 0;
+	}
+	//	APS_LOG( "%s: since ges is enabled, PS is disabled\n", __func__);		
+	//	obj->re_enable_ps = enable ? true : false;
+	//	return 0;
+	
+	}
+#endif	
+	
+#ifdef STK_CHK_REG	
+	if(validate_reg)
+	{
+		err = stk3x1x_validate_n_handle(obj->client);
+		if(err < 0)	
+		{
+			APS_ERR("stk3x1x_validate_n_handle fail: %d\n", err); 
+		}	
+	}		
+#endif	
+#ifdef STK_TUNE0		
+	if (!(obj->psi_set) && !enable)
+	{
+		hrtimer_cancel(&obj->ps_tune0_timer);					
+		cancel_work_sync(&obj->stk_ps_tune0_work);
+	}	
+#endif
+
+	if(obj->first_boot == true)
+	{		
+		obj->first_boot = false;
 	}
 
-	APS_LOG("%s: enable=%d\n", __FUNCTION__, enable);	
+
+	cur = old;		
 	cur &= (~(0x45)); 
 	if(enable)
 	{
@@ -1112,6 +1398,37 @@ static int stk3x1x_enable_ps(struct i2c_client *client, int enable)
 	
 	if(enable)
 	{
+#ifdef STK_TUNE0		
+	#ifndef CALI_EVERY_TIME
+		if (!(obj->psi_set))
+			hrtimer_start(&obj->ps_tune0_timer, obj->ps_tune0_delay, HRTIMER_MODE_REL);			
+	#else
+		if(true)
+		{
+			obj->psi_set = 0;
+			obj->psa = 0;
+			obj->psi = 0xFFFF;
+			
+			atomic_set(&obj->ps_high_thd_val, obj->ps_high_thd_boot);
+			atomic_set(&obj->ps_low_thd_val, obj->ps_low_thd_boot);
+			if ((err = stk3x1x_write_ps_high_thd(obj->client, atomic_read(&obj->ps_high_thd_val)))) 
+			{
+				APS_ERR("write high thd error: %d\n", err);
+				return err;
+			}
+			if ((err = stk3x1x_write_ps_low_thd(obj->client, atomic_read(&obj->ps_low_thd_val))))
+			{
+				APS_ERR("write low thd error: %d\n", err);
+				return err;
+			}
+		//	APS_LOG("%s: set HT=%d, LT=%d\n", __func__, atomic_read(&obj->ps_high_thd_val), atomic_read(&obj->ps_low_thd_val));
+			
+			hrtimer_start(&obj->ps_tune0_timer, obj->ps_tune0_delay, HRTIMER_MODE_REL);			
+		}
+	#endif
+#endif		
+		APS_LOG("%s: HT=%d, LT=%d\n", __func__, atomic_read(&obj->ps_high_thd_val), atomic_read(&obj->ps_low_thd_val));	
+		
 		if(obj->hw->polling_mode_ps)
 		{
 			atomic_set(&obj->ps_deb_on, 1);
@@ -1119,32 +1436,60 @@ static int stk3x1x_enable_ps(struct i2c_client *client, int enable)
 		}
 		else
 		{
-			msleep(4);
-			if((err = stk3x1x_read_ps(obj->client, &obj->ps)))
+#ifdef STK_CHK_REG				
+			if(!validate_reg)
 			{
-				APS_ERR("stk3x1x read ps data: %d\n", err);
-				return err;
-			}
-			
-			err = stk3x1x_get_ps_value_only(obj, obj->ps);
-			if(err < 0)
-			{
-				APS_ERR("stk3x1x get ps value: %d\n", err);
-				return err;
-			}
-			else if(stk3x1x_obj->hw->polling_mode_ps == 0)
-			{	
-				sensor_data.values[0] = err;
+				sensor_data.values[0] = 1;
 				sensor_data.value_divide = 1;
 				sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
-				APS_LOG("%s:ps raw 0x%x -> value 0x%x \n",__FUNCTION__, obj->ps,sensor_data.values[0]);
-				if(ps_report_interrupt_data(sensor_data.values[0]))
+				APS_LOG("%s:force report ps, value 0x%x \n",__FUNCTION__,
+								sensor_data.values[0]);
+
+				ps_report_interrupt_data(sensor_data.values[0]);
+//				if((err = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data)))
+//					APS_ERR("call hwmsen_get_interrupt_data fail = %d\n", err);
+			}
+			else
+#endif			
+			{			
+				msleep(4);
+				if((err = stk3x1x_read_ps(obj->client, &obj->ps)))
+				{
+					APS_ERR("stk3x1x read ps data: %d\n", err);
+					return err;
+				}
+				
+				err = stk3x1x_get_ps_value_only(obj, obj->ps);
+				if(err < 0)
+				{
+					APS_ERR("stk3x1x get ps value: %d\n", err);
+					return err;
+				}
+				else
 				{	
-					APS_ERR("call ps_report_interrupt_data fail\n");
-				}			
-			}			
+					sensor_data.values[0] = err;
+					sensor_data.value_divide = 1;
+					sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
+					APS_LOG("%s:ps raw 0x%x -> value 0x%x \n",__FUNCTION__, obj->ps,
+									sensor_data.values[0]);
+					if((err = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data)))
+						APS_ERR("call hwmsen_get_interrupt_data fail = %d\n", err);
+				}	
+			}
+		}
+	}
+#ifdef STK_GES	
+	else
+	{
+		if(obj->re_enable_ges2)
+		{
+			cur = obj->re_enable_ges2;
+			obj->re_enable_ges2 = 0;
+			APS_LOG( "%s: re-enable Ges, mode = %d\n", __func__, cur);
+			stk3x1x_enable_ges(obj->client, 1, cur);
 		}
 	}
+#endif	
 
 	if(trc & STK_TRC_DEBUG)
 	{
@@ -1154,47 +1499,194 @@ static int stk3x1x_enable_ps(struct i2c_client *client, int enable)
 	return err;
 }
 /*----------------------------------------------------------------------------*/
-
-static int stk3x1x_check_intr(struct i2c_client *client, u8 *status) 
+#ifdef STK_GES
+static int32_t stk3x1x_enable_ges(struct i2c_client *client, int enable, int mode)
 {
-	struct stk3x1x_priv *obj = i2c_get_clientdata(client);
+	struct stk3x1x_priv *obj = i2c_get_clientdata(client);	
+	u8 reg;	
 	int err;
+	int org_state_reg = atomic_read(&obj->state_val);
+	int org_mode = 0;
+	
+	APS_LOG("%s: enable=%d\n", __FUNCTION__, enable);		
 
-	//if (mt_get_gpio_in(GPIO_ALS_EINT_PIN) == 1) /*skip if no interrupt*/  
-	//    return 0;
-
-	err = stk3x1x_read_flag(client, status);	
-	if (err < 0)
-	{
-		APS_ERR("WARNING: read flag reg error: %d\n", err);
-		return -EFAULT;
-	}
-	APS_LOG("%s: read status reg: 0x%x\n", __func__, *status);
-    
-	if(*status & STK_FLG_ALSINT_MASK)
-	{
-		set_bit(STK_BIT_ALS, &obj->pending_intr);
-	}
-	else
-	{
-	   clear_bit(STK_BIT_ALS, &obj->pending_intr);
-	}
 	
-	if(*status & STK_FLG_PSINT_MASK)
-	{
-		set_bit(STK_BIT_PS,  &obj->pending_intr);
-	}
-	else
-	{
-	    clear_bit(STK_BIT_PS, &obj->pending_intr);
-	}
+	if(enable == obj->ges_enabled)
+		return 0;
 	
-	if(atomic_read(&obj->trace) & STK_TRC_DEBUG)
+	if(enable)
 	{
-		APS_LOG("check intr: 0x%02X => 0x%08lX\n", *status, obj->pending_intr);
-	}
-
-	return 0;
+		if(org_state_reg & STK_STATE_EN_PS_MASK)
+		{
+		//	APS_LOG( "%s: force disable PS\n", __func__);
+		//	stk3x1x_enable_ps(obj->client, 0, 1);
+		//	obj->re_enable_ps = true;
+			APS_LOG( "%s: since PS is enabled, Ges is disabled, mode = %d\n", __func__, mode);
+			obj->re_enable_ges2 = mode;	
+			return 0;
+		}
+		if(org_state_reg & STK_STATE_EN_ALS_MASK) 
+		{
+			APS_LOG( "%s: force disable ALS\n", __func__);						
+			stk3x1x_enable_als(obj->client, 0);		
+			obj->re_enable_als = true;
+		}
+		
+		if((err = stk3x1x_write_wait(client, 0)))
+		{
+			APS_ERR("write wait error: %d\n", err);
+			return err;
+		}		
+		
+		if((err = stk3x1x_write_int(obj->client, 0)))
+		{
+			APS_ERR("write int mode error: %d\n", err);
+			return err;        
+		}				
+			
+		reg = STK_STATE_EN_WAIT_MASK | STK_STATE_EN_PS_MASK; 
+		err = stk3x1x_write_state(client, reg);
+		if(err < 0)
+			return err;
+		atomic_set(&obj->state_val, reg);	
+		obj->ges_enabled = mode;		
+		if(mode == 2)
+		{
+			err = stk3x1x_read_gsctrl(client, &reg);
+			if(err < 0)
+				return err;		
+			reg &= 0xF3;
+			if(obj->hw->polling_mode_ps == 1)
+				reg |= 0x04;
+			else
+				reg |= 0x0C;
+			err = stk3x1x_write_gsctrl(client, reg);
+			if(err < 0)
+				return err;			
+			if(obj->hw->polling_mode_ps == 1)
+			{
+				hrtimer_start(&obj->ps_tune0_timer, obj->ps_tune0_delay, HRTIMER_MODE_REL);			
+			}
+			else
+			{
+//#ifdef MT6516
+//				MT6516_EINTIRQUnmask(CUST_EINT_ALS_NUM);      
+//#endif     
+//#if ((defined MT6573) || (defined MT6575) || (defined MT6577) || (defined MT6589) || (defined MT6572) || (defined MT6582) )
+				mt_eint_unmask(CUST_EINT_ALS_NUM);    
+//#endif				
+			}
+		}			
+	}
+	else
+	{
+		org_mode = obj->ges_enabled;
+		if(org_mode == 2)
+		{	
+			if(obj->hw->polling_mode_ps == 1)
+			{
+				hrtimer_cancel(&obj->ps_tune0_timer);					
+				cancel_work_sync(&obj->stk_ps_tune0_work);					
+			}
+			else
+			{
+//#ifdef MT6516        
+//				MT6516_EINTIRQMask(CUST_EINT_ALS_NUM);  
+//#endif	
+//#if ((defined MT6573) || (defined MT6575) || (defined MT6577) || (defined MT6589) || (defined MT6572) || (defined MT6582) )
+				mt_eint_mask(CUST_EINT_ALS_NUM);    
+//#endif						
+			}
+		}
+		
+		err = stk3x1x_write_state(client, 0);
+		if(err < 0)
+			return err;	
+		atomic_set(&obj->state_val, 0);				
+		if((err = stk3x1x_write_wait(client, obj->wait_val)))
+		{
+			APS_ERR("write wait error: %d\n", err);
+			return err;
+		}	
+				
+		if((err = stk3x1x_write_int(obj->client, obj->int_val)))
+		{
+			APS_ERR("write int mode error: %d\n", err);
+			return err;        
+		}				
+		if(org_mode == 2)
+		{		
+			err = stk3x1x_read_gsctrl(client, &reg);
+			if(err < 0)
+				return err;					
+	
+			reg &= 0xF3;
+			err = stk3x1x_write_gsctrl(client, reg);		
+			if(err < 0)
+				return err;		
+		}
+		obj->ges_enabled = 0;
+		/*
+		if(obj->re_enable_ps)
+		{
+			APS_LOG( "%s: re-enable PS\n", __func__);
+			stk3x1x_enable_ps(obj->client, 1, 1);
+			obj->re_enable_ps = false;
+		}
+		*/
+		if(obj->re_enable_als) 
+		{
+			APS_LOG( "%s: re-enable ALS\n", __func__);
+			stk3x1x_enable_als(obj->client, 1);
+			obj->re_enable_als = false;
+		}
+	}	
+
+	return 0;
+}
+#endif /* #ifdef STK_GES */
+/*----------------------------------------------------------------------------*/
+
+static int stk3x1x_check_intr(struct i2c_client *client, u8 *status) 
+{
+	struct stk3x1x_priv *obj = i2c_get_clientdata(client);
+	int err;
+
+	//if (mt_get_gpio_in(GPIO_ALS_EINT_PIN) == 1) /*skip if no interrupt*/  
+	//    return 0;
+
+	err = stk3x1x_read_flag(client, status);	
+	if (err < 0)
+	{
+		APS_ERR("WARNING: read flag reg error: %d\n", err);
+		return -EFAULT;
+	}
+	APS_LOG("%s: read status reg: 0x%x\n", __func__, *status);
+    
+	if(*status & STK_FLG_ALSINT_MASK)
+	{
+		set_bit(STK_BIT_ALS, &obj->pending_intr);
+	}
+	else
+	{
+	   clear_bit(STK_BIT_ALS, &obj->pending_intr);
+	}
+	
+	if(*status & STK_FLG_PSINT_MASK)
+	{
+		set_bit(STK_BIT_PS,  &obj->pending_intr);
+	}
+	else
+	{
+	    clear_bit(STK_BIT_PS, &obj->pending_intr);
+	}
+	
+	if(atomic_read(&obj->trace) & STK_TRC_DEBUG)
+	{
+		APS_LOG("check intr: 0x%02X => 0x%08lX\n", *status, obj->pending_intr);
+	}
+
+	return 0;
 }
 
 
@@ -1204,13 +1696,123 @@ static int stk3x1x_clear_intr(struct i2c_client *client, u8 status, u8 disable_f
 
     status = status | (STK_FLG_ALSINT_MASK | STK_FLG_PSINT_MASK | STK_FLG_OUI_MASK | STK_FLG_IR_RDY_MASK);
     status &= (~disable_flag);
-	APS_LOG(" set flag reg: 0x%x\n", status);
+	//APS_LOG(" set flag reg: 0x%x\n", status);
 	if((err = stk3x1x_write_flag(client, status)))
 		APS_ERR("stk3x1x_write_flag failed, err=%d\n", err);
     return err;
 }
 
 /*----------------------------------------------------------------------------*/
+#ifdef STK_CHK_REG	
+static int stk3x1x_chk_reg_valid(struct stk3x1x_priv *obj) 
+{    
+	int ret = 0;	
+	u8 buf[9];
+	
+	if(NULL == obj)
+	{
+		return -EINVAL;
+	}	
+	memset(buf, 0, sizeof(buf));
+
+	ret = stk3x1x_master_recv(stk3x1x_obj->client, 1, &buf[0], 7);
+	if(ret < 0)
+	{
+		APS_DBG("error: %d\n", ret);
+		return -EFAULT;
+	}	
+	ret = stk3x1x_master_recv(stk3x1x_obj->client, 8, &buf[7], 2);
+	if(ret < 0)
+	{
+		APS_DBG("error: %d\n", ret);
+		return -EFAULT;
+	}		
+
+	if(buf[0] != atomic_read(&obj->psctrl_val))
+	{
+		APS_ERR("%s: invalid reg 0x01=0x%2x\n", __func__, buf[0]);
+		return 0xFF;
+	}
+	if(buf[1] != atomic_read(&obj->alsctrl_val))
+	{
+		APS_ERR("%s: invalid reg 0x02=0x%2x\n", __func__, buf[1]);
+		return 0xFF;
+	}
+	if(buf[2] != obj->ledctrl_val)
+	{
+		APS_ERR("%s: invalid reg 0x03=0x%2x\n", __func__, buf[2]);
+		return 0xFF;
+	}		
+	if(buf[3] != obj->int_val)
+	{
+		APS_ERR("%s: invalid reg 0x04=0x%2x\n", __func__, buf[3]);
+		return 0xFF;
+	}
+	if(buf[4] != obj->wait_val)
+	{
+		APS_ERR("%s: invalid reg 0x05=0x%2x\n", __func__, buf[4]);
+		return 0xFF;
+	}	
+	if(buf[5] != (atomic_read(&obj->ps_high_thd_val) & 0xFF00) >> 8)
+	{
+		APS_ERR("%s: invalid reg 0x06=0x%2x\n", __func__, buf[5]);
+		return 0xFF;
+	}	
+	if(buf[6] != (atomic_read(&obj->ps_high_thd_val) & 0x00FF))
+	{
+		APS_ERR("%s: invalid reg 0x07=0x%2x\n", __func__, buf[6]);
+		return 0xFF;
+	}	
+	if(buf[7] != (atomic_read(&obj->ps_low_thd_val) & 0xFF00) >> 8)
+	{
+		APS_ERR("%s: invalid reg 0x08=0x%2x\n", __func__, buf[7]);
+		return 0xFF;
+	}	
+	if(buf[8] != (atomic_read(&obj->ps_low_thd_val) & 0x00FF))
+	{
+		APS_ERR("%s: invalid reg 0x09=0x%2x\n", __func__, buf[8]);
+		return 0xFF;
+	}	
+		
+	return 0;
+}
+
+static int stk3x1x_validate_n_handle(struct i2c_client *client) 
+{
+	struct stk3x1x_priv *obj = i2c_get_clientdata(client); 
+	int err;
+	
+	err = stk3x1x_chk_reg_valid(obj);
+	if(err < 0)
+	{
+		APS_ERR("stk3x1x_chk_reg_valid fail: %d\n", err);        
+		return err;
+	}
+	
+	if(err == 0xFF)
+	{		
+		APS_ERR("%s: Re-init chip\n", __func__);
+		stk3x1x_init_client(obj->client);		
+		//obj->psa = 0;
+		//obj->psi = 0xFFFF;		
+		if((err = stk3x1x_write_ps_high_thd(client, atomic_read(&obj->ps_high_thd_val))))
+		{
+			APS_ERR("write high thd error: %d\n", err);
+			return err;        
+		}
+		
+		if((err = stk3x1x_write_ps_low_thd(client, atomic_read(&obj->ps_low_thd_val))))
+		{
+			APS_ERR("write low thd error: %d\n", err);
+			return err;        
+		}		
+		
+		return 0xFF;
+	}
+	return 0;
+}
+#endif /* #ifdef STK_CHK_REG	*/
+/*----------------------------------------------------------------------------*/
 static int stk3x1x_set_als_int_thd(struct i2c_client *client, u16 als_data_reg) 
 {
 	s32 als_thd_h, als_thd_l;	
@@ -1229,6 +1831,331 @@ static int stk3x1x_set_als_int_thd(struct i2c_client *client, u16 als_data_reg)
 	return 0;
 }
 
+static int stk3x1x_ps_val(void)
+{
+	int mode;
+	int32_t word_data, lii;
+	u8 buf[4];
+	int ret;
+	
+	ret = stk3x1x_master_recv(stk3x1x_obj->client, 0x20, buf, 4);
+	if(ret < 0)	
+	{
+		APS_ERR("%s fail, err=0x%x", __FUNCTION__, ret);
+		return ret;	   
+	}
+	word_data = (buf[0] << 8) | buf[1];
+	word_data += (buf[2] << 8) | buf[3];	
+	
+	mode = atomic_read(&stk3x1x_obj->psctrl_val) & 0x3F;
+	if(mode == 0x30)	
+	{
+		lii = 100;	
+	}
+	else if (mode == 0x31)
+	{
+		lii = 200;		
+	}
+	else if (mode == 0x32)
+	{
+		lii = 400;				
+	}
+	else if (mode == 0x33)
+	{
+		lii = 800;			
+	}
+	else
+	{
+		APS_ERR("%s: unsupported PS_IT(0x%x)\n", __FUNCTION__, mode);
+		return -1;
+	}
+	
+	if(word_data > lii)	
+	{
+		APS_LOG( "%s: word_data=%d, lii=%d\n", __FUNCTION__, word_data, lii);		
+		return 0xFFFF;	
+	}
+	return 0;
+}
+#ifdef STK_GES		
+static int32_t stk_ges_poll_func(struct stk3x1x_priv *obj)
+{
+	u8 disable_flag2 = 0, org_flag2_reg, w_flag2_reg;
+	int ret;
+		
+	if(obj->ges_enabled == 2)
+	{
+		ret = stk3x1x_read_flag2(obj->client, &org_flag2_reg);
+		if(ret < 0)
+			return ret;	
+		
+		disable_flag2 = org_flag2_reg & (STK_FLG2_INT_GS_MASK | 
+			STK_FLG2_GS10_MASK | STK_FLG2_GS01_MASK);
+		if(org_flag2_reg & STK_FLG2_GS10_MASK)
+		{
+			APS_LOG( "%s: >>>>>>>>>>>>\n", __func__);
+		}
+		if(org_flag2_reg & STK_FLG2_GS01_MASK)
+		{
+			APS_LOG( "%s: <<<<<<<<<<<<\n", __func__);
+		}
+		atomic_set(&obj->gesture2, (disable_flag2 & 
+			(STK_FLG2_GS10_MASK | STK_FLG2_GS01_MASK)));  		
+		
+		if(disable_flag2)
+		{
+			w_flag2_reg	= org_flag2_reg | (STK_FLG2_INT_GS_MASK | STK_FLG2_GS10_MASK | STK_FLG2_GS01_MASK);
+			w_flag2_reg &= (~disable_flag2);
+			ret = stk3x1x_write_flag2(obj->client, w_flag2_reg);	
+			if(ret < 0)
+				return ret;
+		}			
+	}		
+	
+	return 0;
+}
+#endif
+
+#ifdef STK_TUNE0	
+
+static int stk_ps_tune_zero_final(struct stk3x1x_priv *obj)
+{
+	int err;
+	
+	obj->tune_zero_init_proc = false;
+	if((err = stk3x1x_write_int(obj->client, obj->int_val)))
+	{
+		APS_ERR("write int mode error: %d\n", err);
+		return err;        
+	}	
+	
+	if((err = stk3x1x_write_state(obj->client, atomic_read(&obj->state_val))))
+	{
+		APS_ERR("write stete error: %d\n", err);
+		return err;        
+	}		
+	
+	if(obj->data_count == -1)
+	{
+		APS_LOG("%s: exceed limit\n", __func__);
+		hrtimer_cancel(&obj->ps_tune0_timer);	
+		return 0;
+	}	
+	
+	obj->psa = obj->ps_stat_data[0];
+	obj->psi = obj->ps_stat_data[2];							
+
+#ifndef CALI_EVERY_TIME
+	atomic_set(&obj->ps_high_thd_val, obj->ps_stat_data[1] + STK_HT_N_CT); 
+	atomic_set(&obj->ps_low_thd_val, obj->ps_stat_data[1] + STK_LT_N_CT); 		
+#else						
+	obj->ps_high_thd_boot = obj->ps_stat_data[1] + STK_HT_N_CT*3;
+	obj->ps_low_thd_boot = obj->ps_stat_data[1] + STK_LT_N_CT*3;
+	atomic_set(&obj->ps_high_thd_val, obj->ps_high_thd_boot); 
+	atomic_set(&obj->ps_low_thd_val, obj->ps_low_thd_boot); 
+#endif
+
+	if((err = stk3x1x_write_ps_high_thd(obj->client, atomic_read(&obj->ps_high_thd_val))))
+	{
+		APS_ERR("write high thd error: %d\n", err);
+		return err;        
+	}	
+	if((err = stk3x1x_write_ps_low_thd(obj->client, atomic_read(&obj->ps_low_thd_val))))
+	{
+		APS_ERR("write low thd error: %d\n", err);
+		return err;        
+	}
+	
+	APS_LOG("%s: set HT=%d,LT=%d\n", __func__, atomic_read(&obj->ps_high_thd_val),  atomic_read(&obj->ps_low_thd_val));		
+	hrtimer_cancel(&obj->ps_tune0_timer);					
+	return 0;
+}
+
+static int32_t stk_tune_zero_get_ps_data(struct stk3x1x_priv *obj)
+{
+	int err;
+	
+	err = stk3x1x_ps_val();	
+	if(err == 0xFFFF)
+	{	
+		obj->data_count = -1;
+		stk_ps_tune_zero_final(obj);
+		return 0;	
+	}
+	
+	if((err = stk3x1x_read_ps(obj->client, &obj->ps)))
+	{
+		APS_ERR("stk3x1x read ps data: %d\n", err);
+		return err;
+	}	
+	APS_LOG("%s: ps #%d=%d\n", __func__, obj->data_count, obj->ps);
+	
+	obj->ps_stat_data[1]  +=  obj->ps;			
+	if(obj->ps > obj->ps_stat_data[0])
+		obj->ps_stat_data[0] = obj->ps;
+	if(obj->ps < obj->ps_stat_data[2])
+		obj->ps_stat_data[2] = obj->ps;						
+	obj->data_count++;	
+	
+	if(obj->data_count == 5)
+	{
+		obj->ps_stat_data[1]  /= obj->data_count;			
+		stk_ps_tune_zero_final(obj);
+	}		
+	
+	return 0;
+}
+
+static int stk_ps_tune_zero_init(struct stk3x1x_priv *obj)
+{
+	u8 w_state_reg;	
+	int err;
+	
+	obj->psa = 0;
+	obj->psi = 0xFFFF;	
+	obj->psi_set = 0;	
+	obj->tune_zero_init_proc = true;		
+	obj->ps_stat_data[0] = 0;
+	obj->ps_stat_data[2] = 9999;
+	obj->ps_stat_data[1] = 0;
+	obj->data_count = 0;
+	
+	if((err = stk3x1x_write_int(obj->client, 0)))
+	{
+		APS_ERR("write int mode error: %d\n", err);
+		return err;        
+	}	
+	
+	w_state_reg = (STK_STATE_EN_PS_MASK | STK_STATE_EN_WAIT_MASK);			
+	if((err = stk3x1x_write_state(obj->client, w_state_reg)))
+	{
+		APS_ERR("write stete error: %d\n", err);
+		return err;        
+	}			
+	hrtimer_start(&obj->ps_tune0_timer, obj->ps_tune0_delay, HRTIMER_MODE_REL);		
+	return 0;	
+}
+
+
+static int stk_ps_tune_zero_func_fae(struct stk3x1x_priv *obj)
+{
+	int32_t word_data;
+	u8 flag;
+	bool ps_enabled = false;
+	u8 buf[2];
+	int ret, diff;
+	
+	ps_enabled = (atomic_read(&obj->state_val) & STK_STATE_EN_PS_MASK) ? true : false;	
+
+#ifndef CALI_EVERY_TIME
+	if(obj->psi_set || !(ps_enabled))
+#else
+	if(!(ps_enabled))
+#endif
+	{
+		return 0;
+	}	
+	
+	ret = stk3x1x_read_flag(obj->client, &flag);
+	if(ret < 0)
+	{
+		APS_ERR( "%s: get flag failed, err=0x%x\n", __func__, ret);
+		return ret;
+	}
+	if(!(flag&STK_FLG_PSDR_MASK))
+	{
+		return 0;
+	}
+	
+	ret = stk3x1x_ps_val();	
+	if(ret == 0)
+	{
+		ret = stk3x1x_master_recv(obj->client, 0x11, buf, 2);
+		if(ret < 0)
+		{
+			APS_ERR( "%s fail, err=0x%x", __func__, ret);
+			return ret;	   
+		}
+		word_data = (buf[0] << 8) | buf[1];
+		//APS_LOG("%s: word_data=%d\n", __func__, word_data);
+		
+		if(word_data == 0)
+		{
+			//APS_ERR( "%s: incorrect word data (0)\n", __func__);
+			return 0xFFFF;
+		}
+		
+		if(word_data > obj->psa)
+		{
+			obj->psa = word_data;
+			APS_LOG("%s: update psa: psa=%d,psi=%d\n", __func__, obj->psa, obj->psi);
+		}
+		if(word_data < obj->psi)
+		{
+			obj->psi = word_data;	
+			APS_LOG("%s: update psi: psa=%d,psi=%d\n", __func__, obj->psa, obj->psi);	
+		}	
+	}	
+	
+	diff = obj->psa - obj->psi;
+	if(diff > STK_MAX_MIN_DIFF)
+	{
+		obj->psi_set = obj->psi; // obj->psi = CT
+		atomic_set(&obj->ps_high_thd_val, obj->psi + STK_HT_N_CT); 
+		atomic_set(&obj->ps_low_thd_val, obj->psi + STK_LT_N_CT); 
+		
+#ifdef CALI_EVERY_TIME
+		if( atomic_read(&obj->ps_high_thd_val) > obj->ps_high_thd_boot )
+		{
+			obj->ps_high_thd_boot = atomic_read(&obj->ps_high_thd_val);
+			obj->ps_low_thd_boot = atomic_read(&obj->ps_low_thd_val);
+			APS_LOG("%s: update boot HT=%d, LT=%d\n", __func__, obj->ps_high_thd_boot, obj->ps_low_thd_boot);
+		}
+#endif
+
+		if((ret = stk3x1x_write_ps_high_thd(obj->client, atomic_read(&obj->ps_high_thd_val))))
+		{
+			APS_ERR("write high thd error: %d\n", ret);
+			return ret;        
+		}		
+		if((ret = stk3x1x_write_ps_low_thd(obj->client, atomic_read(&obj->ps_low_thd_val))))
+		{
+			APS_ERR("write low thd error: %d\n", ret);
+			return ret;        
+		}	
+#ifdef STK_DEBUG_PRINTF				
+		APS_LOG("%s: FAE tune0 psa-psi(%d) > DIFF found\n", __func__, diff);
+#endif					
+		APS_LOG("%s: set HT=%d, LT=%d\n", __func__, atomic_read(&obj->ps_high_thd_val), atomic_read(&obj->ps_low_thd_val));
+		hrtimer_cancel(&obj->ps_tune0_timer);
+	}
+	
+	return 0;
+}	
+#endif	/*#ifdef STK_TUNE0	*/
+
+static void stk_ps_tune0_work_func(struct work_struct *work)
+{
+	struct stk3x1x_priv *obj = container_of(work, struct stk3x1x_priv, stk_ps_tune0_work);		
+#ifdef STK_GES		
+	if(obj->ges_enabled)
+		stk_ges_poll_func(obj);
+#endif
+	if(obj->tune_zero_init_proc)
+		stk_tune_zero_get_ps_data(obj);
+	else
+		stk_ps_tune_zero_func_fae(obj);
+	return;
+}	
+
+
+static enum hrtimer_restart stk_ps_tune0_timer_func(struct hrtimer *timer)
+{
+	struct stk3x1x_priv *obj = container_of(timer, struct stk3x1x_priv, ps_tune0_timer);
+	queue_work(obj->stk_ps_tune0_wq, &obj->stk_ps_tune0_work);	
+	hrtimer_forward_now(&obj->ps_tune0_timer, obj->ps_tune0_delay);
+	return HRTIMER_RESTART;	
+}
 /*----------------------------------------------------------------------------*/
 void stk3x1x_eint_func(void)
 {
@@ -1239,8 +2166,6 @@ void stk3x1x_eint_func(void)
 		return;
 	}
 	//schedule_work(&obj->eint_work);
-	int_top_time = sched_clock();
-    mt_eint_mask(CUST_EINT_ALS_NUM);
 	if(obj->hw->polling_mode_ps == 0 || obj->hw->polling_mode_als == 0)
 		schedule_delayed_work(&obj->eint_work,0);
 	if(atomic_read(&obj->trace) & STK_TRC_EINT)
@@ -1255,10 +2180,10 @@ static void stk3x1x_eint_work(struct work_struct *work)
 	int err;
 	hwm_sensor_data sensor_data;
 	u8 flag_reg, disable_flag = 0;
-	
+
 	memset(&sensor_data, 0, sizeof(sensor_data));
 
-	APS_LOG("stk3x1x int top half time = %lld\n", int_top_time);
+	APS_LOG(" eint work\n");
 	
 	if((err = stk3x1x_check_intr(obj->client, &flag_reg)))
 	{
@@ -1285,9 +2210,9 @@ static void stk3x1x_eint_work(struct work_struct *work)
 		sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
 		APS_LOG("%s:als raw 0x%x -> value 0x%x \n", __FUNCTION__, obj->als,sensor_data.values[0]);
 		//let up layer to know
-		if(ps_report_interrupt_data(sensor_data.values[0]))
+		if((err = hwmsen_get_interrupt_data(ID_LIGHT, &sensor_data)))
 		{
-			APS_ERR("call ps_report_interrupt_data fail \n");
+			APS_ERR("call hwmsen_get_interrupt_data fail = %d\n", err);
 		}	  
 	}
 	if(((1<<STK_BIT_PS) &  obj->pending_intr) && (obj->hw->polling_mode_ps == 0))
@@ -1306,26 +2231,40 @@ static void stk3x1x_eint_work(struct work_struct *work)
 		sensor_data.status = SENSOR_STATUS_ACCURACY_MEDIUM;
 		APS_LOG("%s:ps raw 0x%x -> value 0x%x \n",__FUNCTION__, obj->ps,sensor_data.values[0]);
 		//let up layer to know
-		if(ps_report_interrupt_data(sensor_data.values[0]))
-		{	
-			APS_ERR("call ps_report_interrupt_data fail\n");
-		}
+		ps_report_interrupt_data(sensor_data.values[0]);
+//		if((err = hwmsen_get_interrupt_data(ID_PROXIMITY, &sensor_data)))
+//		{	
+//			APS_ERR("call hwmsen_get_interrupt_data fail = %d\n", err);
+//		}
 		
 	}
-	
-	if((err = stk3x1x_clear_intr(obj->client, flag_reg, disable_flag)))
+	if(disable_flag)
 	{
-		APS_ERR("fail: %d\n", err);
-		goto err_i2c_rw;
-	}		
+		if((err = stk3x1x_clear_intr(obj->client, flag_reg, disable_flag)))
+		{
+			APS_ERR("fail: %d\n", err);
+			goto err_i2c_rw;
+		}		
+	}
+		
+	msleep(1);
+//#ifdef MT6516
+//	MT6516_EINTIRQUnmask(CUST_EINT_ALS_NUM);      
+//#endif     
+//#if ((defined MT6573) || (defined MT6575) || (defined MT6577) || (defined MT6589) || (defined MT6572) || (defined MT6582))
+	mt_eint_unmask(CUST_EINT_ALS_NUM);    
+//#endif	
 
-	msleep(1);    
-	mt_eint_unmask(CUST_EINT_ALS_NUM);  
 	return;
 	
 err_i2c_rw:	
-	msleep(30);    
+	msleep(30);
+//#ifdef MT6516
+//	MT6516_EINTIRQUnmask(CUST_EINT_ALS_NUM);      
+//#endif     
+//#if ((defined MT6573) || (defined MT6575) || (defined MT6577) || (defined MT6589) || (defined MT6572) || (defined MT6582))
 	mt_eint_unmask(CUST_EINT_ALS_NUM);    
+//#endif	
 	return;
 }
 /*----------------------------------------------------------------------------*/
@@ -1343,9 +2282,30 @@ int stk3x1x_setup_eint(struct i2c_client *client)
 	mt_set_gpio_pull_enable(GPIO_ALS_EINT_PIN, GPIO_PULL_ENABLE);
 	mt_set_gpio_pull_select(GPIO_ALS_EINT_PIN, GPIO_PULL_UP);
 
+//#ifdef MT6516
+//	MT6516_EINT_Set_Sensitivity(CUST_EINT_ALS_NUM, CUST_EINT_ALS_SENSITIVE);
+//	MT6516_EINT_Set_Polarity(CUST_EINT_ALS_NUM, CUST_EINT_ALS_POLARITY);
+//	MT6516_EINT_Set_HW_Debounce(CUST_EINT_ALS_NUM, CUST_EINT_ALS_DEBOUNCE_CN);
+//	MT6516_EINT_Registration(CUST_EINT_ALS_NUM, CUST_EINT_ALS_DEBOUNCE_EN, CUST_EINT_ALS_POLARITY, stk3x1x_eint_func, 0);
+//	MT6516_EINTIRQUnmask(CUST_EINT_ALS_NUM);  
+//#endif
+//    
+//#if ((defined MT6573) || (defined MT6575) || (defined MT6577) || (defined MT6589) || (defined MT6572) || (defined MT6582))
+/*
+       mt_eint_set_sens(CUST_EINT_ALS_NUM, CUST_EINT_ALS_SENSITIVE);
+	mt_eint_set_polarity(CUST_EINT_ALS_NUM, CUST_EINT_ALS_POLARITY);
+	mt_eint_set_hw_debounce(CUST_EINT_ALS_NUM, CUST_EINT_ALS_DEBOUNCE_CN);
+	mt_eint_registration(CUST_EINT_ALS_NUM, CUST_EINT_ALS_DEBOUNCE_EN, CUST_EINT_ALS_POLARITY, stk3x1x_eint_func, 0);
+	mt_eint_unmask(CUST_EINT_ALS_NUM);  
+*/
+    mt_set_gpio_mode(GPIO_ALS_EINT_PIN, GPIO_ALS_EINT_PIN_M_EINT);
+    mt_set_gpio_dir(GPIO_ALS_EINT_PIN, GPIO_DIR_IN);
+    mt_set_gpio_pull_enable(GPIO_ALS_EINT_PIN, GPIO_PULL_ENABLE);
+    mt_set_gpio_pull_select(GPIO_ALS_EINT_PIN, GPIO_PULL_UP);
 	mt_eint_set_hw_debounce(CUST_EINT_ALS_NUM, CUST_EINT_ALS_DEBOUNCE_CN);
 	mt_eint_registration(CUST_EINT_ALS_NUM, CUST_EINT_ALS_TYPE, stk3x1x_eint_func, 0);
-	mt_eint_unmask(CUST_EINT_ALS_NUM);
+	mt_eint_unmask(CUST_EINT_ALS_NUM);  
+//#endif  	
     return 0;
 }
 /*----------------------------------------------------------------------------*/
@@ -1361,34 +2321,35 @@ static int stk3x1x_init_client(struct i2c_client *client)
 		APS_ERR("software reset error, err=%d", err);
 		return err;
 	}
-/*
+
 	if((err = stk3x1x_read_id(client)))
 	{
 		APS_ERR("stk3x1x_read_id error, err=%d", err);
 		return err;
 	}		
-*/	
-	if(obj->hw->polling_mode_ps == 0 || obj->hw->polling_mode_als == 0)
-	{
-        mt_eint_mask(CUST_EINT_ALS_NUM);
-		if((err = stk3x1x_setup_eint(client)))
+	
+	if(obj->first_boot == true)
+	{	
+		if(obj->hw->polling_mode_ps == 0 || obj->hw->polling_mode_als == 0)
 		{
-			APS_ERR("setup eint error: %d\n", err);
-			return err;
+			if((err = stk3x1x_setup_eint(client)))
+			{
+				APS_ERR("setup eint error: %d\n", err);
+				return err;
+			}
 		}
 	}
-	
 	if((err = stk3x1x_write_state(client, atomic_read(&obj->state_val))))
 	{
 		APS_ERR("write stete error: %d\n", err);
 		return err;        
 	}	
 	
-	/*
+/*	
 	if((err = stk3x1x_check_intr(client, &int_status)))
 	{
 		APS_ERR("check intr error: %d\n", err);
-		//    return err;
+		return err;
 	}
 	
 	if((err = stk3x1x_clear_intr(client, int_status, STK_FLG_PSINT_MASK | STK_FLG_ALSINT_MASK)))
@@ -1396,7 +2357,7 @@ static int stk3x1x_init_client(struct i2c_client *client)
 		APS_ERR("clear intr error: %d\n", err);	
 		return err;
 	}
-	*/
+*/	
 	ps_ctrl = atomic_read(&obj->psctrl_val);
 	if(obj->hw->polling_mode_ps == 1)
 		ps_ctrl &= 0x3F;
@@ -1424,14 +2385,49 @@ static int stk3x1x_init_client(struct i2c_client *client)
 		APS_ERR("write wait error: %d\n", err);
 		return err;
 	}	
+#ifndef STK_TUNE0	
+	if((err = stk3x1x_write_ps_high_thd(client, atomic_read(&obj->ps_high_thd_val))))
+	{
+		APS_ERR("write high thd error: %d\n", err);
+		return err;        
+	}
+	
+	if((err = stk3x1x_write_ps_low_thd(client, atomic_read(&obj->ps_low_thd_val))))
+	{
+		APS_ERR("write low thd error: %d\n", err);
+		return err;        
+	}
+#endif	
 	if((err = stk3x1x_write_int(client, obj->int_val)))
 	{
 		APS_ERR("write int mode error: %d\n", err);
 		return err;        
-	}	
-#ifdef STK_FIR
+	}		
+	
+	/*
+	u8 data;
+	data = 0x60;
+    err = stk3x1x_master_send(client, 0x87, &data, 1);
+	if (err < 0)
+	{
+		APS_ERR("write 0x87 = %d\n", err);
+		return -EFAULT;
+	} 
+	*/
+#ifdef STK_ALS_FIR
 	memset(&obj->fir, 0x00, sizeof(obj->fir));  
 #endif
+#ifdef STK_TUNE0
+	if(obj->first_boot == true)
+		stk_ps_tune_zero_init(obj);
+#endif	
+#ifdef STK_GES	
+	obj->re_enable_ges = false;	
+	obj->re_enable_ges2 = 0;	
+	atomic_set(&obj->gesture2, 0);
+#endif
+	obj->re_enable_ps = false;
+	obj->re_enable_als = false;
 	return 0;
 }
 
@@ -1488,7 +2484,7 @@ static ssize_t stk3x1x_store_config(struct device_driver *ddri, const char *buf,
 	}
 	else
 	{
-		APS_ERR("invalid content: '%s', length = %zu\n", buf, count);
+		APS_ERR("invalid content: '%s', length = %d\n", buf, (int)count);
 	}
 	return count;    
 }
@@ -1667,8 +2663,9 @@ static ssize_t stk3x1x_store_recv(struct device_driver *ddri, const char *buf, s
 static ssize_t stk3x1x_show_allreg(struct device_driver *ddri, char *buf)
 {
 	int ret = 0;
-	u8 rbuf[27];
+	u8 rbuf[0x22];
 	int cnt;	
+	int len = 0;
 	
 	memset(rbuf, 0, sizeof(rbuf));
 	if(!stk3x1x_obj)
@@ -1694,29 +2691,41 @@ static ssize_t stk3x1x_show_allreg(struct device_driver *ddri, char *buf)
 		APS_DBG("error: %d\n", ret);
 		return -EFAULT;
 	}	
-	ret = stk3x1x_master_recv(stk3x1x_obj->client, 21, &rbuf[21], 4);
+	ret = stk3x1x_master_recv(stk3x1x_obj->client, 21, &rbuf[21], 7);
 	if(ret < 0)
 	{
 		APS_DBG("error: %d\n", ret);
 		return -EFAULT;
 	}
-	ret = stk3x1x_master_recv(stk3x1x_obj->client, STK_PDT_ID_REG, &rbuf[25], 2);
+	ret = stk3x1x_master_recv(stk3x1x_obj->client, 28, &rbuf[28], 4);
+	if(ret < 0)
+	{
+		APS_DBG("error: %d\n", ret);
+		return -EFAULT;
+	}
+	
+	ret = stk3x1x_master_recv(stk3x1x_obj->client, STK_PDT_ID_REG, &rbuf[32], 2);
 	if(ret < 0)
 	{
 		APS_DBG("error: %d\n", ret);
 		return -EFAULT;
 	}	
 	
-	for(cnt=0;cnt<25;cnt++)
+	for(cnt=0;cnt<0x20;cnt++)
 	{
 		APS_LOG("reg[0x%x]=0x%x\n", cnt, rbuf[cnt]);
+		len += scnprintf(buf+len, PAGE_SIZE-len, "[%2X]%2X,", cnt, rbuf[cnt]);
 	}	
 	APS_LOG("reg[0x3E]=0x%x\n", rbuf[cnt]);
 	APS_LOG("reg[0x3F]=0x%x\n", rbuf[cnt++]);
+	len += scnprintf(buf+len, PAGE_SIZE-len, "[0x3E]%2X,[0x3F]%2X\n", rbuf[cnt-1], rbuf[cnt]);	
+	return len;
+	/*
     return scnprintf(buf, PAGE_SIZE, "[0]%2X [1]%2X [2]%2X [3]%2X [4]%2X [5]%2X [6/7 HTHD]%2X,%2X [8/9 LTHD]%2X, %2X [A]%2X [B]%2X [C]%2X [D]%2X [E/F Aoff]%2X,%2X,[10]%2X [11/12 PS]%2X,%2X [13]%2X [14]%2X [15/16 Foff]%2X,%2X [17]%2X [18]%2X [3E]%2X [3F]%2X\n", 	
 		rbuf[0], rbuf[1], rbuf[2], rbuf[3], rbuf[4], rbuf[5], rbuf[6], rbuf[7], rbuf[8], 
 		rbuf[9], rbuf[10], rbuf[11], rbuf[12], rbuf[13], rbuf[14], rbuf[15], rbuf[16], rbuf[17], 
 		rbuf[18], rbuf[19], rbuf[20], rbuf[21], rbuf[22], rbuf[23], rbuf[24], rbuf[25], rbuf[26]);	
+	*/
 }
 /*----------------------------------------------------------------------------*/
 static ssize_t stk3x1x_show_status(struct device_driver *ddri, char *buf)
@@ -1747,6 +2756,14 @@ static ssize_t stk3x1x_show_status(struct device_driver *ddri, char *buf)
 				atomic_read(&stk3x1x_obj->state_val), atomic_read(&stk3x1x_obj->psctrl_val), atomic_read(&stk3x1x_obj->alsctrl_val), 
 				stk3x1x_obj->ledctrl_val, stk3x1x_obj->int_val, stk3x1x_obj->wait_val, 
 				atomic_read(&stk3x1x_obj->ps_high_thd_val), atomic_read(&stk3x1x_obj->ps_low_thd_val),stk3x1x_obj->enable, stk3x1x_obj->pending_intr);
+//#ifdef MT6516
+//	len += scnprintf(buf+len, PAGE_SIZE-len, "EINT: %d (%d %d %d %d)\n", mt_get_gpio_in(GPIO_ALS_EINT_PIN),
+//				CUST_EINT_ALS_NUM, CUST_EINT_ALS_POLARITY, CUST_EINT_ALS_DEBOUNCE_EN, CUST_EINT_ALS_DEBOUNCE_CN);
+
+//	len += scnprintf(buf+len, PAGE_SIZE-len, "GPIO: %d (%d %d %d %d)\n",	GPIO_ALS_EINT_PIN, 
+//				mt_get_gpio_dir(GPIO_ALS_EINT_PIN), mt_get_gpio_mode(GPIO_ALS_EINT_PIN), 
+//				mt_get_gpio_pull_enable(GPIO_ALS_EINT_PIN), mt_get_gpio_pull_select(GPIO_ALS_EINT_PIN));
+//#endif
 
 	len += scnprintf(buf+len, PAGE_SIZE-len, "MISC: %d %d\n", atomic_read(&stk3x1x_obj->als_suspend), atomic_read(&stk3x1x_obj->ps_suspend));	
 	len += scnprintf(buf+len, PAGE_SIZE-len, "VER.: %s\n", DRIVER_VERSION);
@@ -1841,54 +2858,144 @@ static ssize_t stk3x1x_store_alslv(struct device_driver *ddri, const char *buf,
 	}
 	else if(!strcmp(buf, "def"))
 	{
-		memcpy(stk3x1x_obj->als_level, stk3x1x_obj->hw->als_level, sizeof(stk3x1x_obj->als_level));
+		memcpy(stk3x1x_obj->als_level, stk3x1x_obj->hw->als_level, sizeof(stk3x1x_obj->als_level));
+	}
+	else if(stk3x1x_obj->als_level_num != read_int_from_buf(stk3x1x_obj, buf, count, 
+			stk3x1x_obj->hw->als_level, stk3x1x_obj->als_level_num))
+	{
+		APS_ERR("invalid format: '%s'\n", buf);
+	}    
+	return count;
+}
+/*----------------------------------------------------------------------------*/
+static ssize_t stk3x1x_show_alsval(struct device_driver *ddri, char *buf)
+{
+	ssize_t len = 0;
+	int idx;
+	if(!stk3x1x_obj)
+	{
+		APS_ERR("stk3x1x_obj is null!!\n");
+		return 0;
+	}
+	
+	for(idx = 0; idx < stk3x1x_obj->als_value_num; idx++)
+	{
+		len += scnprintf(buf+len, PAGE_SIZE-len, "%d ", stk3x1x_obj->hw->als_value[idx]);
+	}
+	len += scnprintf(buf+len, PAGE_SIZE-len, "\n");
+	return len;    
+}
+/*----------------------------------------------------------------------------*/
+static ssize_t stk3x1x_store_alsval(struct device_driver *ddri, const char *buf, size_t count)
+{
+	if(!stk3x1x_obj)
+	{
+		APS_ERR("stk3x1x_obj is null!!\n");
+		return 0;
+	}
+	else if(!strcmp(buf, "def"))
+	{
+		memcpy(stk3x1x_obj->als_value, stk3x1x_obj->hw->als_value, sizeof(stk3x1x_obj->als_value));
+	}
+	else if(stk3x1x_obj->als_value_num != read_int_from_buf(stk3x1x_obj, buf, count, 
+			stk3x1x_obj->hw->als_value, stk3x1x_obj->als_value_num))
+	{
+		APS_ERR("invalid format: '%s'\n", buf);
+	}    
+	return count;
+}
+
+#ifdef STK_TUNE0
+static ssize_t stk3x1x_show_cali(struct device_driver *ddri, char *buf)
+{
+	int32_t word_data;
+	u8 r_buf[2];
+	int ret;
+	
+	if(!stk3x1x_obj)
+	{
+		APS_ERR("stk3x1x_obj is null!!\n");
+		return 0;
+	}
+
+	ret = stk3x1x_master_recv(stk3x1x_obj->client, 0x20, r_buf, 2);
+	if(ret < 0)	
+	{
+		APS_ERR("%s fail, err=0x%x", __FUNCTION__, ret);
+		return ret;	   
 	}
-	else if(stk3x1x_obj->als_level_num != read_int_from_buf(stk3x1x_obj, buf, count, 
-			stk3x1x_obj->hw->als_level, stk3x1x_obj->als_level_num))
+	word_data = (r_buf[0] << 8) | r_buf[1];
+
+	ret = stk3x1x_master_recv(stk3x1x_obj->client, 0x22, r_buf, 2);
+	if(ret < 0)		
 	{
-		APS_ERR("invalid format: '%s'\n", buf);
-	}    
-	return count;
+		APS_ERR("%s fail, err=0x%x", __FUNCTION__, ret);
+		return ret;	   
+	}	
+	word_data += (r_buf[0] << 8) | r_buf[1];	
+
+	APS_LOG("%s: psi_set=%d, psa=%d,psi=%d, word_data=%d\n", __FUNCTION__, 
+		stk3x1x_obj->psi_set, stk3x1x_obj->psa, stk3x1x_obj->psi, word_data);	
+#ifdef CALI_EVERY_TIME
+	APS_LOG("%s: boot HT=%d, LT=%d\n", __func__, stk3x1x_obj->ps_high_thd_boot, stk3x1x_obj->ps_low_thd_boot);
+#endif
+	return scnprintf(buf, PAGE_SIZE, "%5d\n", stk3x1x_obj->psi_set);		
+	//return 0;
 }
+#endif
+
+#ifdef STK_ALS_FIR
 /*----------------------------------------------------------------------------*/
-static ssize_t stk3x1x_show_alsval(struct device_driver *ddri, char *buf)
+static ssize_t stk3x1x_show_firlen(struct device_driver *ddri, char *buf)
 {
-	ssize_t len = 0;
-	int idx;
+	int len = atomic_read(&stk3x1x_obj->firlength);
+	
 	if(!stk3x1x_obj)
 	{
 		APS_ERR("stk3x1x_obj is null!!\n");
 		return 0;
 	}
+		
+	APS_LOG("%s: len = %2d, idx = %2d\n", __func__, len, stk3x1x_obj->fir.idx);			
+	APS_LOG("%s: sum = %5d, ave = %5d\n", __func__, stk3x1x_obj->fir.sum, stk3x1x_obj->fir.sum/len);
 	
-	for(idx = 0; idx < stk3x1x_obj->als_value_num; idx++)
-	{
-		len += scnprintf(buf+len, PAGE_SIZE-len, "%d ", stk3x1x_obj->hw->als_value[idx]);
-	}
-	len += scnprintf(buf+len, PAGE_SIZE-len, "\n");
-	return len;    
+	return scnprintf(buf, PAGE_SIZE, "%d\n", len);		
 }
+
 /*----------------------------------------------------------------------------*/
-static ssize_t stk3x1x_store_alsval(struct device_driver *ddri, const char *buf, size_t count)
+static ssize_t stk3x1x_store_firlen(struct device_driver *ddri, const char *buf, size_t count)
 {
+	int value;
+
 	if(!stk3x1x_obj)
 	{
 		APS_ERR("stk3x1x_obj is null!!\n");
 		return 0;
 	}
-	else if(!strcmp(buf, "def"))
+	else if(1 != sscanf(buf, "%d", &value))
 	{
-		memcpy(stk3x1x_obj->als_value, stk3x1x_obj->hw->als_value, sizeof(stk3x1x_obj->als_value));
+		APS_ERR("invalid format: '%s'\n", buf);
+		return 0;
 	}
-	else if(stk3x1x_obj->als_value_num != read_int_from_buf(stk3x1x_obj, buf, count, 
-			stk3x1x_obj->hw->als_value, stk3x1x_obj->als_value_num))
+		
+	if(value > MAX_FIR_LEN)
 	{
-		APS_ERR("invalid format: '%s'\n", buf);
-	}    
+		APS_ERR("%s: firlen exceed maximum filter length\n", __func__);
+	}
+	else if (value < 1)
+	{
+		atomic_set(&stk3x1x_obj->firlength, 1);
+		memset(&stk3x1x_obj->fir, 0x00, sizeof(stk3x1x_obj->fir));
+	}
+	else
+	{ 
+		atomic_set(&stk3x1x_obj->firlength, value);
+		memset(&stk3x1x_obj->fir, 0x00, sizeof(stk3x1x_obj->fir));
+	}
+	
 	return count;
 }
-
-
+#endif /* #ifdef STK_ALS_FIR */
 /*----------------------------------------------------------------------------*/
 static DRIVER_ATTR(als,     S_IWUSR | S_IRUGO, stk3x1x_show_als,   NULL);
 static DRIVER_ATTR(ps,      S_IWUSR | S_IRUGO, stk3x1x_show_ps,    NULL);
@@ -1902,6 +3009,12 @@ static DRIVER_ATTR(send,    S_IWUSR | S_IRUGO, stk3x1x_show_send,  stk3x1x_store
 static DRIVER_ATTR(recv,    S_IWUSR | S_IRUGO, stk3x1x_show_recv,  stk3x1x_store_recv);
 static DRIVER_ATTR(reg,     S_IWUSR | S_IRUGO, stk3x1x_show_reg,   NULL);
 static DRIVER_ATTR(allreg,  S_IWUSR | S_IRUGO, stk3x1x_show_allreg,   NULL);
+#ifdef STK_TUNE0
+static DRIVER_ATTR(cali,    S_IWUSR | S_IRUGO, stk3x1x_show_cali,  NULL);
+#endif
+#ifdef STK_ALS_FIR
+static DRIVER_ATTR(firlen,    S_IWUSR | S_IRUGO, stk3x1x_show_firlen,  stk3x1x_store_firlen);
+#endif
 /*----------------------------------------------------------------------------*/
 static struct driver_attribute *stk3x1x_attr_list[] = {
     &driver_attr_als,
@@ -1917,6 +3030,12 @@ static struct driver_attribute *stk3x1x_attr_list[] = {
     &driver_attr_allreg,
 //    &driver_attr_i2c,
     &driver_attr_reg,
+#ifdef STK_TUNE0
+    &driver_attr_cali,
+#endif	
+#ifdef STK_ALS_FIR
+    &driver_attr_firlen,
+#endif	
 };
 
 /*----------------------------------------------------------------------------*/
@@ -1955,9 +3074,304 @@ static int stk3x1x_delete_attr(struct device_driver *driver)
 	
 	return err;
 }
+
+
+#ifdef STK_GES		
+static ssize_t stk_ges_poll_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int len = 0, ii = 0, jj = 0;
+	
+	while(stk_ges_op[ii].ops[0] != 0)
+	{
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%x ", ii);
+		for(jj=0;jj<4;jj++)
+			len += scnprintf(buf + len, PAGE_SIZE - len, "%x ", stk_ges_op[ii].ops[jj]);
+		len += scnprintf(buf + len, PAGE_SIZE - len, "\n");
+		ii++;
+	}
+	return len;
+}
+
+static ssize_t stk_ges_poll_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	int32_t ret, i = 0, index = 0;	
+	char *token;
+	unsigned long value = 0;
+		
+	while(buf != '\0')
+	{
+		token = strsep((char **)&buf, " ");
+		if((ret = strict_strtoul(token, 16, &value)) < 0)
+		{
+			printk(KERN_ERR "%s:strict_strtoul failed, ret=0x%x\n", __func__, ret);
+			return ret;	
+		}
+		
+		if(i == 0)
+		{
+			if(value >= 10)
+			{
+				memset(stk_ges_op, 0, sizeof(stk_ges_op));				
+				break;
+			}
+			else
+				index = value;
+		}
+		else
+		{
+			stk_ges_op[index].ops[i-1] = value;
+		}
+		i++;
+		if(i == 5)
+			break;
+	}
+	if(i != 5)
+	{
+		printk(KERN_ERR "%s: invalid length(%d)\n", __func__, i);
+		memset(&(stk_ges_op[index]), 0, sizeof(union stk_ges_operation));				
+	}
+	return size;
+}
+		
+static ssize_t stk_ges_code_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct stk3x1x_priv *obj =  dev_get_drvdata(dev);	
+    int ret;
+	unsigned int gest0 = 0, gest1 = 0, gest2 = 0;
+	
+	if(obj->ges_enabled)
+    ret = stk3x1x_get_ges_value(obj, &gest0, &gest1, &gest2);
+	else
+		ret = -EFAULT;
+		
+	if(ret < 0)
+		return ret;
+	//else if(ret == 0xFFFF)
+	//	atomic_set(&obj->gesture2, 0);		
+		
+    return scnprintf(buf, PAGE_SIZE, "%5d,%5d,%5d\n", gest0, gest1, atomic_read(&obj->gesture2));
+}
+
+static ssize_t stk_ges_code_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct stk3x1x_priv *obj =  dev_get_drvdata(dev);
+	uint8_t ges;
+	unsigned long value = 0;
+	int ret;
+	
+	ret = strict_strtoul(buf, 16, &value);
+	if(ret < 0)
+	{
+		APS_ERR( "%s:strict_strtoul failed, ret=%d\n", __func__, ret);	
+		return ret;	
+	}	
+	
+	if(obj->ges_enabled)
+	{
+		switch(value)
+		{
+		case 3:
+			//APS_LOG( "%s: ges input event, not detected\n",__func__);			
+		case 0:
+			return size;
+		case 1:
+//			ges = KEY_PAGEUP;	
+			ges = KEY_F2;	
+			atomic_set(&obj->gesture2, 0);
+			APS_LOG( "%s: ges input event >>>\n",__func__);		
+			break;
+		case 2:
+//			ges = KEY_PAGEDOWN;	
+			ges = KEY_F3;	
+			atomic_set(&obj->gesture2, 0);
+			APS_LOG( "%s: ges input event <<<\n",__func__);		
+			break;
+//		case 32:
+//			ges = KEY_VOLUMEDOWN;
+//			APS_LOG( "%s: ges input event near\n",__func__);				
+//			break;
+//		case 48:
+//			ges = KEY_VOLUMEUP;
+//			APS_LOG( "%s: ges input event far\n",__func__);				
+//			break;
+		default:
+			APS_ERR( "%s, invalid value %d\n", __func__, (int)value);
+			return -EINVAL;
+		}
+	
+		input_report_key(obj->ges_input_dev, ges, 1);
+		input_report_key(obj->ges_input_dev, ges, 0);
+		input_sync(obj->ges_input_dev);
+	}
+    return size;
+}
+
+static ssize_t stk_ges_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct stk3x1x_priv *obj =  dev_get_drvdata(dev);
+	unsigned long value = 0;
+	int ret;
+	
+	ret = strict_strtoul(buf, 16, &value);
+	if(ret < 0)
+	{
+		APS_ERR( "%s:strict_strtoul failed, ret=%d\n", __func__, ret);	
+		return ret;	
+	}	
+    APS_LOG( "%s: Enable GES : %d\n", __func__, (int)value);
+	
+	switch(value)
+	{
+	case 0:
+		if(obj->ges_enabled == 1)
+			stk3x1x_enable_ges(obj->client, 0, 1);
+		else
+			stk3x1x_enable_ges(obj->client, 0, 2);
+		break;
+	case 1:
+		stk3x1x_enable_ges(obj->client, 1, 1);
+		break;
+	case 2:
+		stk3x1x_enable_ges(obj->client, 1, 2);
+		break;
+	default:
+		APS_ERR( "%s, invalid value %d\n", __func__, *buf);
+		return -EINVAL;	
+	}
+
+    return size;
+}
+
+static ssize_t stk_ges_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct stk3x1x_priv *obj =  dev_get_drvdata(dev);
+	
+	return scnprintf(buf, PAGE_SIZE, "%d\n", obj->ges_enabled);		
+}
+
+static ssize_t stk_recv_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(!stk3x1x_obj)
+	{
+		APS_ERR("stk3x1x_obj is null!!\n");
+		return 0;
+	}
+	return scnprintf(buf, PAGE_SIZE, "0x%04X\n", atomic_read(&stk3x1x_obj->recv_reg));     	
+}
+
+static ssize_t stk_recv_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	int addr;
+	u8 dat;
+	if(!stk3x1x_obj)
+	{
+		APS_ERR("stk3x1x_obj is null!!\n");
+		return 0;
+	}
+	else if(1 != sscanf(buf, "%x", &addr))
+	{
+		APS_ERR("invalid format: '%s'\n", buf);
+		return 0;
+	}
+	stk3x1x_master_recv(stk3x1x_obj->client, (u16)addr, (char*)&dat, sizeof(dat));
+	//APS_LOG("recv(%02X) = %d, 0x%02X\n", addr, 
+	//stk3x1x_master_recv(stk3x1x_obj->client, (u16)addr, (char*)&dat, sizeof(dat)), dat);
+	atomic_set(&stk3x1x_obj->recv_reg, dat);	
+	return size;
+}
+
+static ssize_t stk_send_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t stk_send_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	int addr, cmd;
+	u8 dat;
+
+	if(!stk3x1x_obj)
+	{
+		APS_ERR("stk3x1x_obj is null!!\n");
+		return 0;
+	}
+	else if(2 != sscanf(buf, "%x %x", &addr, &cmd))
+	{
+		APS_ERR("invalid format: '%s'\n", buf);
+		return 0;
+	}
+
+	dat = (u8)cmd;
+	APS_LOG("send(%02X, %02X) = %d\n", addr, cmd, 
+	stk3x1x_master_send(stk3x1x_obj->client, (u16)addr, &dat, sizeof(dat)));
+	
+	return size;
+}
+
+static struct device_attribute ges_enable_attribute = __ATTR(enable,0664,stk_ges_enable_show,stk_ges_enable_store);
+static struct device_attribute ges_code_attribute = __ATTR(code, 0664, stk_ges_code_show, stk_ges_code_store);
+static struct device_attribute ges_poll_attribute = __ATTR(poll, 0664, stk_ges_poll_show, stk_ges_poll_store);
+static struct device_attribute ges_recv_attribute = __ATTR(recv,0664,stk_recv_show,stk_recv_store);
+static struct device_attribute ges_send_attribute = __ATTR(send,0664,stk_send_show, stk_send_store);
+
+static struct attribute *stk_ges_attrs [] =
+{
+    &ges_enable_attribute.attr,	
+    &ges_code_attribute.attr,
+    &ges_poll_attribute.attr,	
+	&ges_recv_attribute.attr,
+	&ges_send_attribute.attr,
+    NULL
+};
+
+static struct attribute_group stk_ges_attribute_group = 
+{
+	.name = "driver",	
+	.attrs = stk_ges_attrs,
+};
+#endif	/* #ifdef STK_GES */
 /****************************************************************************** 
  * Function Configuration
 ******************************************************************************/
+#ifdef STK_GES		
+static uint32_t stk3x1x_get_ges_value(struct stk3x1x_priv *obj, unsigned int *ges0, unsigned int *ges1, unsigned int *ges2)
+{
+	u8 buf[4];
+	int err, retry = 10;
+	u8 flag;
+
+	do {
+		err = stk3x1x_read_flag(obj->client, &flag);	
+		if(err < 0)
+			return err;
+		if(flag & STK_FLG_PSDR_MASK)
+			break;
+		//APS_LOG( "%s: ps isnot ready\n", __func__);
+		retry--;
+		usleep_range(350, 1000);
+	} while(retry > 0);
+
+	err = stk3x1x_master_recv(obj->client, obj->addr.data1_ps, buf, 0x02);
+	if(err < 0)
+	{
+		APS_DBG("error: %d\n", err);
+		return -EFAULT;
+	}
+
+	err = stk3x1x_master_recv(obj->client, 0x24, buf, 0x04);
+	if(err < 0)
+	{
+		APS_DBG("error: %d\n", err);
+		return -EFAULT;
+	}
+	*ges0 = (buf[0]<<8) | buf[1];	
+	*ges1 = (buf[2]<<8) | buf[3];	
+	//APS_LOG( "%s: ges=%d,%d\n",__func__, *ges0, *ges1);	
+	return 0;
+}
+#endif
+
+
 static int stk3x1x_get_als_value(struct stk3x1x_priv *obj, u16 als)
 {
 	int idx;
@@ -1992,23 +3406,6 @@ static int stk3x1x_get_als_value(struct stk3x1x_priv *obj, u16 als)
 
 	if(!invalid)
 	{
-#if defined(CONFIG_MTK_AAL_SUPPORT)
-		int level_high = obj->hw->als_level[idx];
-		int level_low = (idx > 0) ? obj->hw->als_level[idx-1] : 0;
-		int level_diff = level_high - level_low;
-		int value_high = obj->hw->als_value[idx];
-		int value_low = (idx > 0) ? obj->hw->als_value[idx-1] : 0;
-		int value_diff = value_high - value_low;
-		int value = 0;
-		
-		if ((level_low >= level_high) || (value_low >= value_high))
-			value = value_low;
-		else
-			value = (level_diff * value_low + (als - level_low) * value_diff + ((level_diff + 1) >> 1)) / level_diff;
-		APS_DBG("ALS: %d [%d, %d] => %d [%d, %d] \n", als, level_low, level_high, value, value_low, value_high);
-		return value;
-#endif
-
 		if (atomic_read(&obj->trace) & STK_TRC_CVT_ALS)
 		{
 			APS_DBG("ALS: %05d => %05d\n", als, obj->hw->als_value[idx]);
@@ -2172,7 +3569,7 @@ static int32_t stk3x1x_set_irs_it_slp(struct stk3x1x_priv *obj, uint16_t *slp_ti
 			*slp_time = 96;			
 			break;				
 		default:
-			printk(KERN_ERR "%s: unknown ALS IT=0x%x\n", __func__, irs_alsctrl);
+			APS_ERR( "%s: unknown ALS IT=0x%x\n", __func__, irs_alsctrl);
 			ret = -EINVAL;	
 			return ret;
 	}
@@ -2180,7 +3577,7 @@ static int32_t stk3x1x_set_irs_it_slp(struct stk3x1x_priv *obj, uint16_t *slp_ti
 	ret = i2c_smbus_write_byte_data(obj->client, STK_ALSCTRL_REG, irs_alsctrl);
 	if (ret < 0)
 	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
+		APS_ERR( "%s: write i2c error\n", __func__);
 		return ret;		
 	}		
 	return 0;
@@ -2198,7 +3595,14 @@ static int32_t stk3x1x_get_ir_value(struct stk3x1x_priv *obj)
 	re_enable_ps = (atomic_read(&obj->state_val) & STK_STATE_EN_PS_MASK) ? true : false;	
 	if(re_enable_ps)
 	{
-		stk3x1x_enable_ps(obj->client, 0);
+#ifdef STK_TUNE0		
+		if (!(obj->psi_set))
+		{
+			hrtimer_cancel(&obj->ps_tune0_timer);					
+			cancel_work_sync(&obj->stk_ps_tune0_work);
+		}		
+#endif		
+		stk3x1x_enable_ps(obj->client, 0, 1);
 	}
 	
 	ret = stk3x1x_set_irs_it_slp(obj, &irs_slp_time);
@@ -2209,7 +3613,7 @@ static int32_t stk3x1x_get_ir_value(struct stk3x1x_priv *obj)
     ret = i2c_smbus_write_byte_data(obj->client, STK_STATE_REG, w_reg);
     if (ret < 0)
 	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
+		APS_ERR( "%s: write i2c error\n", __func__);
 		goto irs_err_i2c_rw;
 	}	
 	msleep(irs_slp_time);	
@@ -2228,7 +3632,7 @@ static int32_t stk3x1x_get_ir_value(struct stk3x1x_priv *obj)
 	
 	if(retry == 10)
 	{
-		printk(KERN_ERR "%s: ir data is not ready for 300ms\n", __func__);
+		APS_ERR( "%s: ir data is not ready for 300ms\n", __func__);
 		ret = -EINVAL;
 		goto irs_err_i2c_rw;
 	}
@@ -2236,14 +3640,14 @@ static int32_t stk3x1x_get_ir_value(struct stk3x1x_priv *obj)
 	ret = stk3x1x_clear_intr(obj->client, flag, STK_FLG_IR_RDY_MASK);	
     if (ret < 0)
 	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
+		APS_ERR( "%s: write i2c error\n", __func__);
 		goto irs_err_i2c_rw;
 	}		
 	
 	ret = stk3x1x_master_recv(obj->client, STK_DATA1_IR_REG, buf, 2);
 	if(ret < 0)	
 	{
-		printk(KERN_ERR "%s fail, ret=0x%x", __func__, ret); 
+		APS_ERR( "%s fail, ret=0x%x", __func__, ret); 
 		goto irs_err_i2c_rw;		
 	}
 	word_data =  (buf[0] << 8) | buf[1];
@@ -2251,16 +3655,16 @@ static int32_t stk3x1x_get_ir_value(struct stk3x1x_priv *obj)
 	ret = i2c_smbus_write_byte_data(obj->client, STK_ALSCTRL_REG, atomic_read(&obj->alsctrl_val));
 	if (ret < 0)
 	{
-		printk(KERN_ERR "%s: write i2c error\n", __func__);
+		APS_ERR( "%s: write i2c error\n", __func__);
 		goto irs_err_i2c_rw;
 	}
 	if(re_enable_ps)
-		stk3x1x_enable_ps(obj->client, 1);		
+		stk3x1x_enable_ps(obj->client, 1, 0);		
 	return word_data;
 
 irs_err_i2c_rw:	
 	if(re_enable_ps)
-		stk3x1x_enable_ps(obj->client, 1);	
+		stk3x1x_enable_ps(obj->client, 1, 0);	
 	return ret;
 }
 
@@ -2271,21 +3675,94 @@ static int stk3x1x_open(struct inode *inode, struct file *file)
 {
 	file->private_data = stk3x1x_i2c_client;
 
-	if (!file->private_data)
-	{
-		APS_ERR("null pointer!!\n");
-		return -EINVAL;
+	if (!file->private_data)
+	{
+		APS_ERR("null pointer!!\n");
+		return -EINVAL;
+	}
+	
+	return nonseekable_open(inode, file);
+}
+///*----------------------------------------------------------------------------*/
+static int stk3x1x_release(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+///*----------------------------------------------------------------------------*/
+
+int stk3x1x_ioctl_cmd(struct file *file, unsigned int cmd, unsigned long *arg)      
+{
+	struct i2c_client *client = (struct i2c_client*)file->private_data;
+	struct stk3x1x_priv *obj = i2c_get_clientdata(client);  
+	
+	long err = 0;
+
+	void __user **ptr = (void __user*) arg;
+	int dat;
+	uint32_t enable;
+
+	switch (cmd)
+	{
+
+		case ALSPS_GET_PS_MODE:
+			enable = test_bit(STK_BIT_PS, &obj->enable) ? (1) : (0);
+			if(copy_to_user((*ptr), &enable, sizeof(enable)))
+			{
+				err = -EFAULT;
+				goto err_out;
+			}
+			break;
+
+		case ALSPS_GET_PS_DATA:    
+			if((err = stk3x1x_read_ps(obj->client, &obj->ps)))
+			{
+				goto err_out;
+			}
+			
+			dat = stk3x1x_get_ps_value(obj, obj->ps);
+			if(dat < 0)
+			{
+				err = dat;
+				goto err_out;
+			}
+		
+			if(copy_to_user((*ptr), &dat, sizeof(dat)))
+			{
+				err = -EFAULT;
+				goto err_out;
+			}  
+			break;
+
+		case ALSPS_GET_ALS_MODE:
+			enable = test_bit(STK_BIT_ALS, &obj->enable) ? (1) : (0);
+			if(copy_to_user((*ptr), &enable, sizeof(enable)))
+			{
+				err = -EFAULT;
+				goto err_out;
+			}
+			break;
+
+		case ALSPS_GET_ALS_DATA: 
+			if((err = stk3x1x_read_als(obj->client, &obj->als)))
+			{
+				goto err_out;
+			}
+
+			dat = stk3x1x_get_als_value(obj, obj->als);
+			if(copy_to_user((*ptr), &dat, sizeof(dat)))
+			{
+				err = -EFAULT;
+				goto err_out;
+			}              
+			break;
 	}
 	
-	return nonseekable_open(inode, file);
-}
-/*----------------------------------------------------------------------------*/
-static int stk3x1x_release(struct inode *inode, struct file *file)
-{
-	file->private_data = NULL;
-	return 0;
+err_out:
+	return err;    
 }
-/*----------------------------------------------------------------------------*/
+
+
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,36))	
 static long stk3x1x_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 #else
@@ -2302,9 +3779,6 @@ static int stk3x1x_ioctl(struct inode *inode, struct file *file, unsigned int cm
 	void __user *ptr = (void __user*) arg;
 	int dat;
 	uint32_t enable;
-	int ps_result;
-	int ps_cali;
-	int threshold[2];
 
 	switch (cmd)
 	{
@@ -2316,7 +3790,7 @@ static int stk3x1x_ioctl(struct inode *inode, struct file *file, unsigned int cm
 			}
 			if(enable)
 			{
-				if((err = stk3x1x_enable_ps(obj->client, 1)))
+				if((err = stk3x1x_enable_ps(obj->client, 1, 1)))
 				{
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,36))	
 					APS_ERR("enable ps fail: %ld\n", err); 
@@ -2330,7 +3804,7 @@ static int stk3x1x_ioctl(struct inode *inode, struct file *file, unsigned int cm
 			}
 			else
 			{
-				if((err = stk3x1x_enable_ps(obj->client, 0)))
+				if((err = stk3x1x_enable_ps(obj->client, 0, 1)))
 				{
 #if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,36))	
 					APS_ERR("disable ps fail: %ld\n", err); 
@@ -2462,98 +3936,6 @@ static int stk3x1x_ioctl(struct inode *inode, struct file *file, unsigned int cm
 				goto err_out;
 			}              
 			break;
-			/*----------------------------------for factory mode test---------------------------------------*/
-			case ALSPS_GET_PS_TEST_RESULT:
-				if((err = stk3x1x_read_ps(obj->client, &obj->ps)))
-				{
-					goto err_out;
-				}
-				if(obj->ps > atomic_read(&obj->ps_high_thd_val))
-					{
-						ps_result = 0;
-					}
-				else	ps_result = 1;
-				
-				if(copy_to_user(ptr, &ps_result, sizeof(ps_result)))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}			   
-				break;
-
-			case ALSPS_IOCTL_CLR_CALI:
-				if(copy_from_user(&dat, ptr, sizeof(dat)))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}
-				if(dat == 0)
-					obj->ps_cali = 0;
-				break;
-
-			case ALSPS_IOCTL_GET_CALI:
-				ps_cali = obj->ps_cali ;
-				if(copy_to_user(ptr, &ps_cali, sizeof(ps_cali)))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}
-				break;
-
-			case ALSPS_IOCTL_SET_CALI:
-				if(copy_from_user(&ps_cali, ptr, sizeof(ps_cali)))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}
-
-				obj->ps_cali = ps_cali;
-				break;
-
-			case ALSPS_SET_PS_THRESHOLD:
-				if(copy_from_user(threshold, ptr, sizeof(threshold)))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}
-				APS_ERR("%s set threshold high: 0x%x, low: 0x%x\n", __func__, threshold[0],threshold[1]); 
-				atomic_set(&obj->ps_high_thd_val,  (threshold[0]+obj->ps_cali));
-				atomic_set(&obj->ps_low_thd_val,  (threshold[1]+obj->ps_cali));//need to confirm
-
-				if((err = stk3x1x_write_ps_high_thd(obj->client, atomic_read(&obj->ps_high_thd_val))))
-				{
-					APS_ERR("write high thd error: %ld\n", err);
-					goto err_out;        
-				}
-				
-				if((err = stk3x1x_write_ps_low_thd(obj->client, atomic_read(&obj->ps_low_thd_val))))
-				{
-					APS_ERR("write low thd error: %ld\n", err);
-					goto err_out;       
-				}
-				
-				break;
-				
-			case ALSPS_GET_PS_THRESHOLD_HIGH:
-				threshold[0] = atomic_read(&obj->ps_high_thd_val) - obj->ps_cali;
-				APS_ERR("%s get threshold high: 0x%x\n", __func__, threshold[0]); 
-				if(copy_to_user(ptr, &threshold[0], sizeof(threshold[0])))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}
-				break;
-				
-			case ALSPS_GET_PS_THRESHOLD_LOW:
-				threshold[0] = atomic_read(&obj->ps_low_thd_val) - obj->ps_cali;
-				APS_ERR("%s get threshold low: 0x%x\n", __func__, threshold[0]); 
-				if(copy_to_user(ptr, &threshold[0], sizeof(threshold[0])))
-				{
-					err = -EFAULT;
-					goto err_out;
-				}
-				break;
-			/*------------------------------------------------------------------------------------------*/
 		
 		default:
 			APS_ERR("%s not supported = 0x%04x", __FUNCTION__, cmd);
@@ -2564,7 +3946,7 @@ static int stk3x1x_ioctl(struct inode *inode, struct file *file, unsigned int cm
 	err_out:
 	return err;    
 }
-/*----------------------------------------------------------------------------*/
+///*----------------------------------------------------------------------------*/
 static struct file_operations stk3x1x_fops = {
 #if (LINUX_VERSION_CODE<KERNEL_VERSION(3,0,0))
 	.owner = THIS_MODULE,
@@ -2578,7 +3960,7 @@ static struct file_operations stk3x1x_fops = {
 #endif
 
 };
-/*----------------------------------------------------------------------------*/
+///*----------------------------------------------------------------------------*/
 static struct miscdevice stk3x1x_device = {
 	.minor = MISC_DYNAMIC_MINOR,
 	.name = "als_ps",
@@ -2605,7 +3987,7 @@ static int stk3x1x_i2c_suspend(struct i2c_client *client, pm_message_t msg)
 		}
 
 		atomic_set(&obj->ps_suspend, 1);
-		if((err = stk3x1x_enable_ps(client, 0)))
+		if((err = stk3x1x_enable_ps(client, 0, 1)))
 		{
 			APS_ERR("disable ps:  %d\n", err);
 			return err;
@@ -2645,7 +4027,7 @@ static int stk3x1x_i2c_resume(struct i2c_client *client)
 	atomic_set(&obj->ps_suspend, 0);
 	if(test_bit(STK_BIT_PS,  &obj->enable))
 	{
-		if((err = stk3x1x_enable_ps(client, 1)))
+		if((err = stk3x1x_enable_ps(client, 1, 1)))
 		{
 			APS_ERR("enable ps fail: %d\n", err);                
 		}
@@ -2663,48 +4045,309 @@ static void stk3x1x_early_suspend(struct early_suspend *h)
 
 	if(!obj)
 	{
-		APS_ERR("null pointer!!\n");
-		return;
+		APS_ERR("null pointer!!\n");
+		return;
+	}
+#ifdef STK_CHK_REG		
+	err = stk3x1x_validate_n_handle(obj->client);
+	if(err < 0)	
+	{
+		APS_ERR("stk3x1x_validate_n_handle fail: %d\n", err); 
+	}
+	else if (err == 0xFF)
+	{
+		if(old & STK_STATE_EN_PS_MASK)
+			stk3x1x_enable_ps(obj->client, 1, 0);
+	}
+#endif /* #ifdef STK_CHK_REG	*/	
+
+#ifdef STK_GES	
+	if(obj->ges_enabled == 1)
+	{
+		obj->re_enable_ges = obj->ges_enabled;		
+		stk3x1x_enable_ges(obj->client, 0, 1);	
+	}
+	else if(obj->ges_enabled == 2)
+	{
+		obj->re_enable_ges = obj->ges_enabled;	
+		stk3x1x_enable_ges(obj->client, 0, 2);	
+	}
+#endif
+	if(old & STK_STATE_EN_ALS_MASK)
+	{
+		atomic_set(&obj->als_suspend, 1);    
+		if((err = stk3x1x_enable_als(obj->client, 0)))
+		{
+			APS_ERR("disable als fail: %d\n", err); 
+		}
+		APS_LOG( "%s: Enable ALS : 0\n", __func__);		
+	}
+}
+/*----------------------------------------------------------------------------*/
+static void stk3x1x_late_resume(struct early_suspend *h)
+{   /*early_suspend is only applied for ALS*/
+	int err;
+	struct stk3x1x_priv *obj = container_of(h, struct stk3x1x_priv, early_drv);         	
+	APS_FUN();
+
+	if(!obj)
+	{
+		APS_ERR("null pointer!!\n");
+		return;
+	}
+#ifdef STK_CHK_REG		
+	err = stk3x1x_validate_n_handle(obj->client);
+	if(err < 0)	
+	{
+		APS_ERR("stk3x1x_validate_n_handle fail: %d\n", err); 
+	}
+	else if (err == 0xFF)
+	{
+		if(atomic_read(&obj->state_val) & STK_STATE_EN_PS_MASK)
+			stk3x1x_enable_ps(obj->client, 1, 0);
+	}	
+#endif /* #ifdef STK_CHK_REG	*/	
+	
+#ifdef STK_GES	
+		if(obj->re_enable_ges == 1)
+		{
+			stk3x1x_enable_ges(obj->client, 1, 1);				
+			obj->re_enable_ges = 0;		
+		}
+		else if(obj->re_enable_ges == 2)
+		{
+			stk3x1x_enable_ges(obj->client, 1, 2);				
+			obj->re_enable_ges = 0;				
+		}
+#endif	
+	
+	if(atomic_read(&obj->als_suspend))
+	{
+		atomic_set(&obj->als_suspend, 0);
+		if(test_bit(STK_BIT_ALS, &obj->enable))
+		{
+			APS_LOG( "%s: Enable ALS : 1\n", __func__);		
+			if((err = stk3x1x_enable_als(obj->client, 1)))
+			{
+				APS_ERR("enable als fail: %d\n", err);        
+
+			}
+		}
+	}
+}
+
+static int stk_als_open_report_data(int open)
+{
+	//should queuq work to report event if  is_report_input_direct=true
+	return 0;
+}
+
+static int stk_als_enable_nodata(int value)
+{
+	int res = 0,err;
+	struct stk3x1x_priv *obj = NULL;
+		
+	obj = stk3x1x_obj;	
+	if(value)
+	{
+		if((err = stk3x1x_enable_als(obj->client, 1)))
+		{
+			APS_ERR("enable als fail: %d\n", err); 
+			return -1;
+		}
+		set_bit(STK_BIT_ALS, &obj->enable);
+	}
+	else
+	{
+		if((err = stk3x1x_enable_als(obj->client, 0)))
+		{
+			APS_ERR("disable als fail: %d\n", err); 
+			return -1;
+		}
+		clear_bit(STK_BIT_ALS, &obj->enable);
+	}
+
+	return 0;
+}
+
+
+static int stk_als_set_delay(u64 ns)
+{
+	return 0;
+}
+
+
+static int stk_als_get_data(int* value, int* status)
+{
+	int err = 0;
+	struct stk3x1x_priv *obj = NULL;
+	u8 flag;
+		
+	obj = stk3x1x_obj;
+
+	err = stk3x1x_read_flag(obj->client, &flag);
+	if(err)
+		return err;
+	
+	if(!(flag & STK_FLG_ALSDR_MASK))
+		return -1;				
+	
+//	sensor_data = (hwm_sensor_data *)buff_out;								
+	if((err = stk3x1x_read_als(obj->client, &obj->als)))
+	{
+		err = -1;
+	}
+	else
+	{
+		if(obj->als < 3)
+		{
+			obj->als_last = obj->als;
+			*value = stk3x1x_get_als_value(obj, 0);
+		}
+		else if(abs(obj->als - obj->als_last) >= STK_ALS_CODE_CHANGE_THD)
+		{
+			obj->als_last = obj->als;
+			*value = stk3x1x_get_als_value(obj, obj->als);
+		}
+		else
+		{
+			*value = stk3x1x_get_als_value(obj, obj->als_last);
+		}					
+//		sensor_data->value_divide = 1;
+		*status = SENSOR_STATUS_ACCURACY_MEDIUM;
+	}	
+
+	return err;
+}
+
+
+static int stk_als_get_raw_data(int *als_value)
+{
+	int err = 0;
+	struct stk3x1x_priv *obj = NULL;
+	u8 flag;
+		
+	obj = stk3x1x_obj;
+
+	err = stk3x1x_read_flag(obj->client, &flag);
+	if(err)
+		return err;
+	
+	if(!(flag & STK_FLG_ALSDR_MASK))
+		return -1;				
+	
+//	sensor_data = (hwm_sensor_data *)buff_out;								
+	if((err = stk3x1x_read_als(obj->client, &obj->als)))
+	{
+		err = -1;
+	}
+	else
+	{
+		*als_value=obj->als;
+	}	
+
+	return err;
+}
+
+
+static int stk_ps_open_report_data(int open)
+{
+	//should queuq work to report event if  is_report_input_direct=true
+	return 0;
+}
+
+
+static int stk_ps_enable_nodata(int value)
+{
+	int res = 0,err;
+	struct stk3x1x_priv *obj = NULL;
+		
+	obj = stk3x1x_obj;	
+	
+	if(value)
+	{
+		if((err = stk3x1x_enable_ps(obj->client, 1, 1)))
+		{
+			APS_ERR("enable ps fail: %d\n", err); 
+			return -1;
+		}
+		set_bit(STK_BIT_PS, &obj->enable);
+	}
+	else
+	{
+		if((err = stk3x1x_enable_ps(obj->client, 0, 1)))
+		{
+			APS_ERR("disable ps fail: %d\n", err); 
+			return -1;
+		}
+		clear_bit(STK_BIT_PS, &obj->enable);
+	}
+
+	return 0;
+}
+
+static int stk_ps_set_delay(u64 ns)
+{
+	return 0;
+}
+
+
+static int stk_ps_get_data(int* value, int* status)
+{
+	int err = 0,data;
+	struct stk3x1x_priv *obj = NULL;
+	
+//	sensor_data = (hwm_sensor_data *)buff_out;				
+	obj = stk3x1x_obj;
+
+	if((err = stk3x1x_read_ps(obj->client, &obj->ps)))
+	{
+		err = -1;
 	}
-	
-	if(old & STK_STATE_EN_ALS_MASK)
+	else
 	{
-		atomic_set(&obj->als_suspend, 1);    
-		if((err = stk3x1x_enable_als(obj->client, 0)))
+		data = stk3x1x_get_ps_value(obj, obj->ps);
+		if(data < 0)
 		{
-			APS_ERR("disable als fail: %d\n", err); 
+			err = -1;
 		}
-	}
+		else
+		{
+			*value = data;
+//			sensor_data->value_divide = 1;
+			*status = SENSOR_STATUS_ACCURACY_MEDIUM;
+//#ifdef STK_PS_POLLING_LOG						
+////			APS_LOG("%s:ps raw 0x%x -> value 0x%x \n",__FUNCTION__, obj->ps, sensor_data->values[0]);					
+//#endif				
+		}	
+	}	
+
+	return err;
 }
-/*----------------------------------------------------------------------------*/
-static void stk3x1x_late_resume(struct early_suspend *h)
-{   /*early_suspend is only applied for ALS*/
-	int err;
-	hwm_sensor_data sensor_data;
-	struct stk3x1x_priv *obj = container_of(h, struct stk3x1x_priv, early_drv);         
+
+static int stk_ps_get_raw_data(int *ps_value)
+{
+	int err = 0,data;
+	struct stk3x1x_priv *obj = NULL;
 	
-	memset(&sensor_data, 0, sizeof(sensor_data));
-	APS_FUN();
+//	sensor_data = (hwm_sensor_data *)buff_out;				
+	obj = stk3x1x_obj;
 
-	if(!obj)
+	if((err = stk3x1x_read_ps(obj->client, &obj->ps)))
 	{
-		APS_ERR("null pointer!!\n");
-		return;
+		err = -1;
 	}
-	if(atomic_read(&obj->als_suspend))
+	else
 	{
-		atomic_set(&obj->als_suspend, 0);
-		if(test_bit(STK_BIT_ALS, &obj->enable))
-		{
-			if((err = stk3x1x_enable_als(obj->client, 1)))
-			{
-				APS_ERR("enable als fail: %d\n", err);        
+		*ps_value = obj->ps;;
+		
+	}	
 
-			}
-		}
-	}
+	return err;
 }
 
+
+
 int stk3x1x_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
 		void* buff_out, int size_out, int* actualout)
 {
@@ -2736,7 +4379,7 @@ int stk3x1x_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
 				value = *(int *)buff_in;
 				if(value)
 				{
-					if((err = stk3x1x_enable_ps(obj->client, 1)))
+					if((err = stk3x1x_enable_ps(obj->client, 1, 1)))
 					{
 						APS_ERR("enable ps fail: %d\n", err); 
 						return -1;
@@ -2745,7 +4388,7 @@ int stk3x1x_ps_operate(void* self, uint32_t command, void* buff_in, int size_in,
 				}
 				else
 				{
-					if((err = stk3x1x_enable_ps(obj->client, 0)))
+					if((err = stk3x1x_enable_ps(obj->client, 0, 1)))
 					{
 						APS_ERR("disable ps fail: %d\n", err); 
 						return -1;
@@ -2835,7 +4478,6 @@ int stk3x1x_als_operate(void* self, uint32_t command, void* buff_in, int size_in
 						return -1;
 					}
 					set_bit(STK_BIT_ALS, &obj->enable);
-                	//mt_eint_mask(CUST_EINT_ALS_NUM);
 				}
 				else
 				{
@@ -2845,7 +4487,6 @@ int stk3x1x_als_operate(void* self, uint32_t command, void* buff_in, int size_in
 						return -1;
 					}
 					clear_bit(STK_BIT_ALS, &obj->enable);
-					//mt_eint_unmask(CUST_EINT_ALS_NUM);
 				}
 				
 			}
@@ -2859,6 +4500,15 @@ int stk3x1x_als_operate(void* self, uint32_t command, void* buff_in, int size_in
 			}
 			else
 			{				
+#ifdef STK_GES			
+				if(obj->ges_enabled)
+				{
+					sensor_data->values[0] = stk3x1x_get_als_value(obj, obj->als_last);				
+					sensor_data->value_divide = 1;
+					sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;				
+					break;
+				}
+#endif							
 				err = stk3x1x_read_flag(obj->client, &flag);
 				if(err)
 					return err;
@@ -2873,7 +4523,20 @@ int stk3x1x_als_operate(void* self, uint32_t command, void* buff_in, int size_in
 				}
 				else
 				{
-					sensor_data->values[0] = stk3x1x_get_als_value(obj, obj->als);
+					if(obj->als < 3)
+					{
+						obj->als_last = obj->als;
+						sensor_data->values[0] = stk3x1x_get_als_value(obj, 0);
+					}
+					else if(abs(obj->als - obj->als_last) >= STK_ALS_CODE_CHANGE_THD)
+					{
+						obj->als_last = obj->als;
+						sensor_data->values[0] = stk3x1x_get_als_value(obj, obj->als);
+					}
+					else
+					{
+						sensor_data->values[0] = stk3x1x_get_als_value(obj, obj->als_last);
+					}					
 					sensor_data->value_divide = 1;
 					sensor_data->status = SENSOR_STATUS_ACCURACY_MEDIUM;
 				}				
@@ -2888,196 +4551,6 @@ int stk3x1x_als_operate(void* self, uint32_t command, void* buff_in, int size_in
 	return err;
 }
 
-static int als_open_report_data(int open)
-{
-	//should queuq work to report event if  is_report_input_direct=true
-	return 0;
-}
-
-// if use  this typ of enable , Gsensor only enabled but not report inputEvent to HAL
-
-static int als_enable_nodata(int en)
-{
-	int res = 0;
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    SCP_SENSOR_HUB_DATA req;
-    int len;
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-
-    APS_LOG("stk3x1x_obj als enable value = %d\n", en);
-
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    req.activate_req.sensorType = ID_LIGHT;
-    req.activate_req.action = SENSOR_HUB_ACTIVATE;
-    req.activate_req.enable = en;
-    len = sizeof(req.activate_req);
-    res = SCP_sensorHub_req_send(&req, &len, 1);
-#else //#ifdef CUSTOM_KERNEL_SENSORHUB
-	if(!stk3x1x_obj)
-	{
-		APS_ERR("stk3x1x_obj is null!!\n");
-		return -1;
-	}
-	res=	stk3x1x_enable_als(stk3x1x_obj->client, en);
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-	if(res){
-		APS_ERR("als_enable_nodata is failed!!\n");
-		return -1;
-	}
-	return 0;
-}
-
-static int als_set_delay(u64 ns)
-{
-	return 0;
-}
-
-static int als_get_data(int* value, int* status)
-{
-	int err = 0;
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    SCP_SENSOR_HUB_DATA req;
-    int len;
-#else
-    struct stk3x1x_priv *obj = NULL;
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    req.get_data_req.sensorType = ID_LIGHT;
-    req.get_data_req.action = SENSOR_HUB_GET_DATA;
-    len = sizeof(req.get_data_req);
-    err = SCP_sensorHub_req_send(&req, &len, 1);
-    if (err)
-    {
-        APS_ERR("SCP_sensorHub_req_send fail!\n");
-    }
-    else
-    {
-        *value = req.get_data_rsp.int16_Data[0];
-        *status = SENSOR_STATUS_ACCURACY_MEDIUM;
-    }
-
-    if(atomic_read(&stk3x1x_obj->trace) & CMC_TRC_PS_DATA)
-	{
-        APS_LOG("value = %d\n", *value);
-        //show data
-	}
-#else //#ifdef CUSTOM_KERNEL_SENSORHUB
-	if(!stk3x1x_obj)
-	{
-		APS_ERR("stk3x1x_obj is null!!\n");
-		return -1;
-	}
-	obj = stk3x1x_obj;
-	if((err = stk3x1x_read_als(obj->client, &obj->als)))
-	{
-		err = -1;
-	}
-	else
-	{
-		*value = stk3x1x_get_als_value(obj, obj->als);
-		*status = SENSOR_STATUS_ACCURACY_MEDIUM;
-	}
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-
-	return err;
-}
-
-static int ps_open_report_data(int open)
-{
-	//should queuq work to report event if  is_report_input_direct=true
-	return 0;
-}
-
-// if use  this typ of enable , Gsensor only enabled but not report inputEvent to HAL
-
-static int ps_enable_nodata(int en)
-{
-	int res = 0;
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    SCP_SENSOR_HUB_DATA req;
-    int len;
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-
-    APS_LOG("stk3x1x_obj als enable value = %d\n", en);
-
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    req.activate_req.sensorType = ID_PROXIMITY;
-    req.activate_req.action = SENSOR_HUB_ACTIVATE;
-    req.activate_req.enable = en;
-    len = sizeof(req.activate_req);
-    res = SCP_sensorHub_req_send(&req, &len, 1);
-#else //#ifdef CUSTOM_KERNEL_SENSORHUB
-	if(!stk3x1x_obj)
-	{
-		APS_ERR("stk3x1x_obj is null!!\n");
-		return -1;
-	}
-	res=	stk3x1x_enable_ps(stk3x1x_obj->client, en);
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-    
-	if(res){
-		APS_ERR("als_enable_nodata is failed!!\n");
-		return -1;
-	}
-	return 0;
-
-}
-
-static int ps_set_delay(u64 ns)
-{
-	return 0;
-}
-
-static int ps_get_data(int* value, int* status)
-{
-    int err = 0;
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    SCP_SENSOR_HUB_DATA req;
-    int len;
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-
-#ifdef CUSTOM_KERNEL_SENSORHUB
-    req.get_data_req.sensorType = ID_PROXIMITY;
-    req.get_data_req.action = SENSOR_HUB_GET_DATA;
-    len = sizeof(req.get_data_req);
-    err = SCP_sensorHub_req_send(&req, &len, 1);
-    if (err)
-    {
-        APS_ERR("SCP_sensorHub_req_send fail!\n");
-    }
-    else
-    {
-        *value = req.get_data_rsp.int16_Data[0];
-        *status = SENSOR_STATUS_ACCURACY_MEDIUM;
-    }
-
-    if(atomic_read(&stk3x1x_obj->trace) & CMC_TRC_PS_DATA)
-	{
-        APS_LOG("value = %d\n", *value);
-        //show data
-	}
-#else //#ifdef CUSTOM_KERNEL_SENSORHUB
-    if(!stk3x1x_obj)
-	{
-		APS_ERR("stk3x1x_obj is null!!\n");
-		return -1;
-	}
-    
-    if((err = stk3x1x_read_ps(stk3x1x_obj->client, &stk3x1x_obj->ps)))
-    {
-        err = -1;;
-    }
-    else
-    {
-        *value = stk3x1x_get_ps_value(stk3x1x_obj, stk3x1x_obj->ps);
-        *status = SENSOR_STATUS_ACCURACY_MEDIUM;
-    }
-#endif //#ifdef CUSTOM_KERNEL_SENSORHUB
-    
-	return 0;
-}
-
 
 /*----------------------------------------------------------------------------*/
 #if (LINUX_VERSION_CODE<KERNEL_VERSION(3,0,0))	
@@ -3088,24 +4561,73 @@ static int stk3x1x_i2c_detect(struct i2c_client *client, int kind, struct i2c_bo
 }
 #endif
 /*----------------------------------------------------------------------------*/
+#ifdef STK_GES
+static int stk3x1x_set_input_device(struct stk3x1x_priv *obj)
+{
+	int err;
+	
+	obj->ges_input_dev = input_allocate_device();
+	if (obj->ges_input_dev==NULL)
+	{
+		APS_ERR( "%s: could not allocate ps device\n", __func__);		
+		err = -ENOMEM;
+		return err;		
+	}
+	obj->ges_input_dev->name = "stk_ges";
+	obj->ges_input_dev->evbit[0] = BIT_MASK(EV_KEY);
+	set_bit(KEY_PAGEUP, obj->ges_input_dev->keybit);
+	set_bit(KEY_PAGEDOWN, obj->ges_input_dev->keybit);
+	set_bit(KEY_UP, obj->ges_input_dev->keybit);
+	set_bit(KEY_DOWN, obj->ges_input_dev->keybit);
+	set_bit(KEY_F2, obj->ges_input_dev->keybit);
+	set_bit(KEY_F3, obj->ges_input_dev->keybit);	
+	/*
+		set_bit(KEY_LEFT, obj->ges_input_dev->keybit);
+		set_bit(KEY_RIGHT, obj->ges_input_dev->keybit);
+		set_bit(KEY_UP, obj->ges_input_dev->keybit);
+		set_bit(KEY_DOWN, obj->ges_input_dev->keybit);
+	 */	
+	err = input_register_device(obj->ges_input_dev);	
+	if (err<0)
+	{
+		APS_ERR( "%s: can not register ps input device\n", __func__);	
+		return err;
+	}
+	
+	err = sysfs_create_group(&obj->ges_input_dev->dev.kobj, &stk_ges_attribute_group);
+	if (err < 0) 
+	{
+		APS_ERR( "%s:could not create sysfs group for ps\n", __func__);
+		return err;
+	}	
+	input_set_drvdata(obj->ges_input_dev, obj);	
+	return 0;
+}
+#endif	
+	
+/*----------------------------------------------------------------------------*/
 static int stk3x1x_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
-	int err = 0;
 	struct stk3x1x_priv *obj;
+	struct hwmsen_object obj_ps, obj_als;
+	int err = 0;
+
 	struct als_control_path als_ctl={0};
 	struct als_data_path als_data={0};
 	struct ps_control_path ps_ctl={0};
 	struct ps_data_path ps_data={0};
 
+
 	APS_LOG("%s: driver version: %s\n", __FUNCTION__, DRIVER_VERSION);
+
 	if(!(obj = kzalloc(sizeof(*obj), GFP_KERNEL)))
 	{
 		err = -ENOMEM;
 		goto exit;
 	}
-
+	memset(obj, 0, sizeof(*obj));
 	stk3x1x_obj = obj;
-	obj->hw = get_cust_alsps_hw();
+	obj->hw = stx3x1x_get_cust_alsps_hw();
 	stk3x1x_get_addr(obj->hw, &obj->addr);
 
 	INIT_DELAYED_WORK(&obj->eint_work, stk3x1x_eint_work);
@@ -3114,28 +4636,27 @@ static int stk3x1x_i2c_probe(struct i2c_client *client, const struct i2c_device_
 	atomic_set(&obj->als_debounce, 200);
 	atomic_set(&obj->als_deb_on, 0);
 	atomic_set(&obj->als_deb_end, 0);
-	atomic_set(&obj->ps_debounce, 100);
+	atomic_set(&obj->ps_debounce, 10);
 	atomic_set(&obj->ps_deb_on, 0);
 	atomic_set(&obj->ps_deb_end, 0);
 	atomic_set(&obj->ps_mask, 0);
 	atomic_set(&obj->trace, 0x00);
 	atomic_set(&obj->als_suspend, 0);
 
-	atomic_set(&obj->state_val, 0x0);
-	atomic_set(&obj->psctrl_val, PSCTRL_VAL);
-	atomic_set(&obj->alsctrl_val, ALSCTRL_VAL);
-	obj->ledctrl_val = LEDCTRL_VAL;
-	obj->wait_val = WAIT_VAL;
+	atomic_set(&obj->state_val, obj->hw->state_val);
+	atomic_set(&obj->psctrl_val, obj->hw->psctrl_val);
+	atomic_set(&obj->alsctrl_val, obj->hw->alsctrl_val);
+	obj->ledctrl_val = obj->hw->ledctrl_val;
+	obj->wait_val = obj->hw->wait_val;
 	obj->int_val = 0;
 	obj->first_boot = true;			 
 	obj->als_correct_factor = 1000;
-	obj->ps_cali = 0;
-
-	atomic_set(&obj->ps_high_thd_val, obj->hw->ps_threshold_high ); 
-	atomic_set(&obj->ps_low_thd_val, obj->hw->ps_threshold_low ); 
-
+	atomic_set(&obj->ps_high_thd_val, obj->hw->ps_high_thd_val);
+	atomic_set(&obj->ps_low_thd_val, obj->hw->ps_low_thd_val);	
 	atomic_set(&obj->recv_reg, 0);  
-	
+#ifdef STK_ALS_FIR	
+	atomic_set(&obj->firlength, STK_FIR_LEN);	
+#endif	
 	if(obj->hw->polling_mode_ps == 0)
 	{
 		APS_LOG("%s: enable PS interrupt\n", __FUNCTION__);
@@ -3174,19 +4695,31 @@ static int stk3x1x_i2c_probe(struct i2c_client *client, const struct i2c_device_
 	
 	stk3x1x_i2c_client = client;
 
+
+	APS_LOG("stk3x1x_i2c_probe() OK 11 !\n");
+
+	obj->stk_ps_tune0_wq = create_singlethread_workqueue("stk_ps_tune0_wq");
+	INIT_WORK(&obj->stk_ps_tune0_work, stk_ps_tune0_work_func);
+	hrtimer_init(&obj->ps_tune0_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+#ifdef STK_TUNE0
+	obj->ps_tune0_delay = ns_to_ktime(60 * NSEC_PER_MSEC);
+	obj->ps_tune0_timer.function = stk_ps_tune0_timer_func;
+#endif		
 	if((err = stk3x1x_init_client(client)))
 	{
 		goto exit_init_failed;
 	}
+
+
+
 	
 	if((err = misc_register(&stk3x1x_device)))
 	{
 		APS_ERR("stk3x1x_device register failed\n");
 		goto exit_misc_device_register_failed;
 	}
-    als_ctl.is_use_common_factory =false;
-	ps_ctl.is_use_common_factory = false;
 
+//	if((err = stk3x1x_create_attr(&stk3x1x_alsps_driver.driver)))
 	if((err = stk3x1x_create_attr(&(stk3x1x_init_info.platform_diver_addr->driver))))
 	{
 		APS_ERR("create attribute err = %d\n", err);
@@ -3194,72 +4727,100 @@ static int stk3x1x_i2c_probe(struct i2c_client *client, const struct i2c_device_
 	}
 
 
-
-	als_ctl.open_report_data= als_open_report_data;
-	als_ctl.enable_nodata = als_enable_nodata;
-	als_ctl.set_delay  = als_set_delay;
-	als_ctl.is_report_input_direct = false;
+		als_ctl.open_report_data= stk_als_open_report_data;
+		als_ctl.enable_nodata = stk_als_enable_nodata;
+		als_ctl.set_delay  = stk_als_set_delay;
+		als_ctl.is_report_input_direct = false;
+//		als_ctl.is_support_batch = obj->hw->is_batch_supported_als;
 #ifdef CUSTOM_KERNEL_SENSORHUB
-	als_ctl.is_support_batch = obj->hw->is_batch_supported_als;
+		als_ctl.is_support_batch = true;
 #else
-    als_ctl.is_support_batch = false;
-#endif
+	    als_ctl.is_support_batch = false;
+#endif			
+		err = als_register_control_path(&als_ctl);
+		if(err)
+		{
+			APS_ERR("register fail = %d\n", err);
+			goto exit_create_attr_failed;
+		}
 	
-	err = als_register_control_path(&als_ctl);
-	if(err)
-	{
-		APS_ERR("register fail = %d\n", err);
-		goto exit_sensor_obj_attach_fail;
-	}
-
-	als_data.get_data = als_get_data;
-	als_data.vender_div = 100;
-	err = als_register_data_path(&als_data);	
-	if(err)
-	{
-		APS_ERR("tregister fail = %d\n", err);
-		goto exit_sensor_obj_attach_fail;
-	}
-
+		als_data.get_data = stk_als_get_data;
+		als_data.als_get_raw_data = stk_als_get_raw_data;
+		als_data.vender_div = 1;
+		err = als_register_data_path(&als_data);	
+		if(err)
+		{
+			APS_ERR("tregister fail = %d\n", err);
+			goto exit_create_attr_failed;
+		}
 	
-	ps_ctl.open_report_data= ps_open_report_data;
-	ps_ctl.enable_nodata = ps_enable_nodata;
-	ps_ctl.set_delay  = ps_set_delay;
-	ps_ctl.is_report_input_direct = true;
+		
+		ps_ctl.open_report_data= stk_ps_open_report_data;
+		ps_ctl.enable_nodata = stk_ps_enable_nodata;
+		ps_ctl.set_delay  = stk_ps_set_delay;
+		ps_ctl.is_report_input_direct = false;
+//		ps_ctl.is_support_batch = obj->hw->is_batch_supported_ps;
 #ifdef CUSTOM_KERNEL_SENSORHUB
-	ps_ctl.is_support_batch = obj->hw->is_batch_supported_ps;
+		ps_ctl.is_support_batch = true;
 #else
-    ps_ctl.is_support_batch = false;
-#endif
+	    ps_ctl.is_support_batch = false;
+#endif	
+		err = ps_register_control_path(&ps_ctl);
+		if(err)
+		{
+			APS_ERR("register fail = %d\n", err);
+			goto exit_create_attr_failed;
+		}
 	
-	err = ps_register_control_path(&ps_ctl);
-	if(err)
-	{
-		APS_ERR("register fail = %d\n", err);
-		goto exit_sensor_obj_attach_fail;
-	}
+		ps_data.get_data = stk_ps_get_data;
+		ps_data.ps_get_raw_data = stk_ps_get_raw_data;
+		ps_data.vender_div = 1;
+		err = ps_register_data_path(&ps_data);	
+		if(err)
+		{
+			APS_ERR("tregister fail = %d\n", err);
+			goto exit_create_attr_failed;
+		}
 
-	ps_data.get_data = ps_get_data;
-	ps_data.vender_div = 100;
-	err = ps_register_data_path(&ps_data);	
-	if(err)
+
+//	obj_ps.self = stk3x1x_obj;
+	if(1 == obj->hw->polling_mode_ps)
 	{
-		APS_ERR("tregister fail = %d\n", err);
-		goto exit_sensor_obj_attach_fail;
+		obj_ps.polling = 1;
+		wake_lock_init(&ps_lock,WAKE_LOCK_SUSPEND,"ps wakelock");
 	}
-
-	err = batch_register_support_info(ID_LIGHT,als_ctl.is_support_batch, 100, 0);
-	if(err)
+	else
 	{
-		APS_ERR("register light batch support err = %d\n", err);
+	  obj_ps.polling = 0;//PS interrupt mode
 	}
 	
-	err = batch_register_support_info(ID_PROXIMITY,ps_ctl.is_support_batch, 100, 0);
-	if(err)
+//	obj_ps.sensor_operate = stk3x1x_ps_operate;
+//	if((err = hwmsen_attach(ID_PROXIMITY, &obj_ps)))
+//	{
+//		APS_ERR("attach fail = %d\n", err);
+//		goto exit_create_attr_failed;
+//	}
+	
+//	obj_als.self = stk3x1x_obj;
+	if(1 == obj->hw->polling_mode_als)
 	{
-		APS_ERR("register proximity batch support err = %d\n", err);
+	  obj_als.polling = 1;
 	}
-
+	else
+	{
+	  obj_als.polling = 0;//ALS interrupt mode
+	}
+//	obj_als.sensor_operate = stk3x1x_als_operate;
+//	if((err = hwmsen_attach(ID_LIGHT, &obj_als)))
+//	{
+//		APS_ERR("attach fail = %d\n", err);
+//		goto exit_create_attr_failed;
+//	}
+#ifdef STK_GES
+	err = stk3x1x_set_input_device(obj);
+	if(err < 0)
+		goto exit_set_input_failed;
+#endif
 
 #if defined(CONFIG_HAS_EARLYSUSPEND)
 	obj->early_drv.level    = EARLY_SUSPEND_LEVEL_DISABLE_FB - 1,
@@ -3268,37 +4829,52 @@ static int stk3x1x_i2c_probe(struct i2c_client *client, const struct i2c_device_
 	register_early_suspend(&obj->early_drv);
 #endif
 
-    stk3x1x_init_flag = 0;
 	APS_LOG("%s: OK\n", __FUNCTION__);
+
 	return 0;
 	
-    exit_sensor_obj_attach_fail:
+#ifdef STK_GES	
+	exit_set_input_failed:
+	input_unregister_device(obj->ges_input_dev);	
+	input_free_device(obj->ges_input_dev);		
+#endif	
 	exit_create_attr_failed:
 	misc_deregister(&stk3x1x_device);
 	exit_misc_device_register_failed:
 	exit_init_failed:
+	//i2c_detach_client(client);
+//	exit_kfree:
 	kfree(obj);
-	obj = NULL;
 	exit:
-	stk3x1x_i2c_client = NULL;
-	stk3x1x_init_flag = -1;
+	stk3x1x_i2c_client = NULL;           
+//	#ifdef MT6516        
+//	MT6516_EINTIRQMask(CUST_EINT_ALS_NUM);  /*mask interrupt if fail*/
+//	#endif
+	mt_eint_mask(CUST_EINT_ALS_NUM); 
 	APS_ERR("%s: err = %d\n", __FUNCTION__, err);
 	return err;
 }
-
+/*----------------------------------------------------------------------------*/
 static int stk3x1x_i2c_remove(struct i2c_client *client)
 {
 	int err;	
-	
-	if((err = stk3x1x_delete_attr(&(stk3x1x_init_info.platform_diver_addr->driver))))
-	{
-		APS_ERR("stk3x1x_delete_attr fail: %d\n", err);
-	} 
-
-	if((err = misc_deregister(&stk3x1x_device)))
-	{
-		APS_ERR("misc_deregister fail: %d\n", err);    
-	}
+#ifdef STK_TUNE0
+	struct stk3x1x_priv *obj = i2c_get_clientdata(client);		
+	destroy_workqueue(obj->stk_ps_tune0_wq);	
+#endif		
+#ifdef STK_GES		
+	input_unregister_device(obj->ges_input_dev);	
+	input_free_device(obj->ges_input_dev);		
+#endif	
+//	if((err = stk3x1x_delete_attr(&stk3x1x_i2c_driver.driver)))
+//	{
+//		APS_ERR("stk3x1x_delete_attr fail: %d\n", err);
+//	} 
+
+//	if((err = misc_deregister(&stk3x1x_device)))
+//	{
+//		APS_ERR("misc_deregister fail: %d\n", err);    
+//	}
 	
 	stk3x1x_i2c_client = NULL;
 	i2c_unregister_device(client);
@@ -3307,9 +4883,9 @@ static int stk3x1x_i2c_remove(struct i2c_client *client)
 	return 0;
 }
 /*----------------------------------------------------------------------------*/
-static int stk3x1x_local_init(void) 
+static int stk3x1x_probe(struct platform_device *pdev) 
 {
-	struct alsps_hw *hw = get_cust_alsps_hw();
+	struct alsps_hw *hw = stx3x1x_get_cust_alsps_hw();
 	struct stk3x1x_i2c_addr addr;
 
 	stk3x1x_power(hw, 1);    
@@ -3323,37 +4899,82 @@ static int stk3x1x_local_init(void)
 		APS_ERR("add driver error\n");
 		return -1;
 	} 
-	if(-1 == stk3x1x_init_flag)
+
+	return 0;
+}
+static int  stk3x1x_local_init(void)
+{
+	struct  alsps_hw *hw = stx3x1x_get_cust_alsps_hw();
+	stk3x1x_power(hw, 1); 
+	APS_ERR("stk3310_local_init...\n");
+	if(i2c_add_driver(&stk3x1x_i2c_driver))
 	{
-	   return -1;
+		APS_ERR("add driver error\n");
+		return -1;
+	} 
+	if(-1 == stk3310_init_flag)		
+	{	   		
+		return -1;		
 	}
-	
 	return 0;
 }
-
-static int stk3x1x_local_uninit(void)
+static int stk3x1x_remove(void)
 {
-	struct alsps_hw *hw = get_cust_alsps_hw();
+	struct alsps_hw *hw = stx3x1x_get_cust_alsps_hw();
 	APS_FUN();    
 	stk3x1x_power(hw, 0);    
 	i2c_del_driver(&stk3x1x_i2c_driver);
 	return 0;
 }
-
-
+#if 0
+/*----------------------------------------------------------------------------*/
+static int stk3x1x_remove(struct platform_device *pdev)
+{
+	struct alsps_hw *hw = stx3x1x_get_cust_alsps_hw();
+	APS_FUN();    
+	stk3x1x_power(hw, 0);    
+	i2c_del_driver(&stk3x1x_i2c_driver);
+	return 0;
+}
+/*----------------------------------------------------------------------------*/
+static struct platform_driver stk3x1x_alsps_driver = {
+	.probe      = stk3x1x_probe,
+	.remove     = stk3x1x_remove,    
+	.driver     = {
+		.name  = "als_ps",
+#if (LINUX_VERSION_CODE<KERNEL_VERSION(3,0,0))	
+		.owner = THIS_MODULE,
+#endif
+	}
+};
+#endif
 /*----------------------------------------------------------------------------*/
 static int __init stk3x1x_init(void)
 {
-	struct alsps_hw *hw = get_cust_alsps_hw();
+//#if (LINUX_VERSION_CODE>=KERNEL_VERSION(3,0,0))	
+	struct alsps_hw *hw = stx3x1x_get_cust_alsps_hw();
 	APS_LOG("%s: i2c_number=%d\n", __func__,hw->i2c_num); 
 	i2c_register_board_info(hw->i2c_num, &i2c_stk3x1x, 1);	
-	alsps_driver_add(&stk3x1x_init_info);
+//#endif
+	APS_FUN();
+      #if 0
+	if(platform_driver_register(&stk3x1x_alsps_driver))
+	{
+		APS_ERR("failed to register driver");
+		return -ENODEV;
+	}
+	#else
+      	alsps_driver_add(&stk3x1x_init_info);
+	#endif
 	return 0;
 }
-
+/*----------------------------------------------------------------------------*/
 static void __exit stk3x1x_exit(void)
 {
 	APS_FUN();
+	#if 0
+	platform_driver_unregister(&stk3x1x_alsps_driver);
+	#endif
 }
 /*----------------------------------------------------------------------------*/
 module_init(stk3x1x_init);
@@ -3362,3 +4983,4 @@ module_exit(stk3x1x_exit);
 MODULE_AUTHOR("MingHsien Hsieh");
 MODULE_DESCRIPTION("SensorTek stk3x1x proximity and light sensor driver");
 MODULE_LICENSE("GPL");
+
diff --git a/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x.h b/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x.h
index 9181afd..8468289 100644
--- a/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x.h
+++ b/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x.h
@@ -45,6 +45,9 @@
 #define STK_PDT_ID_REG 			0x3E
 #define STK_RSRVD_REG 			0x3F
 #define STK_SW_RESET_REG		0x80
+	
+#define STK_GSCTRL_REG			0x1A
+#define STK_FLAG2_REG			0x1C	
 
 /* Define state reg */
 #define STK_STATE_EN_IRS_SHIFT  	7
@@ -120,10 +123,20 @@
 #define STK_FLG_IR_RDY_MASK		0x02
 #define STK_FLG_NF_MASK			0x01
 
+/* Define flag2 reg */
+#define STK_FLG2_INT_GS_SHIFT		6
+#define STK_FLG2_GS10_SHIFT		5
+#define STK_FLG2_GS01_SHIFT		4
+
+#define STK_FLG2_INT_GS_MASK	0x40
+#define STK_FLG2_GS10_MASK		0x20
+#define STK_FLG2_GS01_MASK		0x10
+
 /* misc define */
 #define ALS_MIN_DELAY   100
 #define PS_MIN_DELAY    10
 
-#define STK_ALS_CODE_CHANGE_THD	5
+#define STK_ALS_CODE_CHANGE_THD	20
 
 #endif
+
diff --git a/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x_cust_alsps.c b/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x_cust_alsps.c
new file mode 100644
index 0000000..9bf1066
--- /dev/null
+++ b/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x_cust_alsps.c
@@ -0,0 +1,91 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+#include <linux/types.h>
+#include "stk3x1x_cust_alsps.h"
+#include <mach/mt_pm_ldo.h>
+
+//#ifdef MT6573
+//#include <mach/mt6573_pll.h>
+//#endif
+//#ifdef MT6575
+//#include <mach/mt6575_pm_ldo.h>
+//#endif
+//#ifdef MT6577
+//#include <mach/mt6577_pm_ldo.h>
+//#endif
+//#ifdef MT6589
+//#include <mach/mt_pm_ldo.h>
+//#endif
+//#ifdef MT6572
+//#include <mach/mt_pm_ldo.h>
+//#endif
+//#ifdef MT6582
+//#include <mach/mt_pm_ldo.h>
+//#endif
+
+static struct alsps_hw cust_alsps_hw = {
+	/* i2c bus number, for mt657x, default=0. For mt6589, default=3 */
+//#ifdef MT6589	
+//    .i2c_num    = 3,
+//#elif defined(MT6572)	
+//    .i2c_num    = 1,
+//#elif defined(MT6582)
+//    .i2c_num    = 2,	
+//#else	
+//    .i2c_num    = 0,	
+//#endif	
+	.i2c_num    = 2,	
+	.polling_mode_ps =0,
+	.polling_mode_als = 1,
+    .power_id   = MT65XX_POWER_NONE,    /*LDO is not used*/
+    .power_vol  = VOL_DEFAULT,          /*LDO is not used*/
+    .i2c_addr   = {0x90, 0x00, 0x00, 0x00},	/*STK3x1x*/
+    //.als_level  = {5,  9, 36, 59, 80, 120, 180, 260, 450, 845, 1136, 1545, 2364, 4655, 6982},	/* als_code */
+    .als_level  = {15,  27, 108, 177, 240, 360, 540, 780, 1350, 2535, 3408, 4635, 7092, 13965, 20946},	/* als_code */
+	  //.als_level  = {6, 12, 56, 78, 108, 174, 270, 360, 660, 1116, 1500, 2040, 3120, 6144, 9216},	/* als_code */
+    .als_value  = {0, 50, 130, 130, 200, 250, 380, 550, 760, 1250, 1700, 2300, 4000, 5120, 7000, 10240},    /* lux */
+   	.state_val = 0x0,		/* disable all */
+	.psctrl_val = 0x31,		/* ps_persistance=4, ps_gain=64X, PS_IT=0.391ms */
+	.alsctrl_val = 0x39, 	/* als_persistance=1, als_gain=64X, ALS_IT=50ms */
+	.ledctrl_val = 0xBF,	/* 100mA IRDR, 64/64 LED duty */
+	.wait_val = 0x7,		/* 50 ms */
+    .ps_high_thd_val = 1700,
+    .ps_low_thd_val = 1500,
+};
+struct alsps_hw *stx3x1x_get_cust_alsps_hw(void) {
+    return &cust_alsps_hw;
+}
+
diff --git a/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x_cust_alsps.h b/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x_cust_alsps.h
new file mode 100644
index 0000000..251a08b
--- /dev/null
+++ b/drivers/misc/mediatek/alsps/stk3x1x-new/stk3x1x_cust_alsps.h
@@ -0,0 +1,65 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef __CUST_ALSPS_H__
+#define __CUST_ALSPS_H__
+
+#define C_CUST_ALS_LEVEL    16
+#define C_CUST_I2C_ADDR_NUM 1
+
+struct alsps_hw {
+    int i2c_num;                                    /*!< the i2c bus used by ALS/PS */
+    int power_id;                                   /*!< the power id of the chip */
+    int power_vol;                                  /*!< the power voltage of the chip */
+	//int polling_mode;                               /*!< 1: polling mode ; 0:interrupt mode*/
+	int polling_mode_ps;                               /*!< 1: polling mode ; 0:interrupt mode*/
+	int polling_mode_als;                               /*!< 1: polling mode ; 0:interrupt mode*/
+    unsigned char   i2c_addr[C_CUST_I2C_ADDR_NUM];  /*!< i2c address list, some chip will have multiple address */
+    unsigned int    als_level[C_CUST_ALS_LEVEL-1];  /*!< (C_CUST_ALS_LEVEL-1) levels divides all range into C_CUST_ALS_LEVEL levels*/
+    unsigned int    als_value[C_CUST_ALS_LEVEL];    /*!< the value reported in each level */
+    //unsigned int    ps_threshold;                   /*!< the threshold of proximity sensor */	
+	unsigned int	state_val;
+	unsigned int 	psctrl_val;
+	unsigned int 	alsctrl_val;
+	unsigned int 	ledctrl_val;
+	unsigned int 	wait_val;	
+    unsigned int    ps_high_thd_val;
+    unsigned int    ps_low_thd_val;
+	unsigned int    als_window_loss;                /*!< the window loss  */
+};
+
+extern struct alsps_hw* stx3x1x_get_cust_alsps_hw(void);
+#endif 
+
diff --git a/drivers/misc/mediatek/alsps/stk3x1x_driver/stk3x1x.h b/drivers/misc/mediatek/alsps/stk3x1x_driver/stk3x1x.h
index 637a9f3..bb1828a 100644
--- a/drivers/misc/mediatek/alsps/stk3x1x_driver/stk3x1x.h
+++ b/drivers/misc/mediatek/alsps/stk3x1x_driver/stk3x1x.h
@@ -171,6 +171,6 @@
 #define ALS_MIN_DELAY   100
 #define PS_MIN_DELAY    10
 
-#define STK_ALS_CODE_CHANGE_THD	5
+#define STK_ALS_CODE_CHANGE_THD	10
 
-#endif
+#endif
\ No newline at end of file
diff --git a/drivers/misc/mediatek/lcm/jd9367_6735_dsi_video/jd9367_6735_dsi_video.c b/drivers/misc/mediatek/lcm/jd9367_6735_dsi_video/jd9367_6735_dsi_video.c
index db14ec5..920e5fa 100644
--- a/drivers/misc/mediatek/lcm/jd9367_6735_dsi_video/jd9367_6735_dsi_video.c
+++ b/drivers/misc/mediatek/lcm/jd9367_6735_dsi_video/jd9367_6735_dsi_video.c
@@ -119,9 +119,7 @@ static unsigned int lcm_esd_test = FALSE;      ///only for ESD test
 #include <linux/input/doubletap2wake.h>
 #endif
 
-#ifdef CONFIG_POCKETMOD
-#include <linux/pocket_mod.h>
-#endif
+
 
 static LCM_UTIL_FUNCS lcm_util = {0};
 
@@ -600,9 +598,6 @@ static void lcm_suspend(void)
     SET_RESET_PIN(0);
     MDELAY(200);
 //needed for pocket mode
-	#ifdef CONFIG_POCKETMOD
-	is_screen_on = 0;
-	#endif 
 
 }
 
@@ -610,9 +605,7 @@ static void lcm_suspend(void)
 static void lcm_resume(void)
 {
   lcm_init();
-#ifdef CONFIG_POCKETMOD
-	is_screen_on = 1;
-	#endif
+
 }
          
 #if (LCM_DSI_CMD_MODE)
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/Makefile b/drivers/misc/mediatek/mach/mt6735/benefit_m7/Makefile
index f580d25..d5ccbbc 100755
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/Makefile
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/Makefile
@@ -37,10 +37,19 @@ ifeq ($(CONFIG_MTK_MC3XXX_AUTO),y)
 obj-y   +=  accelerometer/mc3xxx_auto/
 endif
 
+
+ifeq ($(CONFIG_MTK_CM36652_NEW),y)
+obj-y   +=  alsps/cm36652-new/
+endif
+
 ifeq ($(CONFIG_MTK_STK3X1X_NEW),y)
 obj-y   +=  alsps/stk3x1x-new/
 endif
 
+ifeq ($(CONFIG_MTK_STK3X1X_DRIVER),y)
+obj-y	+=  alsps/stk3x1x_driver/
+endif
+
 ifeq ($(CONFIG_MTK_MMC3416X),y)
 obj-y   +=  magnetometer/mmc3416x/
 endif
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/alsps/stk3x1x-new/cust_alsps.c b/drivers/misc/mediatek/mach/mt6735/benefit_m7/alsps/stk3x1x-new/cust_alsps.c
index ccfdfc4..c46e5d8 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/alsps/stk3x1x-new/cust_alsps.c
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/alsps/stk3x1x-new/cust_alsps.c
@@ -1,26 +1,27 @@
+
 #include <linux/types.h>
 #include <mach/mt_pm_ldo.h>
 #include <cust_alsps.h>
-#include <mach/upmu_common.h>
 
-static struct alsps_hw cust_alsps_hw = {
-    .i2c_num    = 2,
+static struct alsps_hw cust_alsps_hw_stk3x1x = {
+	.i2c_num    = 3,
 	.polling_mode_ps =0,
 	.polling_mode_als =1,
-    .power_id   = MT65XX_POWER_NONE,    /*LDO is not used*/
-    .power_vol  = VOL_DEFAULT,          /*LDO is not used*/
-    //.i2c_addr   = {0x0C, 0x48, 0x78, 0x00},
-    //.als_level  = { 0,  1,  1,   7,  15,  15,  100, 1000, 2000,  3000,  6000, 10000, 14000, 18000, 20000},
-    //.als_value  = {40, 40, 90,  90, 160, 160,  225,  320,  640,  1280,  1280,  2600,  2600, 2600,  10240, 10240},
-    /* MTK: modified to support AAL */
-    .als_level  = {0, 89, 288, 464, 856, 2128, 2844, 4192, 5723, 6339, 8008, 11008, 11421, 11421, 65535},
-    .als_value  = {0, 134, 305, 501, 1005, 2002, 3002, 5000, 8012, 10020, 12010, 16020, 20020, 20020, 20020, 20020},
-    .ps_threshold_high = 450,
-    .ps_threshold_low = 400,
-    .is_batch_supported_ps = false,
-    .is_batch_supported_als = false,
+	.power_id   = MT65XX_POWER_NONE,    /*LDO is not used*/
+	.power_vol  = VOL_DEFAULT,          /*LDO is not used*/
+	.i2c_addr   = {0x90, 0x00, 0x00, 0x00},	/*STK3x1x*/
+        .als_level  = {5,  9, 36, 59, 82, 132, 205, 273, 500, 845, 1136, 1545, 2364, 4655, 6982},	/* als_code */
+        .als_value  = {0, 10, 40, 65, 90, 145, 225, 300, 550, 930, 1250, 1700, 2600, 5120, 7680, 10240},    /* lux */  	
+	//.state_val = 0x0,		/* disable all */
+	//.psctrl_val = 0x33,	// 0x31,	/* ps_persistance=1, ps_gain=64X, PS_IT=0.391ms */
+	//.alsctrl_val = 0x39,	// 0x38, /* als_persistance=1, als_gain=64X, ALS_IT=50ms */
+	//.ledctrl_val = 0xFF,	/* 100mA IRDR, 64/64 LED duty */
+	//.wait_val = 0x9, // 0x7,		/* 50 ms */
+	.ps_threshold_high = 1500, // 1700,
+	.ps_threshold_low = 1300,  // 1500,
 };
-struct alsps_hw *get_cust_alsps_hw(void) {
+struct alsps_hw *get_cust_alsps_hw_stk3x1x(void) {
     return &cust_alsps_hw;
 }
 
+
diff --git a/drivers/misc/mediatek/mach/mt6735/benefit_m7/alsps/stk3x1x_driver/cust_alsps.c b/drivers/misc/mediatek/mach/mt6735/benefit_m7/alsps/stk3x1x_driver/cust_alsps.c
index a3bc42a..3d57c19 100644
--- a/drivers/misc/mediatek/mach/mt6735/benefit_m7/alsps/stk3x1x_driver/cust_alsps.c
+++ b/drivers/misc/mediatek/mach/mt6735/benefit_m7/alsps/stk3x1x_driver/cust_alsps.c
@@ -57,7 +57,6 @@ static struct alsps_hw cust_alsps_hw = {
     .ps_threshold_high = 1700,
     .ps_threshold_low = 1500,
 };
-
 struct alsps_hw *stk_get_cust_alsps_hw(void) {
     return &cust_alsps_hw;
 }
diff --git a/include/config/auto.conf b/include/config/auto.conf
index f258550..b890132 100644
--- a/include/config/auto.conf
+++ b/include/config/auto.conf
@@ -374,7 +374,6 @@ CONFIG_NETFILTER_XT_TARGET_HL=y
 CONFIG_RTC_HCTOSYS=y
 CONFIG_SECURITY_NETWORK=y
 CONFIG_SERIAL_CORE_CONSOLE=y
-CONFIG_MTK_STK3X1X_NEW=y
 CONFIG_USB_HID=y
 CONFIG_IOSCHED_SIO=y
 CONFIG_USB_MTK_HDRC_GADGET=y
@@ -440,6 +439,7 @@ CONFIG_SND_HWDEP=y
 CONFIG_PANIC_ON_OOPS=y
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_WAKELOCK=y
+CONFIG_MTK_STK3X1X_DRIVER=y
 CONFIG_INPUT_MISC=y
 CONFIG_SND_COMPRESS_OFFLOAD=y
 CONFIG_CUSTOM_KERNEL_ACTIVITY_SENSOR=""
diff --git a/include/config/mtk/stk3x1x/driver.h b/include/config/mtk/stk3x1x/driver.h
new file mode 100644
index 0000000..e69de29
diff --git a/include/generated/autoconf.h b/include/generated/autoconf.h
index 0d89875..4847209 100644
--- a/include/generated/autoconf.h
+++ b/include/generated/autoconf.h
@@ -376,7 +376,6 @@
 #define CONFIG_RTC_HCTOSYS 1
 #define CONFIG_SECURITY_NETWORK 1
 #define CONFIG_SERIAL_CORE_CONSOLE 1
-#define CONFIG_MTK_STK3X1X_NEW 1
 #define CONFIG_USB_HID 1
 #define CONFIG_IOSCHED_SIO 1
 #define CONFIG_USB_MTK_HDRC_GADGET 1
@@ -442,6 +441,7 @@
 #define CONFIG_PANIC_ON_OOPS 1
 #define CONFIG_BLK_DEV_LOOP 1
 #define CONFIG_WAKELOCK 1
+#define CONFIG_MTK_STK3X1X_DRIVER 1
 #define CONFIG_INPUT_MISC 1
 #define CONFIG_SND_COMPRESS_OFFLOAD 1
 #define CONFIG_CUSTOM_KERNEL_ACTIVITY_SENSOR ""
diff --git a/include/generated/compile.h b/include/generated/compile.h
index 5f1dc5f..cf6bb86 100644
--- a/include/generated/compile.h
+++ b/include/generated/compile.h
@@ -1,7 +1,7 @@
-/* This file is auto generated, version 17 */
+/* This file is auto generated, version 34 */
 /* SMP PREEMPT */
 #define UTS_MACHINE "arm64"
-#define UTS_VERSION "#17 SMP PREEMPT Sun May 8 01:29:37 MSK 2016"
+#define UTS_VERSION "#34 SMP PREEMPT Sun May 8 15:35:31 MSK 2016"
 #define LINUX_COMPILE_BY "olegsvs"
 #define LINUX_COMPILE_HOST "olegsvs-develop"
 #define LINUX_COMPILER "gcc version 4.9 20150123 (prerelease) (GCC) "
diff --git a/tools/dct/DCT.log b/tools/dct/DCT.log
index 8e6a185..e69de29 100644
--- a/tools/dct/DCT.log
+++ b/tools/dct/DCT.log
@@ -1,5 +0,0 @@
-/* Log generated by MTK SP DrvGen Version 03.13.6;
- Log Time is Sun May 08 01:06:51 2016
- */
-open operater parse MT6735M.fig OK!
-Edit operater parse .cmp file OK!
-- 
2.7.4

