From 189cd0a5f0c047caa9b50cf17e9bc95af629559c Mon Sep 17 00:00:00 2001
From: Stefan Guendhoer <stefan@guendhoer.com>
Date: Wed, 13 Jan 2016 04:17:44 +0000
Subject: [PATCH 1028/1168] Linux 3.10.94 commit
 03ed106ff4c200d01f3c72f71fa9c5b18da07d9b Author: Greg Kroah-Hartman
 <gregkh@linuxfoundation.org> Date:   Wed Dec 9 13:43:21 2015 -0500
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

    Linux 3.10.94

commit 82dbfa50b0ee671e40779541a6ceef0850d19c84
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 15 22:39:08 2015 +0100

    ALSA: usb-audio: work around CH345 input SysEx corruption

    commit a91e627e3f0ed820b11d86cdc04df38f65f33a70 upstream.

    One of the many faults of the QinHeng CH345 USB MIDI interface chip is
    that it does not handle received SysEx messages correctly -- every second
    event packet has a wrong code index number, which is the one from the last
    seen message, instead of 4.  For example, the two messages "FE F0 01 02 03
    04 05 06 07 08 09 0A 0B 0C 0D 0E F7" result in the following event
    packets:

    correct:       CH345:
    0F FE 00 00    0F FE 00 00
    04 F0 01 02    04 F0 01 02
    04 03 04 05    0F 03 04 05
    04 06 07 08    04 06 07 08
    04 09 0A 0B    0F 09 0A 0B
    04 0C 0D 0E    04 0C 0D 0E
    05 F7 00 00    05 F7 00 00

    A class-compliant driver must interpret an event packet with CIN 15 as
    having a single data byte, so the other two bytes would be ignored.  The
    message received by the host would then be missing two bytes out of six;
    in this example, "F0 01 02 03 06 07 08 09 0C 0D 0E F7".

    These corrupted SysEx event packages contain only data bytes, while the
    CH345 uses event packets with a correct CIN value only for messages with
    a status byte, so it is possible to distinguish between these two cases by
    checking for the presence of this status byte.

    (Other bugs in the CH345's input handling, such as the corruption resulting
    from running status, cannot be worked around.)

    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 88ab73208769677b3935d747a43aab1213d15d39
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 15 22:38:29 2015 +0100

    ALSA: usb-audio: prevent CH345 multiport output SysEx corruption

    commit 1ca8b201309d842642f221db7f02f71c0af5be2d upstream.

    The CH345 USB MIDI chip has two output ports.  However, they are
    multiplexed through one pin, and the number of ports cannot be reduced
    even for hardware that implements only one connector, so for those
    devices, data sent to either port ends up on the same hardware output.
    This becomes a problem when both ports are used at the same time, as
    longer MIDI commands (such as SysEx messages) are likely to be
    interrupted by messages from the other port, and thus to get lost.

    It would not be possible for the driver to detect how many ports the
    device actually has, except that in practice, _all_ devices built with
    the CH345 have only one port.  So we can just ignore the device's
    descriptors, and hardcode one output port.

    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 5d39c9b60cfd2381737cdeb5a74bd79d4b27e84c
Author: Clemens Ladisch <clemens@ladisch.de>
Date:   Sun Nov 15 22:37:44 2015 +0100

    ALSA: usb-audio: add packet size quirk for the Medeli DD305

    commit 98d362becb6621bebdda7ed0eac7ad7ec6c37898 upstream.

    Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 53009ce204642c3191d6f4d773d28c80f0c27971
Author: Bjørn Mork <bjorn@mork.no>
Date:   Wed Nov 18 21:12:33 2015 +0100

    USB: option: add XS Stick W100-2 from 4G Systems

    commit 638148e20c7f8f6e95017fdc13bce8549a6925e0 upstream.

    Thomas reports
    "
    4gsystems sells two total different LTE-surfsticks under the same name.
    ..
    The newer version of XS Stick W100 is from "omega"
    ..
    Under windows the driver switches to the same ID, and uses MI03\6 for
    network and MI01\6 for modem.
    ..
    echo "1c9e 9b01" > /sys/bus/usb/drivers/qmi_wwan/new_id
    echo "1c9e 9b01" > /sys/bus/usb-serial/drivers/option1/new_id

    T:  Bus=01 Lev=01 Prnt=01 Port=03 Cnt=01 Dev#=  4 Spd=480 MxCh= 0
    D:  Ver= 2.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1
    P:  Vendor=1c9e ProdID=9b01 Rev=02.32
    S:  Manufacturer=USB Modem
    S:  Product=USB Modem
    S:  SerialNumber=
    C:  #Ifs= 5 Cfg#= 1 Atr=80 MxPwr=500mA
    I:  If#= 0 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=ff Prot=ff Driver=option
    I:  If#= 1 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=ff Prot=ff Driver=option
    I:  If#= 2 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=ff Prot=ff Driver=option
    I:  If#= 3 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=ff Prot=ff Driver=qmi_wwan
    I:  If#= 4 Alt= 0 #EPs= 2 Cls=08(stor.) Sub=06 Prot=50 Driver=usb-storage

    Now all important things are there:

    wwp0s29f7u2i3 (net), ttyUSB2 (at), cdc-wdm0 (qmi), ttyUSB1 (at)

    There is also ttyUSB0, but it is not usable, at least not for at.

    The device works well with qmi and ModemManager-NetworkManager.
    "

    Reported-by: Thomas Schäfer <tschaefer@t-online.de>
    Signed-off-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b2dbbdda6605358caeed741f51101395991dda5f
Author: Aleksander Morgado <aleksander@aleksander.es>
Date:   Wed Nov 11 19:51:40 2015 +0100

    USB: serial: option: add support for Novatel MiFi USB620L

    commit e07af133c3e2716db25e3e1e1d9f10c2088e9c1a upstream.

    Also known as Verizon U620L.

    The device is modeswitched from 1410:9020 to 1410:9022 by selecting the
    4th USB configuration:

     $ sudo usb_modeswitch –v 0x1410 –p 0x9020 –u 4

    This configuration provides a ECM interface as well as TTYs ('Enterprise
    Mode' according to the U620 Linux integration guide).

    Signed-off-by: Aleksander Morgado <aleksander@aleksander.es>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9a960144742c6b57a17e8fd0df982b9ea28ae3c9
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Fri Oct 23 09:53:50 2015 +0200

    usb: musb: core: fix order of arguments to ulpi write callback

    commit 705e63d2b29c8bbf091119084544d353bda70393 upstream.

    There is a bit of a mess in the order of arguments to the ulpi write
    callback. There is

    	int ulpi_write(struct ulpi *ulpi, u8 addr, u8 val)

    in drivers/usb/common/ulpi.c;

    	struct usb_phy_io_ops {
    		...
    		int (*write)(struct usb_phy *x, u32 val, u32 reg);
    	}

    in include/linux/usb/phy.h.

    The callback registered by the musb driver has to comply to the latter,
    but up to now had "offset" first which effectively made the function
    broken for correct users. So flip the order and while at it also
    switch to the parameter names of struct usb_phy_io_ops's write.

    Fixes: ffb865b1e460 ("usb: musb: add ulpi access operations")
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 2391fbf63585c3befa63a4780f470cf59539a6f7
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Nov 2 10:27:00 2015 +0100

    usblp: do not set TASK_INTERRUPTIBLE before lock

    commit 19cd80a214821f4b558560ebd76bfb2c38b4f3d8 upstream.

    It is not permitted to set task state before lock. usblp_wwait sets
    the state to TASK_INTERRUPTIBLE and calls mutex_lock_interruptible.
    Upon return from that function, the state will be TASK_RUNNING again.

    This is clearly a bug and a warning is generated with LOCKDEP too:
    WARNING: CPU: 1 PID: 5109 at kernel/sched/core.c:7404 __might_sleep+0x7d/0x90()
    do not call blocking ops when !TASK_RUNNING; state=1 set at [<ffffffffa0c588d0>] usblp_wwait+0xa0/0x310 [usblp]
    Modules linked in: ...
    CPU: 1 PID: 5109 Comm: captmon Tainted: G        W       4.2.5-0.gef2823b-default #1
    Hardware name: LENOVO 23252SG/23252SG, BIOS G2ET33WW (1.13 ) 07/24/2012
     ffffffff81a4edce ffff880236ec7ba8 ffffffff81716651 0000000000000000
     ffff880236ec7bf8 ffff880236ec7be8 ffffffff8106e146 0000000000000282
     ffffffff81a50119 000000000000028b 0000000000000000 ffff8802dab7c508
    Call Trace:
    ...
     [<ffffffff8106e1c6>] warn_slowpath_fmt+0x46/0x50
     [<ffffffff8109a8bd>] __might_sleep+0x7d/0x90
     [<ffffffff8171b20f>] mutex_lock_interruptible_nested+0x2f/0x4b0
     [<ffffffffa0c588fc>] usblp_wwait+0xcc/0x310 [usblp]
     [<ffffffffa0c58bb2>] usblp_write+0x72/0x350 [usblp]
     [<ffffffff8121ed98>] __vfs_write+0x28/0xf0
    ...

    Commit 7f477358e2384c54b190cc3b6ce28277050a041b (usblp: Implement the
    ENOSPC convention) moved the set prior locking. So move it back after
    the lock.

    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Fixes: 7f477358e2 ("usblp: Implement the ENOSPC convention")
    Acked-By: Pete Zaitcev <zaitcev@yahoo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b2a5b5964748a5a25a28652f4ea4223a534a4c86
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Oct 22 15:41:52 2015 +0100

    arm64: Fix compat register mappings

    commit 5accd17d0eb523350c9ef754d655e379c9bb93b3 upstream.

    For reasons not entirely apparent, but now enshrined in history, the
    architectural mapping of AArch32 banked registers to AArch64 registers
    actually orders SP_<mode> and LR_<mode> backwards compared to the
    intuitive r13/r14 order, for all modes except FIQ.

    Fix the compat_<reg>_<mode> macros accordingly, in the hope of avoiding
    subtle bugs with KVM and AArch32 guests.

    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3b792c868153a9911e46ec3069b7b94e7cc5c6c6
Author: Mirza Krak <mirza.krak@hostmobility.com>
Date:   Tue Nov 10 14:59:34 2015 +0100

    can: sja1000: clear interrupts on start

    commit 7cecd9ab80f43972c056dc068338f7bcc407b71c upstream.

    According to SJA1000 data sheet error-warning (EI) interrupt is not
    cleared by setting the controller in to reset-mode.

    Then if we have the following case:
    - system is suspended (echo mem > /sys/power/state) and SJA1000 is left
      in operating state
    - A bus error condition occurs which activates EI interrupt, system is
      still suspended which means EI interrupt will be not be handled nor
      cleared.

    If the above two events occur, on resume there is no way to return the
    SJA1000 to operating state, except to cycle power to it.

    By simply reading the IR register on start we will clear any previous
    conditions that could be present.

    Signed-off-by: Mirza Krak <mirza.krak@hostmobility.com>
    Reported-by: Christian Magnusson <Christian.Magnusson@semcon.com>
    Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c45820774f2d7f3196c7ad371b026c2b6e93c9a7
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Mon Sep 7 12:05:41 2015 +0200

    Bluetooth: hidp: fix device disconnect on idle timeout

    commit 660f0fc07d21114549c1862e67e78b1cf0c90c29 upstream.

    The HIDP specs define an idle-timeout which automatically disconnects a
    device. This has always been implemented in the HIDP layer and forced a
    synchronous shutdown of the hidp-scheduler. This works just fine, but
    lacks a forced disconnect on the underlying l2cap channels. This has been
    broken since:

        commit 5205185d461d5902325e457ca80bd421127b7308
        Author: David Herrmann <dh.herrmann@gmail.com>
        Date:   Sat Apr 6 20:28:47 2013 +0200

            Bluetooth: hidp: remove old session-management

    The old session-management always forced an l2cap error on the ctrl/intr
    channels when shutting down. The new session-management skips this, as we
    don't want to enforce channel policy on the caller. In other words, if
    user-space removes an HIDP device, the underlying channels (which are
    *owned* and *referenced* by user-space) are still left active. User-space
    needs to call shutdown(2) or close(2) to release them.

    Unfortunately, this does not work with idle-timeouts. There is no way to
    signal user-space that the HIDP layer has been stopped. The API simply
    does not support any event-passing except for poll(2). Hence, we restore
    old behavior and force EUNATCH on the sockets if the HIDP layer is
    disconnected due to idle-timeouts (behavior of explicit disconnects
    remains unmodified). User-space can still call

        getsockopt(..., SO_ERROR, ...)

    ..to retrieve the EUNATCH error and clear sk_err. Hence, the channels can
    still be re-used (which nobody does so far, though). Therefore, the API
    still supports the new behavior, but with this patch it's also compatible
    to the old implicit channel shutdown.

    Reported-by: Mark Haun <haunma@keteu.org>
    Reported-by: Luiz Augusto von Dentz <luiz.dentz@gmail.com>
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9babe681a7554368197bc33b33eaea6ec3112f51
Author: Larry Finger <Larry.Finger@lwfinger.net>
Date:   Sun Oct 18 22:14:48 2015 -0500

    staging: rtl8712: Add device ID for Sitecom WLA2100

    commit 1e6e63283691a2a9048a35d9c6c59cf0abd342e4 upstream.

    This adds the USB ID for the Sitecom WLA2100. The Windows 10 inf file
    was checked to verify that the addition is correct.

    Reported-by: Frans van de Wiel <fvdw@fvdw.eu>
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    Cc: Frans van de Wiel <fvdw@fvdw.eu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 95563ce161961fbdf5df6d2b2df0d8ee5cf660c9
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Sep 21 19:19:53 2015 +0300

    mwifiex: fix mwifiex_rdeeprom_read()

    commit 1f9c6e1bc1ba5f8a10fcd6e99d170954d7c6d382 upstream.

    There were several bugs here.

    1)  The done label was in the wrong place so we didn't copy any
        information out when there was no command given.

    2)  We were using PAGE_SIZE as the size of the buffer instead of
        "PAGE_SIZE - pos".

    3)  snprintf() returns the number of characters that would have been
        printed if there were enough space.  If there was not enough space
        (and we had fixed the memory corruption bug #2) then it would result
        in an information leak when we do simple_read_from_buffer().  I've
        changed it to use scnprintf() instead.

    I also removed the initialization at the start of the function, because
    I thought it made the code a little more clear.

    Fixes: 5e6e3a92b9a4 ('wireless: mwifiex: initial commit for Marvell mwifiex driver')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Amitkumar Karwar <akarwar@marvell.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit dde9eef8c909fac6f2bac664598a1b8553bbb003
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Fri Sep 25 18:09:35 2015 +0200

    net: mvneta: Fix CPU_MAP registers initialisation

    commit 2502d0ef272da7058ef303b849a2c8dc324c2e2e upstream.

    The CPU_MAP register is duplicated for each CPUs at different addresses,
    each instance being at a different address.

    However, the code so far was using CONFIG_NR_CPUS to initialise the CPU_MAP
    registers for each registers, while the SoCs embed at most 4 CPUs.

    This is especially an issue with multi_v7_defconfig, where CONFIG_NR_CPUS
    is currently set to 16, resulting in writes to registers that are not
    CPU_MAP.

    Fixes: c5aff18204da ("net: mvneta: driver for Marvell Armada 370/XP network unit")
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ad9550e54d1bb06eb91100e0b8129b77015943b7
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Aug 28 10:52:53 2015 +0200

    mac80211: fix driver RSSI event calculations

    commit 8ec6d97871f37e4743678ea4a455bd59580aa0f4 upstream.

    The ifmgd->ave_beacon_signal value cannot be taken as is for
    comparisons, it must be divided by since it's represented
    like that for better accuracy of the EWMA calculations. This
    would lead to invalid driver RSSI events. Fix the used value.

    Fixes: 615f7b9bb1f8 ("mac80211: add driver RSSI threshold events")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8fa88fa8503eba326e6ddf47e3ec1f71d6997dc0
Author: Andrew Cooper <andrew.cooper3@citrix.com>
Date:   Wed Jun 3 10:31:14 2015 +0100

    x86/cpu: Fix SMAP check in PVOPS environments

    commit 581b7f158fe0383b492acd1ce3fb4e99d4e57808 upstream.

    There appears to be no formal statement of what pv_irq_ops.save_fl() is
    supposed to return precisely.  Native returns the full flags, while lguest and
    Xen only return the Interrupt Flag, and both have comments by the
    implementations stating that only the Interrupt Flag is looked at.  This may
    have been true when initially implemented, but no longer is.

    To make matters worse, the Xen PVOP leaves the upper bits undefined, making
    the BUG_ON() undefined behaviour.  Experimentally, this now trips for 32bit PV
    guests on Broadwell hardware.  The BUG_ON() is consistent for an individual
    build, but not consistent for all builds.  It has also been a sitting timebomb
    since SMAP support was introduced.

    Use native_save_fl() instead, which will obtain an accurate view of the AC
    flag.

    Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Tested-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: <lguest@lists.ozlabs.org>
    Cc: Xen-devel <xen-devel@lists.xen.org>
    Link: http://lkml.kernel.org/r/1433323874-6927-1-git-send-email-andrew.cooper3@citrix.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8f14777b580d064a80f0adac4c2596d24a196205
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Nov 5 16:57:56 2015 +0100

    x86/cpu: Call verify_cpu() after having entered long mode too

    commit 04633df0c43d710e5f696b06539c100898678235 upstream.

    When we get loaded by a 64-bit bootloader, kernel entry point is
    startup_64 in head_64.S. We don't trust any and all bootloaders because
    some will fiddle with CPU configuration so we go ahead and massage each
    CPU into sanity again.

    For example, some dell BIOSes have this XD disable feature which set
    IA32_MISC_ENABLE[34] and disable NX. This might be some dumb workaround
    for other OSes but Linux sure doesn't need it.

    A similar thing is present in the Surface 3 firmware - see
    https://bugzilla.kernel.org/show_bug.cgi?id=106051 - which sets this bit
    only on the BSP:

      # rdmsr -a 0x1a0
      400850089
      850089
      850089
      850089

    I know, right?!

    There's not even an off switch in there.

    So fix all those cases by sanitizing the 64-bit entry point too. For
    that, make verify_cpu() callable in 64-bit mode also.

    Requested-and-debugged-by: "H. Peter Anvin" <hpa@zytor.com>
    Reported-and-tested-by: Bastien Nocera <bugzilla@hadess.net>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Matt Fleming <matt@codeblueprint.co.uk>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1446739076-21303-1-git-send-email-bp@alien8.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 308b1b04336a71008b9b9d143506625d4c653751
Author: Krzysztof Mazur <krzysiek@podlesie.net>
Date:   Fri Nov 6 14:18:36 2015 +0100

    x86/setup: Fix low identity map for >= 2GB kernel range

    commit 68accac392d859d24adcf1be3a90e41f978bd54c upstream.

    The commit f5f3497cad8c extended the low identity mapping. However, if
    the kernel uses more than 2 GB (VMSPLIT_2G_OPT or VMSPLIT_1G memory
    split), the normal memory mapping is overwritten by the low identity
    mapping causing a crash. To avoid overwritting, limit the low identity
    map to cover only memory before kernel range (PAGE_OFFSET).

    Fixes: f5f3497cad8c "x86/setup: Extend low identity map to cover whole kernel range
    Signed-off-by: Krzysztof Mazur <krzysiek@podlesie.net>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Laszlo Ersek <lersek@redhat.com>
    Cc: Matt Fleming <matt.fleming@intel.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Link: http://lkml.kernel.org/r/1446815916-22105-1-git-send-email-krzysiek@podlesie.net
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit fa4fbf71380d21a54e25b66e77b9700184c0ef91
Author: Paolo Bonzini <pbonzini@redhat.com>
Date:   Wed Oct 14 13:30:45 2015 +0200

    x86/setup: Extend low identity map to cover whole kernel range

    commit f5f3497cad8c8416a74b9aaceb127908755d020a upstream.

    On 32-bit systems, the initial_page_table is reused by
    efi_call_phys_prolog as an identity map to call
    SetVirtualAddressMap.  efi_call_phys_prolog takes care of
    converting the current CPU's GDT to a physical address too.

    For PAE kernels the identity mapping is achieved by aliasing the
    first PDPE for the kernel memory mapping into the first PDPE
    of initial_page_table.  This makes the EFI stub's trick "just work".

    However, for non-PAE kernels there is no guarantee that the identity
    mapping in the initial_page_table extends as far as the GDT; in this
    case, accesses to the GDT will cause a page fault (which quickly becomes
    a triple fault).  Fix this by copying the kernel mappings from
    swapper_pg_dir to initial_page_table twice, both at PAGE_OFFSET and at
    identity mapping.

    For some reason, this is only reproducible with QEMU's dynamic translation
    mode, and not for example with KVM.  However, even under KVM one can clearly
    see that the page table is bogus:

        $ qemu-system-i386 -pflash OVMF.fd -M q35 vmlinuz0 -s -S -daemonize
        $ gdb
        (gdb) target remote localhost:1234
        (gdb) hb *0x02858f6f
        Hardware assisted breakpoint 1 at 0x2858f6f
        (gdb) c
        Continuing.

        Breakpoint 1, 0x02858f6f in ?? ()
        (gdb) monitor info registers
        ...
        GDT=     0724e000 000000ff
        IDT=     fffbb000 000007ff
        CR0=0005003b CR2=ff896000 CR3=032b7000 CR4=00000690
        ...

    The page directory is sane:

        (gdb) x/4wx 0x32b7000
        0x32b7000:	0x03398063	0x03399063	0x0339a063	0x0339b063
        (gdb) x/4wx 0x3398000
        0x3398000:	0x00000163	0x00001163	0x00002163	0x00003163
        (gdb) x/4wx 0x3399000
        0x3399000:	0x00400003	0x00401003	0x00402003	0x00403003

    but our particular page directory entry is empty:

        (gdb) x/1wx 0x32b7000 + (0x724e000 >> 22) * 4
        0x32b7070:	0x00000000

    [ It appears that you can skate past this issue if you don't receive
      any interrupts while the bogus GDT pointer is loaded, or if you avoid
      reloading the segment registers in general.

      Andy Lutomirski provides some additional insight:

       "AFAICT it's entirely permissible for the GDTR and/or LDT
        descriptor to point to unmapped memory.  Any attempt to use them
        (segment loads, interrupts, IRET, etc) will try to access that memory
        as if the access came from CPL 0 and, if the access fails, will
        generate a valid page fault with CR2 pointing into the GDT or
        LDT."

      Up until commit 23a0d4e8fa6d ("efi: Disable interrupts around EFI
      calls, not in the epilog/prolog calls") interrupts were disabled
      around the prolog and epilog calls, and the functional GDT was
      re-installed before interrupts were re-enabled.

      Which explains why no one has hit this issue until now. ]

    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
    Reported-by: Laszlo Ersek <lersek@redhat.com>
    Cc: <stable@vger.kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Matt Fleming <matt.fleming@intel.com>
    [ Updated changelog. ]
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8d4b96524384f8962c64c2ae061326682916dc48
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sat Oct 3 13:03:47 2015 -0700

    ARM: orion: Fix DSA platform device after mvmdio conversion

    commit d836ace65ee98d7079bc3c5afdbcc0e27dca20a3 upstream.

    DSA expects the host_dev pointer to be the device structure associated
    with the MDIO bus controller driver. First commit breaking that was
    c3a07134e6aa ("mv643xx_eth: convert to use the Marvell Orion MDIO
    driver"), and then, it got completely under the radar for a while.

    Reported-by: Frans van de Wiel <fvdw@fvdw.eu>
    Fixes: c3a07134e6aa ("mv643xx_eth: convert to use the Marvell Orion MDIO driver")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1aac1dc9886764cfa1226273e4d4709284872442
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Aug 28 09:42:09 2015 +0100

    ARM: 8427/1: dma-mapping: add support for offset parameter in dma_mmap()

    commit 7e31210349e9e03a9a4dff31ab5f2bc83e8e84f5 upstream.

    IOMMU-based dma_mmap() implementation lacked proper support for offset
    parameter used in mmap call (it always assumed that mapping starts from
    offset zero). This patch adds support for offset parameter to IOMMU-based
    implementation.

    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 98cc6d31fa7dde7beb1bccc51ad5c858d9ae5b04
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri Aug 28 09:41:39 2015 +0100

    ARM: 8426/1: dma-mapping: add missing range check in dma_mmap()

    commit 371f0f085f629fc0f66695f572373ca4445a67ad upstream.

    dma_mmap() function in IOMMU-based dma-mapping implementation lacked
    a check for valid range of mmap parameters (offset and buffer size), what
    might have caused access beyond the allocated buffer. This patch fixes
    this issue.

    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c79f626810b7d20aca9cd935d8cfc3272ba7a054
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Tue Sep 8 10:53:40 2015 -0400

    RDS: verify the underlying transport exists before creating a connection

    [ Upstream commit 74e98eb085889b0d2d4908f59f6e00026063014f ]

    There was no verification that an underlying transport exists when creating
    a connection, this would cause dereferencing a NULL ptr.

    It might happen on sockets that weren't properly bound before attempting to
    send a message, which will cause a NULL ptr deref:

    [135546.047719] kasan: GPF could be caused by NULL-ptr deref or user memory accessgeneral protection fault: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC KASAN
    [135546.051270] Modules linked in:
    [135546.051781] CPU: 4 PID: 15650 Comm: trinity-c4 Not tainted 4.2.0-next-20150902-sasha-00041-gbaa1222-dirty #2527
    [135546.053217] task: ffff8800835bc000 ti: ffff8800bc708000 task.ti: ffff8800bc708000
    [135546.054291] RIP: __rds_conn_create (net/rds/connection.c:194)
    [135546.055666] RSP: 0018:ffff8800bc70fab0  EFLAGS: 00010202
    [135546.056457] RAX: dffffc0000000000 RBX: 0000000000000f2c RCX: ffff8800835bc000
    [135546.057494] RDX: 0000000000000007 RSI: ffff8800835bccd8 RDI: 0000000000000038
    [135546.058530] RBP: ffff8800bc70fb18 R08: 0000000000000001 R09: 0000000000000000
    [135546.059556] R10: ffffed014d7a3a23 R11: ffffed014d7a3a21 R12: 0000000000000000
    [135546.060614] R13: 0000000000000001 R14: ffff8801ec3d0000 R15: 0000000000000000
    [135546.061668] FS:  00007faad4ffb700(0000) GS:ffff880252000000(0000) knlGS:0000000000000000
    [135546.062836] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [135546.063682] CR2: 000000000000846a CR3: 000000009d137000 CR4: 00000000000006a0
    [135546.064723] Stack:
    [135546.065048]  ffffffffafe2055c ffffffffafe23fc1 ffffed00493097bf ffff8801ec3d0008
    [135546.066247]  0000000000000000 00000000000000d0 0000000000000000 ac194a24c0586342
    [135546.067438]  1ffff100178e1f78 ffff880320581b00 ffff8800bc70fdd0 ffff880320581b00
    [135546.068629] Call Trace:
    [135546.069028] ? __rds_conn_create (include/linux/rcupdate.h:856 net/rds/connection.c:134)
    [135546.069989] ? rds_message_copy_from_user (net/rds/message.c:298)
    [135546.071021] rds_conn_create_outgoing (net/rds/connection.c:278)
    [135546.071981] rds_sendmsg (net/rds/send.c:1058)
    [135546.072858] ? perf_trace_lock (include/trace/events/lock.h:38)
    [135546.073744] ? lockdep_init (kernel/locking/lockdep.c:3298)
    [135546.074577] ? rds_send_drop_to (net/rds/send.c:976)
    [135546.075508] ? __might_fault (./arch/x86/include/asm/current.h:14 mm/memory.c:3795)
    [135546.076349] ? __might_fault (mm/memory.c:3795)
    [135546.077179] ? rds_send_drop_to (net/rds/send.c:976)
    [135546.078114] sock_sendmsg (net/socket.c:611 net/socket.c:620)
    [135546.078856] SYSC_sendto (net/socket.c:1657)
    [135546.079596] ? SYSC_connect (net/socket.c:1628)
    [135546.080510] ? trace_dump_stack (kernel/trace/trace.c:1926)
    [135546.081397] ? ring_buffer_unlock_commit (kernel/trace/ring_buffer.c:2479 kernel/trace/ring_buffer.c:2558 kernel/trace/ring_buffer.c:2674)
    [135546.082390] ? trace_buffer_unlock_commit (kernel/trace/trace.c:1749)
    [135546.083410] ? trace_event_raw_event_sys_enter (include/trace/events/syscalls.h:16)
    [135546.084481] ? do_audit_syscall_entry (include/trace/events/syscalls.h:16)
    [135546.085438] ? trace_buffer_unlock_commit (kernel/trace/trace.c:1749)
    [135546.085515] rds_ib_laddr_check(): addr 36.74.25.172 ret -99 node type -1

    Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bd81712486bd1af8086984b5191d055908d867ec
Author: Jason Wang <jasowang@redhat.com>
Date:   Wed Aug 5 10:34:04 2015 +0800

    virtio-net: drop NETIF_F_FRAGLIST

    [ Upstream commit 48900cb6af4282fa0fb6ff4d72a81aa3dadb5c39 ]

    virtio declares support for NETIF_F_FRAGLIST, but assumes
    that there are at most MAX_SKB_FRAGS + 2 fragments which isn't
    always true with a fraglist.

    A longer fraglist in the skb will make the call to skb_to_sgvec overflow
    the sg array, leading to memory corruption.

    Drop NETIF_F_FRAGLIST so we only get what we can handle.

    Cc: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jason Wang <jasowang@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0be0e5758dbdf3f61378b5d17d00363f92e93bae
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Nov 9 17:51:23 2015 -0800

    net: fix a race in dst_release()

    [ Upstream commit d69bbf88c8d0b367cf3e3a052f6daadf630ee566 ]

    Only cpu seeing dst refcount going to 0 can safely
    dereference dst->flags.

    Otherwise an other cpu might already have freed the dst.

    Fixes: 27b75c95f10d ("net: avoid RCU for NOCACHE dst")
    Reported-by: Greg Thelen <gthelen@google.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 0861d012ecff07b74a8c6ecfda04bb1737831e09
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Nov 2 07:50:07 2015 -0800

    net: avoid NULL deref in inet_ctl_sock_destroy()

    [ Upstream commit 8fa677d2706d325d71dab91bf6e6512c05214e37 ]

    Under low memory conditions, tcp_sk_init() and icmp_sk_init()
    can both iterate on all possible cpus and call inet_ctl_sock_destroy(),
    with eventual NULL pointer.

    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 25e462d9e34f8bb0cdaab78093c61373048d13a3
Author: Ani Sinha <ani@arista.com>
Date:   Fri Oct 30 16:54:31 2015 -0700

    ipmr: fix possible race resulting from improper usage of IP_INC_STATS_BH() in preemptible context.

    [ Upstream commit 44f49dd8b5a606870a1f21101522a0f9c4414784 ]

    Fixes the following kernel BUG :

    BUG: using __this_cpu_add() in preemptible [00000000] code: bash/2758
    caller is __this_cpu_preempt_check+0x13/0x15
    CPU: 0 PID: 2758 Comm: bash Tainted: P           O   3.18.19 #2
     ffffffff8170eaca ffff880110d1b788 ffffffff81482b2a 0000000000000000
     0000000000000000 ffff880110d1b7b8 ffffffff812010ae ffff880007cab800
     ffff88001a060800 ffff88013a899108 ffff880108b84240 ffff880110d1b7c8
    Call Trace:
    [<ffffffff81482b2a>] dump_stack+0x52/0x80
    [<ffffffff812010ae>] check_preemption_disabled+0xce/0xe1
    [<ffffffff812010d4>] __this_cpu_preempt_check+0x13/0x15
    [<ffffffff81419d60>] ipmr_queue_xmit+0x647/0x70c
    [<ffffffff8141a154>] ip_mr_forward+0x32f/0x34e
    [<ffffffff8141af76>] ip_mroute_setsockopt+0xe03/0x108c
    [<ffffffff810553fc>] ? get_parent_ip+0x11/0x42
    [<ffffffff810e6974>] ? pollwake+0x4d/0x51
    [<ffffffff81058ac0>] ? default_wake_function+0x0/0xf
    [<ffffffff810553fc>] ? get_parent_ip+0x11/0x42
    [<ffffffff810613d9>] ? __wake_up_common+0x45/0x77
    [<ffffffff81486ea9>] ? _raw_spin_unlock_irqrestore+0x1d/0x32
    [<ffffffff810618bc>] ? __wake_up_sync_key+0x4a/0x53
    [<ffffffff8139a519>] ? sock_def_readable+0x71/0x75
    [<ffffffff813dd226>] do_ip_setsockopt+0x9d/0xb55
    [<ffffffff81429818>] ? unix_seqpacket_sendmsg+0x3f/0x41
    [<ffffffff813963fe>] ? sock_sendmsg+0x6d/0x86
    [<ffffffff813959d4>] ? sockfd_lookup_light+0x12/0x5d
    [<ffffffff8139650a>] ? SyS_sendto+0xf3/0x11b
    [<ffffffff810d5738>] ? new_sync_read+0x82/0xaa
    [<ffffffff813ddd19>] compat_ip_setsockopt+0x3b/0x99
    [<ffffffff813fb24a>] compat_raw_setsockopt+0x11/0x32
    [<ffffffff81399052>] compat_sock_common_setsockopt+0x18/0x1f
    [<ffffffff813c4d05>] compat_SyS_setsockopt+0x1a9/0x1cf
    [<ffffffff813c4149>] compat_SyS_socketcall+0x180/0x1e3
    [<ffffffff81488ea1>] cstar_dispatch+0x7/0x1e

    Signed-off-by: Ani Sinha <ani@arista.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 34805d167c315860130d55448e9a45b51cc18fb2
Author: Phil Reid <preid@electromag.com.au>
Date:   Fri Oct 30 16:43:55 2015 +0800

    stmmac: Correctly report PTP capabilities.

    [ Upstream commit e6dbe1eb2db0d7a14991c06278dd3030c45fb825 ]

    priv->hwts_*_en indicate if timestamping is enabled/disabled at run
    time. But  priv->dma_cap.time_stamp  and priv->dma_cap.atime_stamp
    indicates HW is support for PTPv1/PTPv2.

    Signed-off-by: Phil Reid <preid@electromag.com.au>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 669cd5ea954101b516a1632995e8e12f2898da17
Author: Carol L Soto <clsoto@linux.vnet.ibm.com>
Date:   Tue Oct 27 17:36:20 2015 +0200

    net/mlx4: Copy/set only sizeof struct mlx4_eqe bytes

    [ Upstream commit c02b05011fadf8e409e41910217ca689f2fc9d91 ]

    When doing memcpy/memset of EQEs, we should use sizeof struct
    mlx4_eqe as the base size and not caps.eqe_size which could be bigger.

    If caps.eqe_size is bigger than the struct mlx4_eqe then we corrupt
    data in the master context.

    When using a 64 byte stride, the memcpy copied over 63 bytes to the
    slave_eq structure.  This resulted in copying over the entire eqe of
    interest, including its ownership bit -- and also 31 bytes of garbage
    into the next WQE in the slave EQ -- which did NOT include the ownership
    bit (and therefore had no impact).

    However, once the stride is increased to 128, we are overwriting the
    ownership bits of *three* eqes in the slave_eq struct.  This results
    in an incorrect ownership bit for those eqes, which causes the eq to
    seem to be full. The issue therefore surfaced only once 128-byte EQEs
    started being used in SRIOV and (overarchitectures that have 128/256
    byte cache-lines such as PPC) - e.g after commit 77507aa249ae
    "net/mlx4_core: Enable CQE/EQE stride support".

    Fixes: 08ff32352d6f ('mlx4: 64-byte CQE/EQE support')
    Signed-off-by: Carol L Soto <clsoto@linux.vnet.ibm.com>
    Signed-off-by: Jack Morgenstein <jackm@dev.mellanox.co.il>
    Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 074043fdd071a4d5c4cd25fa7aaaff5c6eedd1dd
Author: Sowmini Varadhan <sowmini.varadhan@oracle.com>
Date:   Mon Oct 26 12:46:37 2015 -0400

    RDS-TCP: Recover correctly from pskb_pull()/pksb_trim() failure in rds_tcp_data_recv

    [ Upstream commit 8ce675ff39b9958d1c10f86cf58e357efaafc856 ]

    Either of pskb_pull() or pskb_trim() may fail under low memory conditions.
    If rds_tcp_data_recv() ignores such failures, the application will
    receive corrupted data because the skb has not been correctly
    carved to the RDS datagram size.

    Avoid this by handling pskb_pull/pskb_trim failure in the same
    manner as the skb_clone failure: bail out of rds_tcp_data_recv(), and
    retry via the deferred call to rds_send_worker() that gets set up on
    ENOMEM from rds_tcp_read_sock()

    Signed-off-by: Sowmini Varadhan <sowmini.varadhan@oracle.com>
    Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit e42f6b5c7bcf22062a389d40cbf2a723aab4d2df
Author: Guillaume Nault <g.nault@alphalink.fr>
Date:   Thu Oct 22 16:57:10 2015 +0200

    ppp: fix pppoe_dev deletion condition in pppoe_release()

    [ Upstream commit 1acea4f6ce1b1c0941438aca75dd2e5c6b09db60 ]

    We can't rely on PPPOX_ZOMBIE to decide whether to clear po->pppoe_dev.
    PPPOX_ZOMBIE can be set by pppoe_disc_rcv() even when po->pppoe_dev is
    NULL. So we have no guarantee that (sk->sk_state & PPPOX_ZOMBIE) implies
    (po->pppoe_dev != NULL).
    Since we're releasing a PPPoE socket, we want to release the pppoe_dev
    if it exists and reset sk_state to PPPOX_DEAD, no matter the previous
    value of sk_state. So we can just check for po->pppoe_dev and avoid any
    assumption on sk->sk_state.

    Fixes: 2b018d57ff18 ("pppoe: drop PPPOX_ZOMBIEs in pppoe_release")
    Signed-off-by: Guillaume Nault <g.nault@alphalink.fr>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit edbdd72399cf707f3086a8c3df35e435381fd227
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Oct 19 13:16:49 2015 +0300

    irda: precedence bug in irlmp_seq_hb_idx()

    [ Upstream commit 50010c20597d14667eff0fdb628309986f195230 ]

    This is decrementing the pointer, instead of the value stored in the
    pointer.  KASan detects it as an out of bounds reference.

    Reported-by: "Berry Cheng 程君(成淼)" <chengmiao.cj@alibaba-inc.com>
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>


Former-commit-id: a08e130dc13ff0c96a0b3ed1f90c09e5e9bfc3ac
---
 Makefile                                           |  2 +-
 arch/arm/mm/dma-mapping.c                          |  7 ++++
 arch/arm/plat-orion/common.c                       |  2 +-
 arch/arm64/include/asm/ptrace.h                    | 16 ++++----
 arch/x86/kernel/cpu/common.c                       |  3 +-
 arch/x86/kernel/head_64.S                          |  8 ++++
 arch/x86/kernel/setup.c                            |  8 ++++
 arch/x86/kernel/verify_cpu.S                       | 12 +++---
 drivers/net/can/sja1000/sja1000.c                  |  3 ++
 drivers/net/ethernet/marvell/mvneta.c              |  2 +-
 drivers/net/ethernet/mellanox/mlx4/cmd.c           |  2 +-
 drivers/net/ethernet/mellanox/mlx4/eq.c            |  2 +-
 .../net/ethernet/stmicro/stmmac/stmmac_ethtool.c   |  7 +++-
 drivers/net/ppp/pppoe.c                            |  2 +-
 drivers/net/virtio_net.c                           |  4 +-
 drivers/net/wireless/mwifiex/debugfs.c             | 14 +++----
 drivers/staging/rtl8712/usb_intf.c                 |  1 +
 drivers/usb/class/usblp.c                          |  2 +-
 drivers/usb/musb/musb_core.c                       | 10 ++---
 drivers/usb/serial/option.c                        | 11 ++++++
 include/net/inet_common.h                          |  3 +-
 net/bluetooth/hidp/core.c                          | 14 +++++++
 net/core/dst.c                                     |  2 +-
 net/ipv4/ipmr.c                                    |  6 +--
 net/irda/irlmp.c                                   |  2 +-
 net/mac80211/mlme.c                                |  2 +-
 net/rds/connection.c                               |  6 +++
 net/rds/tcp_recv.c                                 | 11 +++++-
 sound/usb/midi.c                                   | 46 ++++++++++++++++++++++
 sound/usb/quirks-table.h                           | 11 ++++++
 sound/usb/quirks.c                                 |  1 +
 sound/usb/usbaudio.h                               |  1 +
 32 files changed, 176 insertions(+), 47 deletions(-)

diff --git a/Makefile b/Makefile
index 93019e1..de042b2 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,6 @@
 VERSION = 3
 PATCHLEVEL = 10
-SUBLEVEL = 93
+SUBLEVEL = 94
 EXTRAVERSION =
 NAME = TOSSUG Baby Fish
 
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 10f605f..5974209 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -1367,12 +1367,19 @@ static int arm_iommu_mmap_attrs(struct device *dev, struct vm_area_struct *vma,
 	unsigned long uaddr = vma->vm_start;
 	unsigned long usize = vma->vm_end - vma->vm_start;
 	struct page **pages = __iommu_get_pages(cpu_addr, attrs);
+	unsigned long nr_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;
+	unsigned long off = vma->vm_pgoff;
 
 	vma->vm_page_prot = __get_dma_pgprot(attrs, vma->vm_page_prot);
 
 	if (!pages)
 		return -ENXIO;
 
+	if (off >= nr_pages || (usize >> PAGE_SHIFT) > nr_pages - off)
+		return -ENXIO;
+
+	pages += off;
+
 	do {
 		int ret = vm_insert_page(vma, uaddr, *pages++);
 		if (ret) {
diff --git a/arch/arm/plat-orion/common.c b/arch/arm/plat-orion/common.c
index c019b7a..553e00a 100644
--- a/arch/arm/plat-orion/common.c
+++ b/arch/arm/plat-orion/common.c
@@ -498,7 +498,7 @@ void __init orion_ge00_switch_init(struct dsa_platform_data *d, int irq)
 
 	d->netdev = &orion_ge00.dev;
 	for (i = 0; i < d->nr_chips; i++)
-		d->chip[i].mii_bus = &orion_ge00_shared.dev;
+		d->chip[i].mii_bus = &orion_ge_mvmdio.dev;
 	orion_switch_device.dev.platform_data = d;
 
 	platform_device_register(&orion_switch_device);
diff --git a/arch/arm64/include/asm/ptrace.h b/arch/arm64/include/asm/ptrace.h
index 2861aed..7cea6d1 100644
--- a/arch/arm64/include/asm/ptrace.h
+++ b/arch/arm64/include/asm/ptrace.h
@@ -79,14 +79,14 @@
 #define compat_sp	regs[13]
 #define compat_lr	regs[14]
 #define compat_sp_hyp	regs[15]
-#define compat_sp_irq	regs[16]
-#define compat_lr_irq	regs[17]
-#define compat_sp_svc	regs[18]
-#define compat_lr_svc	regs[19]
-#define compat_sp_abt	regs[20]
-#define compat_lr_abt	regs[21]
-#define compat_sp_und	regs[22]
-#define compat_lr_und	regs[23]
+#define compat_lr_irq	regs[16]
+#define compat_sp_irq	regs[17]
+#define compat_lr_svc	regs[18]
+#define compat_sp_svc	regs[19]
+#define compat_lr_abt	regs[20]
+#define compat_sp_abt	regs[21]
+#define compat_lr_und	regs[22]
+#define compat_sp_und	regs[23]
 #define compat_r8_fiq	regs[24]
 #define compat_r9_fiq	regs[25]
 #define compat_r10_fiq	regs[26]
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index 5641401..81e0fe4 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -280,10 +280,9 @@ __setup("nosmap", setup_disable_smap);
 
 static __always_inline void setup_smap(struct cpuinfo_x86 *c)
 {
-	unsigned long eflags;
+	unsigned long eflags = native_save_fl();
 
 	/* This should have been cleared long ago */
-	raw_local_save_flags(eflags);
 	BUG_ON(eflags & X86_EFLAGS_AC);
 
 	if (cpu_has(c, X86_FEATURE_SMAP)) {
diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S
index f2a9a2a..3280489 100644
--- a/arch/x86/kernel/head_64.S
+++ b/arch/x86/kernel/head_64.S
@@ -65,6 +65,9 @@ startup_64:
 	 * tables and then reload them.
 	 */
 
+	/* Sanitize CPU configuration */
+	call verify_cpu
+
 	/*
 	 * Compute the delta between the address I am compiled to run at and the
 	 * address I am actually running at.
@@ -174,6 +177,9 @@ ENTRY(secondary_startup_64)
 	 * after the boot processor executes this code.
 	 */
 
+	/* Sanitize CPU configuration */
+	call verify_cpu
+
 	movq	$(init_level4_pgt - __START_KERNEL_map), %rax
 1:
 
@@ -288,6 +294,8 @@ ENTRY(secondary_startup_64)
 	pushq	%rax		# target address in negative space
 	lretq
 
+#include "verify_cpu.S"
+
 #ifdef CONFIG_HOTPLUG_CPU
 /*
  * Boot CPU0 entry point. It's called from play_dead(). Everything has been set
diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index 91964c6..935aff3 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -1156,6 +1156,14 @@ void __init setup_arch(char **cmdline_p)
 	clone_pgd_range(initial_page_table + KERNEL_PGD_BOUNDARY,
 			swapper_pg_dir     + KERNEL_PGD_BOUNDARY,
 			KERNEL_PGD_PTRS);
+
+	/*
+	 * sync back low identity map too.  It is used for example
+	 * in the 32-bit EFI stub.
+	 */
+	clone_pgd_range(initial_page_table,
+			swapper_pg_dir     + KERNEL_PGD_BOUNDARY,
+			min(KERNEL_PGD_PTRS, KERNEL_PGD_BOUNDARY));
 #endif
 
 	tboot_probe();
diff --git a/arch/x86/kernel/verify_cpu.S b/arch/x86/kernel/verify_cpu.S
index b9242ba..4cf401f 100644
--- a/arch/x86/kernel/verify_cpu.S
+++ b/arch/x86/kernel/verify_cpu.S
@@ -34,10 +34,11 @@
 #include <asm/msr-index.h>
 
 verify_cpu:
-	pushfl				# Save caller passed flags
-	pushl	$0			# Kill any dangerous flags
-	popfl
+	pushf				# Save caller passed flags
+	push	$0			# Kill any dangerous flags
+	popf
 
+#ifndef __x86_64__
 	pushfl				# standard way to check for cpuid
 	popl	%eax
 	movl	%eax,%ebx
@@ -48,6 +49,7 @@ verify_cpu:
 	popl	%eax
 	cmpl	%eax,%ebx
 	jz	verify_cpu_no_longmode	# cpu has no cpuid
+#endif
 
 	movl	$0x0,%eax		# See if cpuid 1 is implemented
 	cpuid
@@ -130,10 +132,10 @@ verify_cpu_sse_test:
 	jmp	verify_cpu_sse_test	# try again
 
 verify_cpu_no_longmode:
-	popfl				# Restore caller passed flags
+	popf				# Restore caller passed flags
 	movl $1,%eax
 	ret
 verify_cpu_sse_ok:
-	popfl				# Restore caller passed flags
+	popf				# Restore caller passed flags
 	xorl %eax, %eax
 	ret
diff --git a/drivers/net/can/sja1000/sja1000.c b/drivers/net/can/sja1000/sja1000.c
index f17c301..c2d0559 100755
--- a/drivers/net/can/sja1000/sja1000.c
+++ b/drivers/net/can/sja1000/sja1000.c
@@ -184,6 +184,9 @@ static void sja1000_start(struct net_device *dev)
 	priv->write_reg(priv, SJA1000_RXERR, 0x0);
 	priv->read_reg(priv, SJA1000_ECC);
 
+	/* clear interrupt flags */
+	priv->read_reg(priv, SJA1000_IR);
+
 	/* leave reset mode */
 	set_normal_mode(dev);
 }
diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index 8b6c923..d5643c1 100755
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -910,7 +910,7 @@ static void mvneta_defaults_set(struct mvneta_port *pp)
 	/* Set CPU queue access map - all CPUs have access to all RX
 	 * queues and to all TX queues
 	 */
-	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++)
+	for_each_present_cpu(cpu)
 		mvreg_write(pp, MVNETA_CPU_MAP(cpu),
 			    (MVNETA_CPU_RXQ_ACCESS_ALL_MASK |
 			     MVNETA_CPU_TXQ_ACCESS_ALL_MASK));
diff --git a/drivers/net/ethernet/mellanox/mlx4/cmd.c b/drivers/net/ethernet/mellanox/mlx4/cmd.c
index 28d706b..d64050f 100755
--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c
@@ -1836,7 +1836,7 @@ int mlx4_multi_func_init(struct mlx4_dev *dev)
 			spin_lock_init(&s_state->lock);
 		}
 
-		memset(&priv->mfunc.master.cmd_eqe, 0, dev->caps.eqe_size);
+		memset(&priv->mfunc.master.cmd_eqe, 0, sizeof(struct mlx4_eqe));
 		priv->mfunc.master.cmd_eqe.type = MLX4_EVENT_TYPE_CMD;
 		INIT_WORK(&priv->mfunc.master.comm_work,
 			  mlx4_master_comm_channel);
diff --git a/drivers/net/ethernet/mellanox/mlx4/eq.c b/drivers/net/ethernet/mellanox/mlx4/eq.c
index 6000342..16a1ccc 100755
--- a/drivers/net/ethernet/mellanox/mlx4/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c
@@ -183,7 +183,7 @@ static void slave_event(struct mlx4_dev *dev, u8 slave, struct mlx4_eqe *eqe)
 		return;
 	}
 
-	memcpy(s_eqe, eqe, dev->caps.eqe_size - 1);
+	memcpy(s_eqe, eqe, sizeof(struct mlx4_eqe) - 1);
 	s_eqe->slave_id = slave;
 	/* ensure all information is written before setting the ownersip bit */
 	wmb();
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index c5f9cb8..ff08be5 100755
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -731,10 +731,13 @@ static int stmmac_get_ts_info(struct net_device *dev,
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
 
-	if ((priv->hwts_tx_en) && (priv->hwts_rx_en)) {
+	if ((priv->dma_cap.time_stamp || priv->dma_cap.atime_stamp)) {
 
-		info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
+		info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |
+					SOF_TIMESTAMPING_TX_HARDWARE |
+					SOF_TIMESTAMPING_RX_SOFTWARE |
 					SOF_TIMESTAMPING_RX_HARDWARE |
+					SOF_TIMESTAMPING_SOFTWARE |
 					SOF_TIMESTAMPING_RAW_HARDWARE;
 
 		if (priv->ptp_clock)
diff --git a/drivers/net/ppp/pppoe.c b/drivers/net/ppp/pppoe.c
index eda9f3d..2840cf6 100755
--- a/drivers/net/ppp/pppoe.c
+++ b/drivers/net/ppp/pppoe.c
@@ -569,7 +569,7 @@ static int pppoe_release(struct socket *sock)
 
 	po = pppox_sk(sk);
 
-	if (sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND | PPPOX_ZOMBIE)) {
+	if (po->pppoe_dev) {
 		dev_put(po->pppoe_dev);
 		po->pppoe_dev = NULL;
 	}
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 2835bfe..b5d1152 100755
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -1545,9 +1545,9 @@ static int virtnet_probe(struct virtio_device *vdev)
 	/* Do we support "hardware" checksums? */
 	if (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {
 		/* This opens up the world of extra features. */
-		dev->hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;
+		dev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;
 		if (csum)
-			dev->features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;
+			dev->features |= NETIF_F_HW_CSUM | NETIF_F_SG;
 
 		if (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {
 			dev->hw_features |= NETIF_F_TSO | NETIF_F_UFO
diff --git a/drivers/net/wireless/mwifiex/debugfs.c b/drivers/net/wireless/mwifiex/debugfs.c
index a5f9875..f84e5d7 100755
--- a/drivers/net/wireless/mwifiex/debugfs.c
+++ b/drivers/net/wireless/mwifiex/debugfs.c
@@ -637,7 +637,7 @@ mwifiex_rdeeprom_read(struct file *file, char __user *ubuf,
 		(struct mwifiex_private *) file->private_data;
 	unsigned long addr = get_zeroed_page(GFP_KERNEL);
 	char *buf = (char *) addr;
-	int pos = 0, ret = 0, i;
+	int pos, ret, i;
 	u8 value[MAX_EEPROM_DATA];
 
 	if (!buf)
@@ -645,7 +645,7 @@ mwifiex_rdeeprom_read(struct file *file, char __user *ubuf,
 
 	if (saved_offset == -1) {
 		/* No command has been given */
-		pos += snprintf(buf, PAGE_SIZE, "0");
+		pos = snprintf(buf, PAGE_SIZE, "0");
 		goto done;
 	}
 
@@ -654,17 +654,17 @@ mwifiex_rdeeprom_read(struct file *file, char __user *ubuf,
 				  (u16) saved_bytes, value);
 	if (ret) {
 		ret = -EINVAL;
-		goto done;
+		goto out_free;
 	}
 
-	pos += snprintf(buf, PAGE_SIZE, "%d %d ", saved_offset, saved_bytes);
+	pos = snprintf(buf, PAGE_SIZE, "%d %d ", saved_offset, saved_bytes);
 
 	for (i = 0; i < saved_bytes; i++)
-		pos += snprintf(buf + strlen(buf), PAGE_SIZE, "%d ", value[i]);
-
-	ret = simple_read_from_buffer(ubuf, count, ppos, buf, pos);
+		pos += scnprintf(buf + pos, PAGE_SIZE - pos, "%d ", value[i]);
 
 done:
+	ret = simple_read_from_buffer(ubuf, count, ppos, buf, pos);
+out_free:
 	free_page(addr);
 	return ret;
 }
diff --git a/drivers/staging/rtl8712/usb_intf.c b/drivers/staging/rtl8712/usb_intf.c
index e3a005d..1d9ab22 100755
--- a/drivers/staging/rtl8712/usb_intf.c
+++ b/drivers/staging/rtl8712/usb_intf.c
@@ -144,6 +144,7 @@ static struct usb_device_id rtl871x_usb_id_tbl[] = {
 	{USB_DEVICE(0x0DF6, 0x0058)},
 	{USB_DEVICE(0x0DF6, 0x0049)},
 	{USB_DEVICE(0x0DF6, 0x004C)},
+	{USB_DEVICE(0x0DF6, 0x006C)},
 	{USB_DEVICE(0x0DF6, 0x0064)},
 	/* Skyworth */
 	{USB_DEVICE(0x14b2, 0x3300)},
diff --git a/drivers/usb/class/usblp.c b/drivers/usb/class/usblp.c
index d4c47d5..7ac5fac 100755
--- a/drivers/usb/class/usblp.c
+++ b/drivers/usb/class/usblp.c
@@ -870,11 +870,11 @@ static int usblp_wwait(struct usblp *usblp, int nonblock)
 
 	add_wait_queue(&usblp->wwait, &waita);
 	for (;;) {
-		set_current_state(TASK_INTERRUPTIBLE);
 		if (mutex_lock_interruptible(&usblp->mut)) {
 			rc = -EINTR;
 			break;
 		}
+		set_current_state(TASK_INTERRUPTIBLE);
 		rc = usblp_wtest(usblp, nonblock);
 		mutex_unlock(&usblp->mut);
 		if (rc <= 0)
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index da0caf3..462a7d5 100755
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -133,7 +133,7 @@ static inline struct musb *dev_to_musb(struct device *dev)
 /*-------------------------------------------------------------------------*/
 
 #ifndef CONFIG_BLACKFIN
-static int musb_ulpi_read(struct usb_phy *phy, u32 offset)
+static int musb_ulpi_read(struct usb_phy *phy, u32 reg)
 {
 	void __iomem *addr = phy->io_priv;
 	int	i = 0;
@@ -152,7 +152,7 @@ static int musb_ulpi_read(struct usb_phy *phy, u32 offset)
 	 * ULPICarKitControlDisableUTMI after clearing POWER_SUSPENDM.
 	 */
 
-	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)offset);
+	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)reg);
 	musb_writeb(addr, MUSB_ULPI_REG_CONTROL,
 			MUSB_ULPI_REG_REQ | MUSB_ULPI_RDN_WR);
 
@@ -177,7 +177,7 @@ out:
 	return ret;
 }
 
-static int musb_ulpi_write(struct usb_phy *phy, u32 offset, u32 data)
+static int musb_ulpi_write(struct usb_phy *phy, u32 val, u32 reg)
 {
 	void __iomem *addr = phy->io_priv;
 	int	i = 0;
@@ -192,8 +192,8 @@ static int musb_ulpi_write(struct usb_phy *phy, u32 offset, u32 data)
 	power &= ~MUSB_POWER_SUSPENDM;
 	musb_writeb(addr, MUSB_POWER, power);
 
-	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)offset);
-	musb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)data);
+	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)reg);
+	musb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)val);
 	musb_writeb(addr, MUSB_ULPI_REG_CONTROL, MUSB_ULPI_REG_REQ);
 
 	while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index bf7fbb9..4b971cc 100755
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -169,6 +169,7 @@ static void option_instat_callback(struct urb *urb);
 #define NOVATELWIRELESS_PRODUCT_HSPA_EMBEDDED_HIGHSPEED	0x9001
 #define NOVATELWIRELESS_PRODUCT_E362		0x9010
 #define NOVATELWIRELESS_PRODUCT_E371		0x9011
+#define NOVATELWIRELESS_PRODUCT_U620L		0x9022
 #define NOVATELWIRELESS_PRODUCT_G2		0xA010
 #define NOVATELWIRELESS_PRODUCT_MC551		0xB001
 
@@ -361,6 +362,7 @@ static void option_instat_callback(struct urb *urb);
 /* This is the 4G XS Stick W14 a.k.a. Mobilcom Debitel Surf-Stick *
  * It seems to contain a Qualcomm QSC6240/6290 chipset            */
 #define FOUR_G_SYSTEMS_PRODUCT_W14		0x9603
+#define FOUR_G_SYSTEMS_PRODUCT_W100		0x9b01
 
 /* iBall 3.5G connect wireless modem */
 #define IBALL_3_5G_CONNECT			0x9605
@@ -535,6 +537,11 @@ static const struct option_blacklist_info four_g_w14_blacklist = {
 	.sendsetup = BIT(0) | BIT(1),
 };
 
+static const struct option_blacklist_info four_g_w100_blacklist = {
+	.sendsetup = BIT(1) | BIT(2),
+	.reserved = BIT(3),
+};
+
 static const struct option_blacklist_info alcatel_x200_blacklist = {
 	.sendsetup = BIT(0) | BIT(1),
 	.reserved = BIT(4),
@@ -1068,6 +1075,7 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_MC551, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_E362, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_E371, 0xff, 0xff, 0xff) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_U620L, 0xff, 0x00, 0x00) },
 
 	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H01) },
 	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H01A) },
@@ -1649,6 +1657,9 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W14),
   	  .driver_info = (kernel_ulong_t)&four_g_w14_blacklist
   	},
+	{ USB_DEVICE(LONGCHEER_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W100),
+	  .driver_info = (kernel_ulong_t)&four_g_w100_blacklist
+	},
 	{ USB_DEVICE_INTERFACE_CLASS(LONGCHEER_VENDOR_ID, SPEEDUP_PRODUCT_SU9800, 0xff) },
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, ZOOM_PRODUCT_4597) },
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, IBALL_3_5G_CONNECT) },
diff --git a/include/net/inet_common.h b/include/net/inet_common.h
index 2340087..102fc42 100644
--- a/include/net/inet_common.h
+++ b/include/net/inet_common.h
@@ -40,7 +40,8 @@ extern int inet_ctl_sock_create(struct sock **sk, unsigned short family,
 
 static inline void inet_ctl_sock_destroy(struct sock *sk)
 {
-	sk_release_kernel(sk);
+	if (sk)
+		sk_release_kernel(sk);
 }
 
 #endif
diff --git a/net/bluetooth/hidp/core.c b/net/bluetooth/hidp/core.c
index de030f5..c605633 100644
--- a/net/bluetooth/hidp/core.c
+++ b/net/bluetooth/hidp/core.c
@@ -396,6 +396,20 @@ static void hidp_idle_timeout(unsigned long arg)
 {
 	struct hidp_session *session = (struct hidp_session *) arg;
 
+	/* The HIDP user-space API only contains calls to add and remove
+	 * devices. There is no way to forward events of any kind. Therefore,
+	 * we have to forcefully disconnect a device on idle-timeouts. This is
+	 * unfortunate and weird API design, but it is spec-compliant and
+	 * required for backwards-compatibility. Hence, on idle-timeout, we
+	 * signal driver-detach events, so poll() will be woken up with an
+	 * error-condition on both sockets.
+	 */
+
+	session->intr_sock->sk->sk_err = EUNATCH;
+	session->ctrl_sock->sk->sk_err = EUNATCH;
+	wake_up_interruptible(sk_sleep(session->intr_sock->sk));
+	wake_up_interruptible(sk_sleep(session->ctrl_sock->sk));
+
 	hidp_session_terminate(session);
 }
 
diff --git a/net/core/dst.c b/net/core/dst.c
index c0e0218..01f9980 100644
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@ -283,7 +283,7 @@ void dst_release(struct dst_entry *dst)
 
 		newrefcnt = atomic_dec_return(&dst->__refcnt);
 		WARN_ON(newrefcnt < 0);
-		if (unlikely(dst->flags & DST_NOCACHE) && !newrefcnt)
+		if (!newrefcnt && unlikely(dst->flags & DST_NOCACHE))
 			call_rcu(&dst->rcu_head, dst_destroy_rcu);
 	}
 }
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index 56d079b..6f5f943 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -1672,8 +1672,8 @@ static inline int ipmr_forward_finish(struct sk_buff *skb)
 {
 	struct ip_options *opt = &(IPCB(skb)->opt);
 
-	IP_INC_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_OUTFORWDATAGRAMS);
-	IP_ADD_STATS_BH(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_OUTOCTETS, skb->len);
+	IP_INC_STATS(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_OUTFORWDATAGRAMS);
+	IP_ADD_STATS(dev_net(skb_dst(skb)->dev), IPSTATS_MIB_OUTOCTETS, skb->len);
 
 	if (unlikely(opt->optlen))
 		ip_forward_options(skb);
@@ -1735,7 +1735,7 @@ static void ipmr_queue_xmit(struct net *net, struct mr_table *mrt,
 		 * to blackhole.
 		 */
 
-		IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_FRAGFAILS);
+		IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGFAILS);
 		ip_rt_put(rt);
 		goto out_free;
 	}
diff --git a/net/irda/irlmp.c b/net/irda/irlmp.c
index 98ad6ec..8ad1494 100644
--- a/net/irda/irlmp.c
+++ b/net/irda/irlmp.c
@@ -1876,7 +1876,7 @@ static void *irlmp_seq_hb_idx(struct irlmp_iter_state *iter, loff_t *off)
 	for (element = hashbin_get_first(iter->hashbin);
 	     element != NULL;
 	     element = hashbin_get_next(iter->hashbin)) {
-		if (!off || *off-- == 0) {
+		if (!off || (*off)-- == 0) {
 			/* NB: hashbin left locked */
 			return element;
 		}
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index e606e4a..952cb33 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -3074,7 +3074,7 @@ ieee80211_rx_mgmt_beacon(struct ieee80211_sub_if_data *sdata,
 
 	if (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&
 	    ifmgd->count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {
-		int sig = ifmgd->ave_beacon_signal;
+		int sig = ifmgd->ave_beacon_signal / 16;
 		int last_sig = ifmgd->last_ave_beacon_signal;
 
 		/*
diff --git a/net/rds/connection.c b/net/rds/connection.c
index 642ad42..e88bf39 100644
--- a/net/rds/connection.c
+++ b/net/rds/connection.c
@@ -177,6 +177,12 @@ static struct rds_connection *__rds_conn_create(__be32 laddr, __be32 faddr,
 		}
 	}
 
+	if (trans == NULL) {
+		kmem_cache_free(rds_conn_slab, conn);
+		conn = ERR_PTR(-ENODEV);
+		goto out;
+	}
+
 	conn->c_trans = trans;
 
 	ret = trans->conn_alloc(conn, gfp);
diff --git a/net/rds/tcp_recv.c b/net/rds/tcp_recv.c
index 4fac4f2..8b33d99 100644
--- a/net/rds/tcp_recv.c
+++ b/net/rds/tcp_recv.c
@@ -234,8 +234,15 @@ static int rds_tcp_data_recv(read_descriptor_t *desc, struct sk_buff *skb,
 			}
 
 			to_copy = min(tc->t_tinc_data_rem, left);
-			pskb_pull(clone, offset);
-			pskb_trim(clone, to_copy);
+			if (!pskb_pull(clone, offset) ||
+			    pskb_trim(clone, to_copy)) {
+				pr_warn("rds_tcp_data_recv: pull/trim failed "
+					"left %zu data_rem %zu skb_len %d\n",
+					left, tc->t_tinc_data_rem, skb->len);
+				kfree_skb(clone);
+				desc->error = -ENOMEM;
+				goto out;
+			}
 			skb_queue_tail(&tinc->ti_skb_list, clone);
 
 			rdsdebug("skb %p data %p len %d off %u to_copy %zu -> "
diff --git a/sound/usb/midi.c b/sound/usb/midi.c
index 9324913..dabbe05 100644
--- a/sound/usb/midi.c
+++ b/sound/usb/midi.c
@@ -174,6 +174,8 @@ struct snd_usb_midi_in_endpoint {
 		u8 running_status_length;
 	} ports[0x10];
 	u8 seen_f5;
+	bool in_sysex;
+	u8 last_cin;
 	u8 error_resubmit;
 	int current_port;
 };
@@ -465,6 +467,39 @@ static void snd_usbmidi_maudio_broken_running_status_input(
 }
 
 /*
+ * QinHeng CH345 is buggy: every second packet inside a SysEx has not CIN 4
+ * but the previously seen CIN, but still with three data bytes.
+ */
+static void ch345_broken_sysex_input(struct snd_usb_midi_in_endpoint *ep,
+				     uint8_t *buffer, int buffer_length)
+{
+	unsigned int i, cin, length;
+
+	for (i = 0; i + 3 < buffer_length; i += 4) {
+		if (buffer[i] == 0 && i > 0)
+			break;
+		cin = buffer[i] & 0x0f;
+		if (ep->in_sysex &&
+		    cin == ep->last_cin &&
+		    (buffer[i + 1 + (cin == 0x6)] & 0x80) == 0)
+			cin = 0x4;
+#if 0
+		if (buffer[i + 1] == 0x90) {
+			/*
+			 * Either a corrupted running status or a real note-on
+			 * message; impossible to detect reliably.
+			 */
+		}
+#endif
+		length = snd_usbmidi_cin_length[cin];
+		snd_usbmidi_input_data(ep, 0, &buffer[i + 1], length);
+		ep->in_sysex = cin == 0x4;
+		if (!ep->in_sysex)
+			ep->last_cin = cin;
+	}
+}
+
+/*
  * CME protocol: like the standard protocol, but SysEx commands are sent as a
  * single USB packet preceded by a 0x0F byte.
  */
@@ -650,6 +685,12 @@ static struct usb_protocol_ops snd_usbmidi_cme_ops = {
 	.output_packet = snd_usbmidi_output_standard_packet,
 };
 
+static struct usb_protocol_ops snd_usbmidi_ch345_broken_sysex_ops = {
+	.input = ch345_broken_sysex_input,
+	.output = snd_usbmidi_standard_output,
+	.output_packet = snd_usbmidi_output_standard_packet,
+};
+
 /*
  * AKAI MPD16 protocol:
  *
@@ -1326,6 +1367,7 @@ static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi* umidi,
 		 * Various chips declare a packet size larger than 4 bytes, but
 		 * do not actually work with larger packets:
 		 */
+	case USB_ID(0x0a67, 0x5011): /* Medeli DD305 */
 	case USB_ID(0x0a92, 0x1020): /* ESI M4U */
 	case USB_ID(0x1430, 0x474b): /* RedOctane GH MIDI INTERFACE */
 	case USB_ID(0x15ca, 0x0101): /* Textech USB Midi Cable */
@@ -2216,6 +2258,10 @@ int snd_usbmidi_create(struct snd_card *card,
 
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
+	case QUIRK_MIDI_CH345:
+		umidi->usb_protocol_ops = &snd_usbmidi_ch345_broken_sysex_ops;
+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
+		break;
 	default:
 		snd_printd(KERN_ERR "invalid quirk type %d\n", quirk->type);
 		err = -ENXIO;
diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h
index 45d586b..9ec5ce4 100644
--- a/sound/usb/quirks-table.h
+++ b/sound/usb/quirks-table.h
@@ -3041,6 +3041,17 @@ YAMAHA_DEVICE(0x7010, "UB99"),
 	.idProduct = 0x1020,
 },
 
+/* QinHeng devices */
+{
+	USB_DEVICE(0x1a86, 0x752d),
+	.driver_info = (unsigned long) &(const struct snd_usb_audio_quirk) {
+		.vendor_name = "QinHeng",
+		.product_name = "CH345",
+		.ifnum = 1,
+		.type = QUIRK_MIDI_CH345
+	}
+},
+
 /* KeithMcMillen Stringport */
 {
 	USB_DEVICE(0x1f38, 0x0001),
diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c
index 734c657..94cd28c 100644
--- a/sound/usb/quirks.c
+++ b/sound/usb/quirks.c
@@ -313,6 +313,7 @@ int snd_usb_create_quirk(struct snd_usb_audio *chip,
 		[QUIRK_MIDI_CME] = create_any_midi_quirk,
 		[QUIRK_MIDI_AKAI] = create_any_midi_quirk,
 		[QUIRK_MIDI_FTDI] = create_any_midi_quirk,
+		[QUIRK_MIDI_CH345] = create_any_midi_quirk,
 		[QUIRK_AUDIO_STANDARD_INTERFACE] = create_standard_audio_quirk,
 		[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,
 		[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,
diff --git a/sound/usb/usbaudio.h b/sound/usb/usbaudio.h
index bc43bca..d6f3fef 100644
--- a/sound/usb/usbaudio.h
+++ b/sound/usb/usbaudio.h
@@ -83,6 +83,7 @@ enum quirk_type {
 	QUIRK_MIDI_AKAI,
 	QUIRK_MIDI_US122L,
 	QUIRK_MIDI_FTDI,
+	QUIRK_MIDI_CH345,
 	QUIRK_AUDIO_STANDARD_INTERFACE,
 	QUIRK_AUDIO_FIXED_ENDPOINT,
 	QUIRK_AUDIO_EDIROL_UAXX,
-- 
2.7.4

